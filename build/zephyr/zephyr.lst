
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

10000000 <cy_m0p_image>:
10000000:	00 20 00 08 eb 00 00 10 0d 00 00 00 4d 01 00 10     . ..........M...
	...
1000002c:	49 01 00 10 00 00 00 00 00 00 00 00 49 01 00 10     I...........I...
1000003c:	49 01 00 10 49 01 00 10 49 01 00 10 49 01 00 10     I...I...I...I...
1000004c:	49 01 00 10 49 01 00 10 49 01 00 10 49 01 00 10     I...I...I...I...
1000005c:	49 01 00 10 49 01 00 10 49 01 00 10 49 01 00 10     I...I...I...I...
1000006c:	49 01 00 10 49 01 00 10 49 01 00 10 49 01 00 10     I...I...I...I...
1000007c:	49 01 00 10 10 b5 06 4c 23 78 00 2b 07 d1 05 4b     I......L#x.+...K
1000008c:	00 2b 02 d0 04 48 00 e0 00 bf 01 23 23 70 10 bd     .+...H.....##p..
1000009c:	b0 03 00 08 00 00 00 00 14 15 00 10 04 4b 10 b5     .............K..
100000ac:	00 2b 03 d0 03 49 04 48 00 e0 00 bf 10 bd c0 46     .+...I.H.......F
100000bc:	00 00 00 00 b4 03 00 08 14 15 00 10 02 30 80 08     .............0..
100000cc:	03 d0 01 30 02 38 fc d1 c0 46 c0 46 70 47 ef f3     ...0.8...F.FpG..
100000dc:	10 80 72 b6 70 47 80 f3 10 88 70 47 70 47 ff f7     ..r.pG....pGpG..
100000ec:	fd ff 72 b6 0f 4c 10 4d ac 42 09 da 21 68 62 68     ..r..L.M.B..!hbh
100000fc:	a3 68 04 3b 02 db c8 58 d0 50 fa e7 0c 34 f3 e7     .h.;...X.P...4..
1000010c:	0a 49 0b 4a 00 20 52 1a 02 dd 04 3a 88 50 fc dc     .I.J. R....:.P..
1000011c:	08 48 09 49 08 60 bf f3 4f 8f 00 f0 ed fe 00 f0     .H.I.`..O.......
1000012c:	9b fe fe e7 20 15 00 10 38 15 00 10 b0 03 00 08     .... ...8.......
1000013c:	c8 05 00 08 00 00 00 08 08 ed 00 e0 fe e7 fe e7     ................
1000014c:	00 b5 04 20 71 46 08 42 02 d0 ef f3 09 80 02 e0     ... qF.B........
1000015c:	ef f3 08 80 04 30 00 f0 91 fc fe e7 01 4b 18 60     .....0.......K.`
1000016c:	70 47 c0 46 cc 03 00 08 04 4b 1b 68 1a 00 ba 32     pG.F.....K.h...2
1000017c:	12 88 1b 6a 50 43 c0 18 70 47 c0 46 cc 03 00 08     ...jPC..pG.F....
1000018c:	a0 23 00 b5 1b 06 98 42 26 d0 15 d8 80 28 25 d0     .#.....B&....(%.
1000019c:	0a d8 10 28 24 d0 40 28 24 d0 00 28 0b d0 15 48     ...($.@($..(...H
100001ac:	09 e0 a4 20 c0 03 06 e0 80 22 13 4b 52 00 90 42     ... .....".KR..B
100001bc:	1c d0 98 42 f3 d1 00 bd 10 4b 98 42 18 d0 10 4b     ...B.....K.B...K
100001cc:	c0 18 04 28 eb d8 00 f0 35 ff ec ea 0f 03 05 00     ...(....5.......
100001dc:	0c 48 f0 e7 0c 48 ee e7 00 20 ec e7 0b 48 ea e7     .H...H... ...H..
100001ec:	0b 48 e8 e7 0b 48 e6 e7 0b 48 e4 e7 18 00 e2 e7     .H...H...H......
100001fc:	a0 20 d7 e7 ff 00 52 00 06 00 52 00 09 00 00 a0     . ....R...R.....
1000020c:	ff ff ff 0f 02 00 52 00 03 00 52 00 05 00 52 00     ......R...R...R.
1000021c:	01 00 50 00 02 00 50 00 01 00 52 00 10 b5 00 20     ..P...P...R.... 
1000022c:	ff f7 a2 ff 0a 4b 1c 68 23 00 bc 33 1b 68 c0 18     .....K.h#..3.h..
1000023c:	03 68 00 2b 0a db 07 4b 18 68 ff f7 a1 ff 01 22     .h.+...K.h....."
1000024c:	63 68 9a 60 9a 68 00 2a fc d1 10 bd 02 48 fc e7     ch.`.h.*.....H..
1000025c:	cc 03 00 08 d0 03 00 08 02 00 50 00 06 4b 1b 68     ..........P..K.h
1000026c:	bc 33 1b 68 c3 18 1b 68 00 2b 03 da 89 b2 41 60     .3.h...h.+....A`
1000027c:	00 20 70 47 01 48 fc e7 cc 03 00 08 01 00 8a 00     . pG.H..........
1000028c:	03 68 00 2b 04 da 89 b2 c2 60 81 60 00 20 70 47     .h.+.....`.`. pG
1000029c:	00 48 fc e7 01 00 8a 00 06 4b 1b 68 bc 33 1b 68     .H.......K.h.3.h
100002ac:	c3 18 1b 68 00 2b 03 da c3 68 00 20 0b 60 70 47     ...h.+...h. .`pG
100002bc:	01 48 fc e7 cc 03 00 08 01 00 8a 00 02 4b 1a 68     .H...........K.h
100002cc:	00 2a 00 d1 18 60 70 47 e4 03 00 08 f0 b5 2c 24     .*...`pG......,$
100002dc:	44 43 15 48 1f 00 00 68 1e 0a 00 19 ff 24 26 40     DC.H...h.....$&@
100002ec:	27 40 12 4c 1b 0c 25 68 07 60 2c 6a 46 60 83 60     '@.L..%h.`,jF`.`
100002fc:	ba 35 2d 88 6f 43 3f 19 07 61 37 00 80 37 7f 01     .5-.oC?..a7..7..
1000030c:	e7 19 0b 4d 76 01 47 61 a4 19 1f 04 3b 43 64 19     ...Mv.Ga....;Cd.
1000031c:	23 60 00 23 83 61 05 9b c2 61 01 62 00 2b 01 d0     #`.#.a...a.b.+..
1000032c:	1b 88 83 81 f0 bd c0 46 e4 03 00 08 cc 03 00 08     .......F........
1000033c:	08 10 00 00 f0 b5 83 68 85 b0 02 ad 2b 80 03 68     .......h....+..h
1000034c:	06 6a 17 33 6b 80 43 68 47 6a 00 95 82 6a c1 6a     .j.3k.ChGj...j.j
1000035c:	04 00 03 93 03 69 c0 68 ff f7 b8 ff 00 21 3b 00     .....i.h.....!;.
1000036c:	0a 00 30 00 00 91 ff f7 b1 ff 28 00 21 6b 00 f0     ..0.......(.!k..
1000037c:	39 fb 00 22 ab 5e 00 2b 06 db 1f 22 13 40 1e 3a     9..".^.+...".@.:
1000038c:	9a 40 13 00 01 4a 13 60 05 b0 f0 bd 00 e1 00 e0     .@...J.`........
1000039c:	f7 b5 2c 26 13 4c 70 43 4e 43 24 68 01 93 25 18     ..,&.LpCNC$h..%.
100003ac:	a4 19 2e 69 00 2e 19 d0 a0 69 00 28 18 d1 31 68     ...i.....i.(..1h
100003bc:	00 29 15 da 01 21 6f 68 0d 00 63 68 9d 40 ac 46     .)...!oh..ch.@.F
100003cc:	13 68 9d b2 63 46 1b 04 1d 43 15 60 f2 60 a1 61     .h..cF...C.`.`.a
100003dc:	b9 40 01 9b 89 b2 63 62 b1 60 fe bd 02 48 fc e7     .@....cb.`...H..
100003ec:	02 48 fa e7 e4 03 00 08 04 02 8a 00 07 02 8a 00     .H..............
100003fc:	73 b5 00 26 42 69 04 00 d5 68 01 96 2b 0c b3 42     s..&Bi...h..+..B
1000040c:	21 d0 1b 04 13 60 13 68 19 4b 00 69 1b 68 bc 33     !....`.h.K.i.h.3
1000041c:	1b 68 c3 18 1b 68 b3 42 15 da 01 a9 ff f7 3c ff     .h...h.B......<.
1000042c:	b0 42 0c d1 01 98 e2 69 03 68 1e 0c db b2 9a 42     .B.....i.h.....B
1000043c:	05 d9 22 6a 9b 00 9b 58 00 2b 00 d0 98 47 31 00     .."j...X.+...G1.
1000044c:	20 69 ff f7 0b ff ad b2 00 2d 09 d0 63 69 1d 60      i.......-..ci.`
1000045c:	00 25 1b 68 63 6a ab 42 05 d0 98 47 65 62 a5 61     .%.hcj.B...Geb.a
1000046c:	63 69 1b 68 73 bd a3 6a 00 2b f8 d0 98 47 f6 e7     ci.hs..j.+...G..
1000047c:	cc 03 00 08 2c 23 10 b5 43 43 03 4a 10 68 c0 18     ....,#..CC.J.h..
1000048c:	ff f7 b6 ff 10 bd c0 46 e4 03 00 08 1a 4b 70 b5     .......F.....Kp.
1000049c:	1a 68 0c 00 13 00 33 33 1b 78 83 42 2a d9 00 29     .h....33.x.B*..)
100004ac:	28 d0 0d 68 1f 21 2b 00 0b 40 0d 42 22 d1 11 00     (..h.!+..@.B"...
100004bc:	ba 31 09 88 12 6a 48 43 19 00 10 4d 80 18 28 60     .1...jHC...M..(`
100004cc:	22 68 52 09 93 42 10 d3 00 21 ff f7 c7 fe 00 21     "hR..B...!.....!
100004dc:	22 00 28 68 ff f7 d4 fe 01 1e 04 d1 28 68 ff f7     ".(h........(h..
100004ec:	bd fe 00 28 00 d0 06 48 70 bd 66 68 9a 00 91 51     ...(...Hp.fh...Q
100004fc:	01 33 e5 e7 03 48 f7 e7 cc 03 00 08 e8 03 00 08     .3...H..........
1000050c:	01 01 8a 00 03 01 8a 00 10 b5 04 00 08 00 00 2a     ...............*
1000051c:	0c d1 00 29 13 d1 0b 4b 1a 68 13 00 ba 33 1b 88     ...)...K.h...3..
1000052c:	12 6a 63 43 9b 18 08 4a 13 60 10 bd 00 29 06 d0     .jcC...J.`...)..
1000053c:	06 49 08 60 20 00 4a 60 ff f7 a8 ff f5 e7 04 48     .I.` .J`.......H
1000054c:	f3 e7 c0 46 cc 03 00 08 e8 03 00 08 78 03 00 08     ...F........x...
1000055c:	03 01 8a 00 f7 b5 18 4f 04 00 3b 68 01 91 de 68     .......O..;h...h
1000056c:	33 68 83 42 26 d9 00 25 a9 42 02 d1 ff f7 af fd     3h.B&..%.B......
1000057c:	05 00 38 68 03 68 00 2b 1a da 1f 22 01 23 22 40     ..8h.h.+...".#"@
1000058c:	93 40 64 09 72 68 a4 00 14 19 22 68 13 42 0d d0     .@d.rh...."h.B..
1000059c:	9a 43 22 60 00 24 00 21 ff f7 60 fe 01 9b 00 2b     .C"`.$.!..`....+
100005ac:	02 d1 28 00 ff f7 97 fd 20 00 fe bd 03 4c f2 e7     ..(..... ....L..
100005bc:	03 4c f3 e7 03 4c f7 e7 e8 03 00 08 02 01 88 00     .L...L..........
100005cc:	03 01 88 00 04 01 8a 00 0a 4b 1b 68 db 68 1a 68     .........K.h.h.h
100005dc:	82 42 0d d9 59 68 1f 23 42 09 18 40 1e 3b 83 40     .B..Yh.#B..@.;.@
100005ec:	92 00 50 58 18 40 43 1e 98 41 03 4b c0 18 70 47     ..PX.@C..A.K..pG
100005fc:	02 48 fc e7 e8 03 00 08 00 01 88 00 04 01 8a 00     .H..............
1000060c:	05 4b 1b 68 1a 00 88 32 1b 68 12 68 9b 18 18 68     .K.h...2.h.h...h
1000061c:	00 0a c0 b2 70 47 c0 46 cc 03 00 08 04 4b 1b 68     ....pG.F.....K.h
1000062c:	1a 00 88 32 1b 68 12 68 9b 18 18 68 00 0e 70 47     ...2.h.h...h..pG
1000063c:	cc 03 00 08 03 4b e0 30 80 00 c0 58 80 06 80 0f     .....K.0...X....
1000064c:	70 47 c0 46 00 00 26 40 02 4b 18 69 40 07 c0 0f     pG.F..&@.K.i@...
1000065c:	70 47 c0 46 00 00 27 40 a6 22 05 49 d2 00 8b 58     pG.F..'@.".I...X
1000066c:	02 20 db 43 9b 07 02 d0 01 23 88 58 18 40 70 47     . .C.....#.X.@pG
1000067c:	00 00 26 40 10 b5 ff f7 ef ff 00 23 02 28 01 d1     ..&@.......#.(..
1000068c:	01 4b 1b 68 18 00 10 bd f0 03 00 08 09 4a 83 00     .K.h.........J..
1000069c:	9b 18 d0 22 92 00 98 58 07 22 10 40 04 28 07 d1     ..."...X.".@.(..
100006ac:	c0 22 92 00 98 58 1f 23 03 40 80 20 40 00 18 43     ."...X.#.@. @..C
100006bc:	70 47 c0 46 00 00 26 40 10 b5 ff f7 e7 ff 88 23     pG.F..&@.......#
100006cc:	5b 00 98 42 1a d0 09 d8 01 28 11 d0 02 28 12 d0     [..B.....(...(..
100006dc:	43 42 58 41 11 4b 40 42 18 40 10 bd 12 23 ff 33     CBXA.K@B.@...#.3
100006ec:	98 42 13 d0 14 23 ff 33 98 42 14 d0 00 20 f4 e7     .B...#.3.B... ..
100006fc:	0b 4b 18 68 f1 e7 ff f7 bd ff ee e7 09 4a 0a 4b     .K.h.........J.K
1000070c:	d3 58 00 2b f2 da 80 20 00 02 e6 e7 ff f7 9c ff     .X.+... ........
1000071c:	00 28 eb d0 f7 e7 03 4a 04 4b f1 e7 00 12 7a 00     .(.....J.K....z.
1000072c:	ec 03 00 08 00 00 26 40 0c 05 00 00 3c 05 00 00     ......&@....<...
1000073c:	b0 23 15 4a db 00 d3 58 10 b5 99 03 db 01 db 0f     .#.J...X........
1000074c:	89 0b c3 71 11 4b 01 60 d3 58 0f 24 d9 04 db 01     ...q.K.`.X.$....
1000075c:	db 0d 03 81 b1 23 db 00 d3 58 c9 0c 81 80 19 00     .....#...X......
1000076c:	21 40 81 72 19 09 21 40 c1 72 d9 02 9b 00 9b 0f     !@.r..!@.r......
1000077c:	83 73 07 4b c9 0c d3 58 81 81 5a 05 db 01 52 0f     .s.K...X..Z...R.
1000078c:	db 0d 82 71 03 82 10 bd 00 00 26 40 84 05 00 00     ...q......&@....
1000079c:	8c 05 00 00 80 30 03 4b ff 30 80 00 c0 58 c0 0f     .....0.K.0...X..
100007ac:	70 47 c0 46 00 00 26 40 10 b5 10 4b 42 1e 1b 68     pG.F..&@...KB..h
100007bc:	3f 33 1b 78 93 42 16 d9 7f 22 1f 24 80 30 0c 4b     ?3.x.B...".$.0.K
100007cc:	ff 30 80 00 c3 58 1a 40 0a 70 1a 0c 22 40 18 0a     .0...X.@.p.."@..
100007dc:	8a 70 1a 01 20 40 e2 40 48 70 00 20 9b 00 9b 0f     .p.. @.@Hp. ....
100007ec:	ca 70 0b 71 10 bd 03 48 fc e7 c0 46 cc 03 00 08     .p.q...H...F....
100007fc:	00 00 26 40 01 00 4a 00 f0 b5 89 b0 03 ac 20 00     ..&@..J....... .
1000080c:	ff f7 96 ff b0 23 1a 4a db 00 d2 58 00 23 9a 42     .....#.J...X.#.B
1000081c:	03 da a3 7b 02 3b 5a 1e 93 41 e5 79 00 26 6a 1e     ...{.;Z..A.y.&j.
1000082c:	95 41 01 35 b3 42 20 d0 a4 88 b4 42 1d d0 30 00     .A.5.B ....B..0.
1000083c:	03 9f ff f7 41 ff 2a 00 33 00 31 00 01 90 20 00     ....A.*.3.1... .
1000084c:	00 f0 ae fc 0c 00 05 00 33 00 3a 00 31 00 01 98     ........3.:.1...
1000085c:	00 f0 a6 fc e6 07 6a 08 32 43 63 08 80 18 59 41     ......j.2Cc...YA
1000086c:	2a 00 23 00 00 f0 7c fc 06 00 30 00 09 b0 f0 bd     *.#...|...0.....
1000087c:	00 00 26 40 f7 b5 23 4b 06 00 1b 68 3f 33 1b 78     ..&@..#K...h?3.x
1000088c:	00 2b 08 d0 00 28 3b d0 83 42 04 d3 69 46 ff f7     .+...(;..B..iF..
1000089c:	8b ff 04 1e 01 d0 00 26 32 e0 30 00 ff f7 7a ff     .......&2.0...z.
100008ac:	23 00 00 28 05 d0 6b 46 1c 79 02 3c 23 00 5a 1e     #..(..kF.y.<#.Z.
100008bc:	93 41 6a 46 54 78 00 2b ed d0 00 2c eb d0 95 78     .AjFTx.+...,...x
100008cc:	00 2d e8 d0 30 00 17 78 ff f7 f6 fe 00 23 06 00     .-..0..x.....#..
100008dc:	2a 00 20 00 19 00 00 f0 63 fc 00 23 0c 00 05 00     *. .....c..#....
100008ec:	3a 00 30 00 19 00 00 f0 5b fc e6 07 6a 08 32 43     :.0.....[...j.2C
100008fc:	63 08 80 18 59 41 2a 00 23 00 00 f0 31 fc 06 00     c...YA*.#...1...
1000090c:	30 00 fe bd cc 03 00 08 10 b5 04 1e 04 d1 ff f7     0...............
1000091c:	73 ff 00 28 06 d0 08 e0 06 4b 1b 68 3f 33 1b 78     s..(.....K.h?3.x
1000092c:	83 42 03 d2 20 00 ff f7 c7 fe 10 bd ff f7 a2 ff     .B.. ...........
1000093c:	ef e7 c0 46 cc 03 00 08 70 b5 05 00 ff f7 7a fe     ...F....p.....z.
1000094c:	e0 35 07 4b ad 00 04 00 e8 58 0f 23 18 40 ff f7     .5.K.....X.#.@..
1000095c:	db ff 01 23 a3 40 5b 08 18 18 e0 40 70 bd c0 46     ...#.@[....@p..F
1000096c:	00 00 26 40 14 4b 30 b5 1c 68 23 00 2c 33 1a 78     ..&@.K0..h#.,3.x
1000097c:	07 23 1f 2a 15 d8 82 08 15 00 9d 43 2b 1e 0f d1     .#.*.......C+...
1000098c:	03 33 18 40 98 40 81 40 23 68 92 00 20 33 9b 18     .3.@.@.@#h.. 3..
1000099c:	0a 00 ff 21 81 40 1c 68 62 40 11 40 61 40 19 60     ...!.@.hb@.@a@.`
100009ac:	30 bd 18 40 80 23 1b 06 18 43 80 23 9b 01 22 68     0..@.#...C.#.."h
100009bc:	c9 18 89 00 88 50 f3 e7 cc 03 00 08 06 4b 10 b5     .....P.......K..
100009cc:	9a 68 06 4c 10 30 83 00 a2 42 02 d1 98 58 99 50     .h.L.0...B...X.P
100009dc:	10 bd 03 4a d0 58 fb e7 00 ed 00 e0 00 00 00 08     ...J.X..........
100009ec:	00 00 00 10 f8 b5 06 00 0d 00 00 28 3a d0 00 23     ...........(:..#
100009fc:	c0 5e 00 28 28 db 71 88 ff f7 b4 ff 00 24 ff 22     .^.((.q......$."
10000a0c:	03 27 94 46 00 23 f0 5e 71 68 07 40 ff 00 66 46     .'.F.#.^qh.@..fF
10000a1c:	ba 40 89 01 31 40 d2 43 b9 40 83 b2 00 28 15 db     .@..1@.C.@...(..
10000a2c:	11 4e 83 08 9b 00 9b 19 c0 26 b6 00 9f 59 3a 40     .N.......&...Y:@
10000a3c:	11 43 99 51 0d 4b 9a 68 0d 4b 9a 42 02 d1 29 00     .C.Q.K.h.K.B..).
10000a4c:	ff f7 bc ff 20 00 f8 bd 0a 4c d8 e7 0f 26 33 40     .... ....L...&3@
10000a5c:	08 3b 06 4e 9b 08 9b 00 9b 19 de 69 32 40 11 43     .;.N.......i2@.C
10000a6c:	d9 61 e7 e7 03 4c ed e7 00 e1 00 e0 00 ed 00 e0     .a...L..........
10000a7c:	00 00 00 08 01 00 56 00 fe e7 00 00 02 68 0a 4b     ......V......h.K
10000a8c:	10 b5 1a 60 42 68 5a 60 82 68 9a 60 c2 68 da 60     ...`BhZ`.h.`.h.`
10000a9c:	02 69 1a 61 42 69 5a 61 82 69 9a 61 c2 69 da 61     .i.aBiZa.i.a.i.a
10000aac:	ff f7 ea ff 10 bd c0 46 90 03 00 08 b0 23 5b 05     .......F.....#[.
10000abc:	5a 78 21 20 00 2a 01 d0 58 78 c0 b2 70 47 b0 23     Zx! .*..Xx..pG.#
10000acc:	5b 05 9a 89 00 2a 02 d0 98 89 80 b2 70 47 80 20     [....*......pG. 
10000adc:	40 00 fb e7 7f b5 27 4b 86 00 0d 00 f4 58 04 29     @.....'K.....X.)
10000aec:	01 d0 01 29 27 d1 00 20 0f e0 a3 68 2b 42 0b d1     ...)'.. ...h+B..
10000afc:	e3 68 29 00 1a 68 5b 68 02 92 01 93 03 93 02 a8     .h)..h[h........
10000b0c:	23 68 98 47 1c 4b 1c 60 64 69 00 2c 0b d0 1b 4b     #h.G.K.`di.,...K
10000b1c:	98 42 ea d1 01 2d e8 d1 17 4b 18 48 1a 68 18 4b     .B...-...K.H.h.K
10000b2c:	9a 51 04 b0 70 bd 01 2d fb d1 14 4b 98 42 f3 d0     .Q..p..-...K.B..
10000b3c:	13 4b 9c 51 f5 e7 02 29 15 d0 26 00 64 69 00 2c     .K.Q...)..&.di.,
10000b4c:	fb d1 00 20 00 2e ec d0 b3 68 2b 42 09 d1 f3 68     ... .....h+B...h
10000b5c:	29 00 1a 68 5b 68 02 92 01 93 03 93 02 a8 33 68     )..h[h........3h
10000b6c:	98 47 36 69 ee e7 04 4b 1b 68 18 1e d9 d0 1e 69     .G6i...K.h.....i
10000b7c:	e7 e7 c0 46 34 04 00 08 30 04 00 08 ff 00 42 00     ...F4...0.....B.
10000b8c:	1c 04 00 08 1a 4b 1b 68 19 00 88 31 1a 68 09 68     .....K.h...1.h.h
10000b9c:	51 18 09 68 01 62 19 00 8c 31 09 68 52 18 12 68     Q..h.b...1.hR..h
10000bac:	42 62 1a 00 46 32 12 78 00 2a 1f d0 9a 68 e0 32     Bb..F2.x.*...h.2
10000bbc:	12 68 d2 06 1a d5 f2 22 db 68 d2 01 9a 58 02 60     .h.....".h...X.`
10000bcc:	f0 22 d2 01 9a 58 42 60 0a 4a 9a 58 82 60 0a 4a     ."...XB`.J.X.`.J
10000bdc:	9a 58 c2 60 09 4a 9a 58 02 61 09 4a 9a 58 42 61     .X.`.J.X.a.J.XBa
10000bec:	08 4a 9a 58 82 61 08 4a 9b 58 c3 61 70 47 c0 46     .J.X.a.J.X.apG.F
10000bfc:	cc 03 00 08 04 78 00 00 08 78 00 00 0c 78 00 00     .....x...x...x..
10000c0c:	10 78 00 00 14 78 00 00 18 78 00 00 1a 4b 1b 68     .x...x...x...K.h
10000c1c:	1a 00 88 32 19 68 12 68 8a 18 01 6a 11 60 1a 00     ...2.h.h...j.`..
10000c2c:	8c 32 19 68 12 68 8a 18 41 6a 11 60 1a 00 46 32     .2.h.h..Aj.`..F2
10000c3c:	12 78 00 2a 1e d0 9a 68 e0 32 12 68 d2 06 19 d5     .x.*...h.2.h....
10000c4c:	f0 22 41 68 db 68 d2 01 99 50 81 68 0b 4a 99 50     ."Ah.h...P.h.J.P
10000c5c:	c1 68 0b 4a 99 50 01 69 0a 4a 99 50 41 69 0a 4a     .h.J.P.i.J.PAi.J
10000c6c:	99 50 81 69 09 4a 99 50 c1 69 09 4a 99 50 01 68     .P.i.J.P.i.J.P.h
10000c7c:	e8 32 99 50 70 47 c0 46 cc 03 00 08 04 78 00 00     .2.PpG.F.....x..
10000c8c:	08 78 00 00 0c 78 00 00 10 78 00 00 14 78 00 00     .x...x...x...x..
10000c9c:	18 78 00 00 f7 b5 07 00 ff f7 08 ff 5d 4d 06 00     .x..........]M..
10000cac:	6b 68 00 2b 00 d0 7d e0 ff f7 11 fa 6b 68 00 90     kh.+..}.....kh..
10000cbc:	00 2b 00 d0 89 e0 58 4c 22 68 13 00 ba 33 19 88     .+....XL"h...3..
10000ccc:	07 23 4b 43 12 6a 9b 18 1a 68 00 2a fc da db 68     .#KC.j...h.*...h
10000cdc:	da 00 21 d5 1b 0f 1b 07 50 48 01 93 ff f7 52 ff     ..!.....PH....R.
10000cec:	20 68 4f 49 03 00 88 33 1c 68 03 68 1c 19 23 68      hOI...3.h.h..#h
10000cfc:	0b 40 21 2e 00 d0 6d e0 90 22 12 01 13 43 23 60     .@!...m.."...C#`
10000d0c:	03 00 8c 33 00 68 1b 68 c3 18 18 68 01 40 0a 43     ...3.h.h...h.@.C
10000d1c:	1a 60 42 4b 01 9a 13 43 80 22 3f 4e 92 05 31 68     .`BK...C."?N..1h
10000d2c:	13 43 0a 00 ba 32 10 88 07 22 00 24 42 43 09 6a     .C...2...".$BC.j
10000d3c:	52 18 d3 60 54 60 53 68 ff f7 c1 fe 80 23 5b 00     R..`T`Sh.....#[.
10000d4c:	98 42 4a d1 38 00 00 f0 5d fb 32 68 13 00 ba 33     .BJ.8...].2h...3
10000d5c:	19 88 07 23 4b 43 12 6a 9b 18 1a 68 00 2a fc da     ...#KC.j...h.*..
10000d6c:	df 68 fb 00 03 d5 38 01 00 09 ff f7 4f ff 2d 4b     .h....8.....O.-K
10000d7c:	32 68 1f 40 13 00 ba 33 19 88 07 23 4b 43 12 6a     2h.@...3...#KC.j
10000d8c:	00 98 9b 18 00 22 df 60 5a 60 ff f7 a4 f9 00 2c     .....".`Z`.....,
10000d9c:	0f d1 6b 68 00 2b 03 d0 08 21 01 20 ff f7 9a fe     ..kh.+...!. ....
10000dac:	20 00 fe bd 01 21 08 00 ff f7 94 fe 04 1e 00 d1      ....!..........
10000dbc:	7a e7 6b 68 00 2b 03 d0 02 21 01 20 ff f7 8a fe     z.kh.+...!. ....
10000dcc:	19 4b 9c 42 ec d0 19 4c ea e7 04 21 01 20 ff f7     .K.B...L...!. ..
10000ddc:	81 fe 70 e7 80 22 52 00 90 e7 33 68 1a 00 bc 32     ..p.."R...3h...2
10000dec:	19 6a 12 68 52 18 11 68 00 29 10 db ba 33 1b 88     .j.hR..h.)...3..
10000dfc:	9a 18 13 68 00 2b 0a db 04 23 0d 4a 11 69 0b 43     ...h.+...#.J.i.C
10000e0c:	13 61 01 2f 01 d0 30 bf 9f e7 20 bf 9d e7 06 4c     .a./..0... ....L
10000e1c:	9b e7 c0 46 34 04 00 08 cc 03 00 08 f4 03 00 08     ...F4...........
10000e2c:	ff 00 ff ff ff ff ff df 05 00 42 00 ff 00 42 00     ..........B...B.
10000e3c:	00 ed 00 e0 c0 22 80 20 06 49 52 00 8b 58 c0 05     .....". .IR..X..
10000e4c:	9b 00 9b 08 03 43 8b 50 80 23 88 58 1b 06 03 43     .....C.P.#.X...C
10000e5c:	8b 50 70 47 00 00 26 40 10 b5 62 b6 03 48 00 f0     .PpG..&@..b..H..
10000e6c:	c3 f8 00 20 ff f7 16 ff fb e7 c0 46 00 20 00 10     ... .......F. ..
10000e7c:	10 b5 00 20 ff f7 fe fa 10 bd 70 47 10 b5 00 20     ... ......pG... 
10000e8c:	ff f7 5a fd 04 1e 28 d0 14 4b 18 60 ff f7 c6 fb     ..Z...(..K.`....
10000e9c:	41 1c 20 00 00 f0 d8 f8 11 4b 04 00 18 60 ff f7     A. ......K...`..
10000eac:	af fb 41 1c 20 00 00 f0 cf f8 04 00 0d 4b 01 3c     ..A. ........K.<
10000ebc:	18 60 0d 49 20 00 00 f0 c7 f8 fa 21 0b 4b 01 30     .`.I ......!.K.0
10000ecc:	18 70 89 00 20 00 00 f0 bf f8 09 4b 01 30 18 60     .p.. ......K.0.`
10000edc:	00 20 ff f7 31 fd 07 4b 18 60 10 bd 88 00 00 08     . ..1..K.`......
10000eec:	8c 00 00 08 80 00 00 08 40 42 0f 00 94 00 00 08     ........@B......
10000efc:	90 00 00 08 84 00 00 08 10 b5 20 48 ff f7 2e f9     .......... H....
10000f0c:	b0 22 e0 21 30 20 1e 4c d2 00 a3 58 89 00 5b 00     .".!0 .L...X..[.
10000f1c:	5b 08 a3 50 63 58 83 43 63 50 80 23 5b 04 a3 50     [..PcX.CcP.#[..P
10000f2c:	18 4b 19 4a e2 50 a0 22 04 33 92 01 e2 50 ff 22     .K.J.P.".3...P."
10000f3c:	16 4b e2 50 ff f7 7e ff c0 22 01 21 52 00 a3 58     .K.P..~..".!R..X
10000f4c:	8b 43 a3 50 ff f7 99 ff ff f7 98 ff 10 4b 03 20     .C.P.........K. 
10000f5c:	1a 68 13 00 ba 33 19 88 07 23 4b 43 12 6a 80 21     .h...3...#KC.j.!
10000f6c:	9b 18 00 22 da 60 5a 60 0a 4a ff f7 cd fa 0a 48     ...".`Z`.J.....H
10000f7c:	ff f7 a4 f9 09 48 ff f7 dd f9 10 bd 20 14 00 10     .....H...... ...
10000f8c:	00 00 26 40 84 05 00 00 01 00 02 00 8c 05 00 00     ..&@............
10000f9c:	cc 03 00 08 80 03 00 08 48 04 00 08 e0 14 00 10     ........H.......
10000fac:	90 23 03 4a 5b 01 d0 58 03 23 18 40 70 47 c0 46     .#.J[..X.#.@pG.F
10000fbc:	00 00 20 40 10 b5 90 24 ff f7 89 f8 07 4b 64 01     .. @...$.....Kd.
10000fcc:	1a 59 07 49 11 40 07 4a 0a 43 1a 51 10 22 59 68     .Y.I.@.J.C.Q."Yh
10000fdc:	11 42 fc d0 ff f7 7f f8 10 bd c0 46 00 00 20 40     .B.........F.. @
10000fec:	fc ff 00 00 01 00 fa 05 f8 b5 90 26 0e 4c 76 01     ...........&.Lv.
10000ffc:	07 00 ff f7 6c f8 a3 59 05 00 db 43 9b 07 01 d1     ....l..Y...C....
1000100c:	ff f7 d8 ff 80 23 9b 00 e7 50 a3 59 07 4a 1a 40     .....#...P.Y.J.@
1000101c:	07 4b 13 43 a3 51 10 23 62 68 1a 42 fc d0 28 00     .K.C.Q.#bh.B..(.
1000102c:	ff f7 59 f8 f8 bd c0 46 00 00 20 40 fc ff 00 00     ..Y....F.. @....
1000103c:	03 00 fa 05 02 b4 71 46 49 08 49 00 09 56 49 00     ......qFI.I..VI.
1000104c:	8e 44 02 bc 70 47 c0 46 00 22 43 08 8b 42 74 d3     .D..pG.F."C..Bt.
1000105c:	03 09 8b 42 5f d3 03 0a 8b 42 44 d3 03 0b 8b 42     ...B_....BD....B
1000106c:	28 d3 03 0c 8b 42 0d d3 ff 22 09 02 12 ba 03 0c     (....B..."......
1000107c:	8b 42 02 d3 12 12 09 02 65 d0 03 0b 8b 42 19 d3     .B......e....B..
1000108c:	00 e0 09 0a c3 0b 8b 42 01 d3 cb 03 c0 1a 52 41     .......B......RA
1000109c:	83 0b 8b 42 01 d3 8b 03 c0 1a 52 41 43 0b 8b 42     ...B......RAC..B
100010ac:	01 d3 4b 03 c0 1a 52 41 03 0b 8b 42 01 d3 0b 03     ..K...RA...B....
100010bc:	c0 1a 52 41 c3 0a 8b 42 01 d3 cb 02 c0 1a 52 41     ..RA...B......RA
100010cc:	83 0a 8b 42 01 d3 8b 02 c0 1a 52 41 43 0a 8b 42     ...B......RAC..B
100010dc:	01 d3 4b 02 c0 1a 52 41 03 0a 8b 42 01 d3 0b 02     ..K...RA...B....
100010ec:	c0 1a 52 41 cd d2 c3 09 8b 42 01 d3 cb 01 c0 1a     ..RA.....B......
100010fc:	52 41 83 09 8b 42 01 d3 8b 01 c0 1a 52 41 43 09     RA...B......RAC.
1000110c:	8b 42 01 d3 4b 01 c0 1a 52 41 03 09 8b 42 01 d3     .B..K...RA...B..
1000111c:	0b 01 c0 1a 52 41 c3 08 8b 42 01 d3 cb 00 c0 1a     ....RA...B......
1000112c:	52 41 83 08 8b 42 01 d3 8b 00 c0 1a 52 41 43 08     RA...B......RAC.
1000113c:	8b 42 01 d3 4b 00 c0 1a 52 41 41 1a 00 d2 01 46     .B..K...RAA....F
1000114c:	52 41 10 46 70 47 ff e7 01 b5 00 20 00 f0 06 f8     RA.FpG..... ....
1000115c:	02 bd c0 46 00 29 f7 d0 76 e7 70 47 70 47 c0 46     ...F.)..v.pGpG.F
1000116c:	00 2b 11 d1 00 2a 0f d1 00 29 00 d1 00 28 02 d0     .+...*...)...(..
1000117c:	00 21 c9 43 08 00 07 b4 02 48 02 a1 40 18 02 90     .!.C.....H..@...
1000118c:	03 bd c0 46 d9 ff ff ff 03 b4 68 46 01 b5 02 98     ...F......hF....
1000119c:	00 f0 34 f8 01 9b 9e 46 02 b0 0c bc 70 47 c0 46     ..4....F....pG.F
100011ac:	f0 b5 ce 46 47 46 80 b5 07 00 99 46 3b 0c 9c 46     ...FGF.....F;..F
100011bc:	13 04 1b 0c 1d 00 0e 00 61 46 00 04 14 0c 00 0c     ........aF......
100011cc:	45 43 4b 43 60 43 61 43 c0 18 2c 0c 20 18 8c 46     ECKC`CaC..,. ..F
100011dc:	83 42 03 d9 80 23 5b 02 98 46 c4 44 49 46 79 43     .B...#[..F.DIFyC
100011ec:	72 43 03 0c 63 44 2d 04 2d 0c c9 18 00 04 40 19     rC..cD-.-.....@.
100011fc:	89 18 c0 bc b9 46 b0 46 f0 bd c0 46 f0 b5 57 46     .....F.F...F..WF
1000120c:	4e 46 45 46 de 46 e0 b5 04 00 0d 00 92 46 99 46     NFEF.F.......F.F
1000121c:	83 b0 8b 42 30 d8 2d d0 49 46 50 46 00 f0 d8 f8     ...B0.-.IFPF....
1000122c:	29 00 06 00 20 00 00 f0 d3 f8 33 1a 98 46 20 3b     )... .....3..F ;
1000123c:	9b 46 33 d4 5a 46 53 46 93 40 42 46 1f 00 53 46     .F3.ZFSF.@BF..SF
1000124c:	93 40 1e 00 af 42 3a d8 af 42 00 d1 78 e0 5b 46     .@...B:..B..x.[F
1000125c:	a4 1b bd 41 00 2b 00 da 75 e0 00 22 00 23 00 92     ...A.+..u..".#..
1000126c:	01 93 01 23 5a 46 93 40 01 93 01 23 42 46 93 40     ...#ZF.@...#BF.@
1000127c:	00 93 28 e0 82 42 cf d9 00 22 00 23 00 92 01 93     ..(..B...".#....
1000128c:	0c 9b 00 2b 01 d0 1c 60 5d 60 00 98 01 99 03 b0     ...+...`]`......
1000129c:	f0 bc bb 46 b2 46 a9 46 a0 46 f0 bd 42 46 20 23     ...F.F.F.F..BF #
100012ac:	9b 1a 52 46 da 40 41 46 13 00 4a 46 8a 40 17 00     ..RF.@AF..JF.@..
100012bc:	42 46 1f 43 53 46 93 40 1e 00 af 42 c4 d9 00 22     BF.CSF.@...B..."
100012cc:	00 23 00 92 01 93 43 46 00 2b d9 d0 fb 07 72 08     .#....CF.+....r.
100012dc:	1a 43 46 46 7b 08 0e e0 ab 42 01 d1 a2 42 0c d8     .CFF{....B...B..
100012ec:	a4 1a 9d 41 01 20 24 19 6d 41 00 21 01 3e 24 18     ...A. $.mA.!.>$.
100012fc:	4d 41 00 2e 06 d0 ab 42 ee d9 01 3e 24 19 6d 41     MA.....B...>$.mA
1000130c:	00 2e f8 d1 00 98 01 99 5b 46 00 19 69 41 00 2b     ........[F..iA.+
1000131c:	24 db 2b 00 5a 46 44 46 d3 40 2a 00 e2 40 1c 00     $.+.ZFDF.@*..@..
1000132c:	5b 46 15 00 00 2b 2a db 26 00 9e 40 33 00 26 00     [F...+*.&..@3.&.
1000133c:	47 46 be 40 32 00 80 1a 99 41 00 90 01 91 9f e7     GF.@2....A......
1000134c:	a3 42 bc d8 83 e7 42 46 20 23 00 21 9b 1a 00 22     .B....BF #.!..."
1000135c:	00 91 01 92 01 22 da 40 01 92 86 e7 42 46 20 23     .....".@....BF #
1000136c:	9b 1a 2a 00 46 46 9a 40 23 00 f3 40 44 46 13 43     ..*.FF.@#..@DF.C
1000137c:	2a 00 e2 40 1c 00 5b 46 15 00 00 2b d4 da 42 46     *..@..[F...+..BF
1000138c:	2f 00 20 23 26 00 97 40 9b 1a de 40 3b 00 33 43     /. #&..@...@;.3C
1000139c:	cd e7 c0 46 1c 21 01 23 1b 04 98 42 01 d3 00 0c     ...F.!.#...B....
100013ac:	10 39 1b 0a 98 42 01 d3 00 0a 08 39 1b 09 98 42     .9...B.....9...B
100013bc:	01 d3 00 09 04 39 02 a2 10 5c 40 18 70 47 c0 46     .....9...\@.pG.F
100013cc:	04 03 02 02 01 01 01 01 00 00 00 00 00 00 00 00     ................
100013dc:	10 b5 00 29 03 d1 ff f7 dd ff 20 30 02 e0 08 00     ...)...... 0....
100013ec:	ff f7 d8 ff 10 bd c0 46 f8 b5 c0 46 f8 bc 08 bc     .......F...F....
100013fc:	9e 46 70 47 f8 b5 c0 46 f8 bc 08 bc 9e 46 70 47     .FpG...F.....FpG
1000140c:	00 00 00 00 01 b4 02 48 84 46 01 bc 60 47 00 bf     .......H.F..`G..
1000141c:	61 02 00 08 00 00 20 40 00 00 24 40 00 00 00 40     a..... @..$@...@
1000142c:	00 00 00 00 00 00 23 40 00 00 30 40 00 00 31 40     ......#@..0@..1@
1000143c:	00 00 9f 40 00 00 22 40 00 00 10 40 00 00 9d 40     ...@.."@...@...@
1000144c:	20 20 20 20 20 10 10 10 10 1d 1d 80 17 00 75 00          .........u.
1000145c:	ff 03 06 02 06 00 36 04 10 20 00 00 7f c0 00 00     ......6.. ......
1000146c:	00 04 00 00 00 00 00 00 00 19 32 4b 64 7d 00 00     ..........2Kd}..
1000147c:	00 00 00 80 40 00 08 0b 10 00 00 00 00 00 ff 01     ....@...........
1000148c:	20 02 00 1f 00 80 00 04 ff 08 10 18 00 10 00 14      ...............
1000149c:	00 18 00 1c 40 44 48 4c 50 00 00 00 08 10 00 00     ....@DHLP.......
100014ac:	08 00 00 00 04 00 00 00 04 10 00 00 00 12 00 00     ................
100014bc:	04 21 00 00 00 21 00 00 00 16 00 00 40 11 40 02     .!...!......@.@.
100014cc:	c4 13 00 13 80 13 a0 13 40 13 88 13 a8 13 20 00     ........@..... .
100014dc:	1c 00 00 00 03 00 00 00 01 00 00 00 01 00 00 00     ................
100014ec:	00 00 00 00 05 03 60 00 04 00 00 00 01 00 00 00     ......`.........
100014fc:	00 00 00 00 01 00 00 00 06 04 60 00 08 00 00 00     ..........`.....
1000150c:	a8 05 00 08 7d 0e 00 10 00 00 00 00 f0 fc ff 7f     ....}...........
1000151c:	01 00 00 00 00 00 00 10 00 00 00 08 80 00 00 00     ................
1000152c:	40 15 00 10 80 00 00 08 f8 02 00 00 b0 03 00 08     @...............
1000153c:	18 02 00 00 00 09 3d 00 00 09 3d 00 00 12 7a 00     ......=...=...z.
1000154c:	00 09 3d 00 a0 0f 00 00 04 00 00 00 a9 00 00 10     ..=.............
1000155c:	81 00 00 10 80 b2 30 b5 c4 00 00 28 20 d0 11 4b     ......0....( ..K
1000156c:	07 22 18 68 03 00 ba 33 1b 88 53 43 02 6a 9a 18     .".h...3..SC.j..
1000157c:	11 68 00 29 fc da 3e 21 0b 4a 06 25 11 60 0b 4a     .h.)..>!.J.%.`.J
1000158c:	0b 49 11 60 a3 21 0b 4a c9 00 55 50 0a 49 54 50     .I.`.!.J..UP.ITP
1000159c:	00 6a 54 58 1b 18 00 20 58 60 53 58 00 2b fc da     .jTX... X`SX.+..
100015ac:	30 bd c0 46 cc 03 00 08 04 01 26 40 08 01 26 40     0..F......&@..&@
100015bc:	1e 1f 00 00 00 00 26 40 1c 05 00 00 10 b5 43 78     ......&@......Cx
100015cc:	ff 2b 11 d1 00 f0 fa f8 04 00 03 20 00 f0 0e f9     .+......... ....
100015dc:	01 21 c3 68 5b 68 1a 68 0a 43 1a 60 1a 68 0a 42     .!.h[h.h.C.`.h.B
100015ec:	fc d1 20 00 00 f0 1a f9 10 bd f7 b5 07 00 00 20     .. ............ 
100015fc:	01 91 00 f0 fb f8 3e 4c 05 00 23 68 1a 00 50 33     ......>L..#h..P3
1000160c:	bc 32 16 68 1b 78 86 19 00 2b 59 d0 00 f0 f6 f8     .2.h.x...+Y.....
1000161c:	00 90 03 28 1a d0 00 f0 d1 f8 36 4a 36 4b 04 00     ...(......6J6K..
1000162c:	d3 58 00 2b 3c da 01 21 28 00 34 4a 00 f0 d6 f8     .X.+<..!(.4J....
1000163c:	00 28 35 d1 01 98 ff f7 8d ff 00 2f 3e d0 33 68     .(5......../>.3h
1000164c:	00 2b fc db 00 f0 b2 f8 05 00 2a e0 06 20 00 f0     .+........*.. ..
1000165c:	cd f8 23 68 bc 33 1b 68 c0 18 03 68 00 2b 02 da     ..#h.3.h...h.+..
1000166c:	27 4d 28 00 fe bd 00 20 00 f0 b0 f8 25 4b 98 42     'M(.... ....%K.B
1000167c:	f6 d0 00 23 24 4a 19 00 01 20 12 68 00 f0 c6 f8     ...#$J... .h....
1000168c:	04 1e ed d1 00 20 00 f0 a1 f8 1e 4a 1f 4b 90 42     ..... .....J.K.B
1000169c:	03 d0 9c 42 e4 d0 01 34 f4 e7 9c 42 bb d1 df e7     ...B...4...B....
100016ac:	17 4d 00 9b 03 2b 05 d1 01 21 00 20 00 f0 76 f8     .M...+...!. ..v.
100016bc:	00 28 f9 d1 20 00 00 f0 b1 f8 d2 e7 14 4d f0 e7     .(.. ........M..
100016cc:	00 f0 7c f8 01 21 04 00 0c 4a 28 00 00 f0 86 f8     ..|..!...J(.....
100016dc:	00 28 08 d1 00 2f 08 d0 33 68 00 2b fc db 00 f0     .(.../..3h.+....
100016ec:	65 f8 05 00 e6 e7 06 4d e4 e7 09 4d e2 e7 c0 46     e......M...M...F
100016fc:	cc 03 00 08 00 00 26 40 1c 05 00 00 d0 03 00 08     ......&@........
1000170c:	05 00 52 00 01 01 88 00 e0 03 00 08 f0 49 02 00     ..R..........I..
1000171c:	01 00 50 00 18 4b f7 b5 1b 68 18 49 5a 68 04 23     ..P..K...h.IZh.#
1000172c:	0c 69 23 43 0b 61 01 28 24 d0 30 bf 13 00 fc 33     .i#C.a.($.0....3
1000173c:	1b 69 00 2b 1d d1 a3 24 11 4b 12 48 12 49 e4 00     .i.+...$.K.H.I..
1000174c:	07 68 1e 59 0d 68 01 95 10 4d 05 60 06 25 1d 51     .h.Y.h...M.`.%.Q
1000175c:	3e 24 0c 60 0e 4c 3e 35 1d 51 1d 59 00 2d fc da     >$.`.L>5.Q.Y.-..
1000176c:	0c 4c fc 32 14 61 a3 22 d2 00 07 60 9e 50 01 9b     .L.2.a."...`.P..
1000177c:	0b 60 f7 bd 20 bf d9 e7 cc 03 00 08 00 ed 00 e0     .`.. ...........
1000178c:	00 00 26 40 08 01 26 40 04 01 26 40 1e 1f 00 00     ..&@..&@..&@....
1000179c:	1c 05 00 00 aa aa aa aa 00 00 00 00 01 b4 02 48     ...............H
100017ac:	84 46 01 bc 60 47 00 bf 61 05 00 10 01 b4 02 48     .F..`G..a......H
100017bc:	84 46 01 bc 60 47 00 bf 29 02 00 10 01 b4 02 48     .F..`G..)......H
100017cc:	84 46 01 bc 60 47 00 bf db 00 00 10 01 b4 02 48     .F..`G.........H
100017dc:	84 46 01 bc 60 47 00 bf d5 05 00 10 01 b4 02 48     .F..`G.........H
100017ec:	84 46 01 bc 60 47 00 bf 8d 02 00 10 01 b4 02 48     .F..`G.........H
100017fc:	84 46 01 bc 60 47 00 bf 75 01 00 10 01 b4 02 48     .F..`G..u......H
1000180c:	84 46 01 bc 60 47 00 bf ad 0f 00 10 01 b4 02 48     .F..`G.........H
1000181c:	84 46 01 bc 60 47 00 bf 9d 03 00 10 01 b4 02 48     .F..`G.........H
1000182c:	84 46 01 bc 60 47 00 bf e3 00 00 10 00 00 00 00     .F..`G..........
	...

10002000 <_vector_table>:
10002000:	00 46 00 08 49 37 00 10 0f 7f 00 10 1d 37 00 10     .F..I7.......7..
10002010:	1d 37 00 10 1d 37 00 10 1d 37 00 10 00 00 00 00     .7...7...7......
	...
1000202c:	9d 33 00 10 1d 37 00 10 00 00 00 00 49 33 00 10     .3...7......I3..
1000203c:	4d 3e 00 10                                         M>..

10002040 <_irq_vector_table>:
10002040:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002050:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002060:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002070:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002080:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002090:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100020a0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100020b0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100020c0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100020d0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100020e0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100020f0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002100:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002110:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002120:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002130:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002140:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002150:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002160:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002170:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002180:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002190:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100021a0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100021b0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100021c0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100021d0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100021e0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100021f0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002200:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002210:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002220:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002230:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002240:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002250:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002260:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002270:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002280:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
10002290:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100022a0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100022b0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100022c0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..
100022d0:	4d 34 00 10 4d 34 00 10 4d 34 00 10 4d 34 00 10     M4..M4..M4..M4..

Disassembly of section text:

100022e0 <Cy_SysLib_DelayCycles>:
.func Cy_SysLib_DelayCycles, Cy_SysLib_DelayCycles
.type Cy_SysLib_DelayCycles, %function
.thumb_func
Cy_SysLib_DelayCycles:      /* cycles bytes */

    ADDS r0, r0, #2         /*    1    2    Round to nearest multiple of 4 */
100022e0:	3002      	adds	r0, #2
    LSRS r0, r0, #2         /*    1    2    Divide by 4 and set flags */
100022e2:	0880      	lsrs	r0, r0, #2
    BEQ Cy_DelayCycles_done /*    2    2    Skip if 0 */
100022e4:	d003      	beq.n	100022ee <Cy_DelayCycles_done>

100022e6 <Cy_DelayCycles_loop>:

Cy_DelayCycles_loop:
    ADDS r0, r0, #1         /*    1    2    Increment counter */
100022e6:	3001      	adds	r0, #1
    SUBS r0, r0, #2         /*    1    2    Decrement counter by 2 */
100022e8:	3802      	subs	r0, #2
    BNE Cy_DelayCycles_loop /*   (1)2  2    2 CPU cycles (if branch is taken) */
100022ea:	d1fc      	bne.n	100022e6 <Cy_DelayCycles_loop>
    NOP                     /*    1    2    Loop alignment padding */
100022ec:	bf00      	nop

100022ee <Cy_DelayCycles_done>:

Cy_DelayCycles_done:
    NOP                     /*    1    2    Loop alignment padding */
100022ee:	bf00      	nop
    BX lr                   /*    3    2 */
100022f0:	4770      	bx	lr

100022f2 <Cy_SysLib_EnterCriticalSection>:
.func Cy_SysLib_EnterCriticalSection, Cy_SysLib_EnterCriticalSection
.type Cy_SysLib_EnterCriticalSection, %function
.thumb_func

Cy_SysLib_EnterCriticalSection:
    MRS r0, PRIMASK         /* Save and return interrupt state */
100022f2:	f3ef 8010 	mrs	r0, PRIMASK
    cpsid i                 /* Disable interrupts */
100022f6:	b672      	cpsid	i
    BX lr
100022f8:	4770      	bx	lr

100022fa <Cy_SysLib_ExitCriticalSection>:
.func Cy_SysLib_ExitCriticalSection, Cy_SysLib_ExitCriticalSection
.type Cy_SysLib_ExitCriticalSection, %function
.thumb_func

Cy_SysLib_ExitCriticalSection:
    MSR PRIMASK, r0         /* Restore interrupt state */
100022fa:	f380 8810 	msr	PRIMASK, r0
    BX lr
100022fe:	4770      	bx	lr

10002300 <__aeabi_ldivmod>:
10002300:	b97b      	cbnz	r3, 10002322 <__aeabi_ldivmod+0x22>
10002302:	b972      	cbnz	r2, 10002322 <__aeabi_ldivmod+0x22>
10002304:	2900      	cmp	r1, #0
10002306:	bfbe      	ittt	lt
10002308:	2000      	movlt	r0, #0
1000230a:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
1000230e:	e006      	blt.n	1000231e <__aeabi_ldivmod+0x1e>
10002310:	bf08      	it	eq
10002312:	2800      	cmpeq	r0, #0
10002314:	bf1c      	itt	ne
10002316:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
1000231a:	f04f 30ff 	movne.w	r0, #4294967295
1000231e:	f000 b857 	b.w	100023d0 <__aeabi_idiv0>
10002322:	f1ad 0c08 	sub.w	ip, sp, #8
10002326:	e96d ce04 	strd	ip, lr, [sp, #-16]!
1000232a:	2900      	cmp	r1, #0
1000232c:	db09      	blt.n	10002342 <__aeabi_ldivmod+0x42>
1000232e:	2b00      	cmp	r3, #0
10002330:	db1a      	blt.n	10002368 <__aeabi_ldivmod+0x68>
10002332:	f000 f84f 	bl	100023d4 <__udivmoddi4>
10002336:	f8dd e004 	ldr.w	lr, [sp, #4]
1000233a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
1000233e:	b004      	add	sp, #16
10002340:	4770      	bx	lr
10002342:	4240      	negs	r0, r0
10002344:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
10002348:	2b00      	cmp	r3, #0
1000234a:	db1b      	blt.n	10002384 <__aeabi_ldivmod+0x84>
1000234c:	f000 f842 	bl	100023d4 <__udivmoddi4>
10002350:	f8dd e004 	ldr.w	lr, [sp, #4]
10002354:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
10002358:	b004      	add	sp, #16
1000235a:	4240      	negs	r0, r0
1000235c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
10002360:	4252      	negs	r2, r2
10002362:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
10002366:	4770      	bx	lr
10002368:	4252      	negs	r2, r2
1000236a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
1000236e:	f000 f831 	bl	100023d4 <__udivmoddi4>
10002372:	f8dd e004 	ldr.w	lr, [sp, #4]
10002376:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
1000237a:	b004      	add	sp, #16
1000237c:	4240      	negs	r0, r0
1000237e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
10002382:	4770      	bx	lr
10002384:	4252      	negs	r2, r2
10002386:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
1000238a:	f000 f823 	bl	100023d4 <__udivmoddi4>
1000238e:	f8dd e004 	ldr.w	lr, [sp, #4]
10002392:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
10002396:	b004      	add	sp, #16
10002398:	4252      	negs	r2, r2
1000239a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
1000239e:	4770      	bx	lr

100023a0 <__aeabi_uldivmod>:
100023a0:	b953      	cbnz	r3, 100023b8 <__aeabi_uldivmod+0x18>
100023a2:	b94a      	cbnz	r2, 100023b8 <__aeabi_uldivmod+0x18>
100023a4:	2900      	cmp	r1, #0
100023a6:	bf08      	it	eq
100023a8:	2800      	cmpeq	r0, #0
100023aa:	bf1c      	itt	ne
100023ac:	f04f 31ff 	movne.w	r1, #4294967295
100023b0:	f04f 30ff 	movne.w	r0, #4294967295
100023b4:	f000 b80c 	b.w	100023d0 <__aeabi_idiv0>
100023b8:	f1ad 0c08 	sub.w	ip, sp, #8
100023bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
100023c0:	f000 f808 	bl	100023d4 <__udivmoddi4>
100023c4:	f8dd e004 	ldr.w	lr, [sp, #4]
100023c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
100023cc:	b004      	add	sp, #16
100023ce:	4770      	bx	lr

100023d0 <__aeabi_idiv0>:
100023d0:	4770      	bx	lr
100023d2:	bf00      	nop

100023d4 <__udivmoddi4>:
100023d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
100023d8:	4686      	mov	lr, r0
100023da:	468c      	mov	ip, r1
100023dc:	4608      	mov	r0, r1
100023de:	9e08      	ldr	r6, [sp, #32]
100023e0:	4615      	mov	r5, r2
100023e2:	4674      	mov	r4, lr
100023e4:	4619      	mov	r1, r3
100023e6:	2b00      	cmp	r3, #0
100023e8:	f040 80c2 	bne.w	10002570 <__udivmoddi4+0x19c>
100023ec:	4285      	cmp	r5, r0
100023ee:	fab2 f282 	clz	r2, r2
100023f2:	d945      	bls.n	10002480 <__udivmoddi4+0xac>
100023f4:	b14a      	cbz	r2, 1000240a <__udivmoddi4+0x36>
100023f6:	f1c2 0320 	rsb	r3, r2, #32
100023fa:	fa00 fc02 	lsl.w	ip, r0, r2
100023fe:	fa2e f303 	lsr.w	r3, lr, r3
10002402:	4095      	lsls	r5, r2
10002404:	ea43 0c0c 	orr.w	ip, r3, ip
10002408:	4094      	lsls	r4, r2
1000240a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1000240e:	b2a8      	uxth	r0, r5
10002410:	fbbc f8fe 	udiv	r8, ip, lr
10002414:	0c23      	lsrs	r3, r4, #16
10002416:	fb0e cc18 	mls	ip, lr, r8, ip
1000241a:	fb08 f900 	mul.w	r9, r8, r0
1000241e:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
10002422:	4599      	cmp	r9, r3
10002424:	d928      	bls.n	10002478 <__udivmoddi4+0xa4>
10002426:	18eb      	adds	r3, r5, r3
10002428:	f108 37ff 	add.w	r7, r8, #4294967295
1000242c:	d204      	bcs.n	10002438 <__udivmoddi4+0x64>
1000242e:	4599      	cmp	r9, r3
10002430:	d902      	bls.n	10002438 <__udivmoddi4+0x64>
10002432:	f1a8 0702 	sub.w	r7, r8, #2
10002436:	442b      	add	r3, r5
10002438:	eba3 0309 	sub.w	r3, r3, r9
1000243c:	b2a4      	uxth	r4, r4
1000243e:	fbb3 fcfe 	udiv	ip, r3, lr
10002442:	fb0e 331c 	mls	r3, lr, ip, r3
10002446:	fb0c f000 	mul.w	r0, ip, r0
1000244a:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
1000244e:	42a0      	cmp	r0, r4
10002450:	d914      	bls.n	1000247c <__udivmoddi4+0xa8>
10002452:	192c      	adds	r4, r5, r4
10002454:	f10c 33ff 	add.w	r3, ip, #4294967295
10002458:	d204      	bcs.n	10002464 <__udivmoddi4+0x90>
1000245a:	42a0      	cmp	r0, r4
1000245c:	d902      	bls.n	10002464 <__udivmoddi4+0x90>
1000245e:	f1ac 0302 	sub.w	r3, ip, #2
10002462:	442c      	add	r4, r5
10002464:	1a24      	subs	r4, r4, r0
10002466:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
1000246a:	b11e      	cbz	r6, 10002474 <__udivmoddi4+0xa0>
1000246c:	40d4      	lsrs	r4, r2
1000246e:	2300      	movs	r3, #0
10002470:	6034      	str	r4, [r6, #0]
10002472:	6073      	str	r3, [r6, #4]
10002474:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
10002478:	4647      	mov	r7, r8
1000247a:	e7dd      	b.n	10002438 <__udivmoddi4+0x64>
1000247c:	4663      	mov	r3, ip
1000247e:	e7f1      	b.n	10002464 <__udivmoddi4+0x90>
10002480:	bb92      	cbnz	r2, 100024e8 <__udivmoddi4+0x114>
10002482:	1b43      	subs	r3, r0, r5
10002484:	2101      	movs	r1, #1
10002486:	ea4f 4e15 	mov.w	lr, r5, lsr #16
1000248a:	b2af      	uxth	r7, r5
1000248c:	fbb3 fcfe 	udiv	ip, r3, lr
10002490:	0c20      	lsrs	r0, r4, #16
10002492:	fb0e 331c 	mls	r3, lr, ip, r3
10002496:	fb0c f807 	mul.w	r8, ip, r7
1000249a:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
1000249e:	4598      	cmp	r8, r3
100024a0:	d962      	bls.n	10002568 <__udivmoddi4+0x194>
100024a2:	18eb      	adds	r3, r5, r3
100024a4:	f10c 30ff 	add.w	r0, ip, #4294967295
100024a8:	d204      	bcs.n	100024b4 <__udivmoddi4+0xe0>
100024aa:	4598      	cmp	r8, r3
100024ac:	d902      	bls.n	100024b4 <__udivmoddi4+0xe0>
100024ae:	f1ac 0002 	sub.w	r0, ip, #2
100024b2:	442b      	add	r3, r5
100024b4:	eba3 0308 	sub.w	r3, r3, r8
100024b8:	b2a4      	uxth	r4, r4
100024ba:	fbb3 fcfe 	udiv	ip, r3, lr
100024be:	fb0e 331c 	mls	r3, lr, ip, r3
100024c2:	fb0c f707 	mul.w	r7, ip, r7
100024c6:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
100024ca:	42a7      	cmp	r7, r4
100024cc:	d94e      	bls.n	1000256c <__udivmoddi4+0x198>
100024ce:	192c      	adds	r4, r5, r4
100024d0:	f10c 33ff 	add.w	r3, ip, #4294967295
100024d4:	d204      	bcs.n	100024e0 <__udivmoddi4+0x10c>
100024d6:	42a7      	cmp	r7, r4
100024d8:	d902      	bls.n	100024e0 <__udivmoddi4+0x10c>
100024da:	f1ac 0302 	sub.w	r3, ip, #2
100024de:	442c      	add	r4, r5
100024e0:	1be4      	subs	r4, r4, r7
100024e2:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
100024e6:	e7c0      	b.n	1000246a <__udivmoddi4+0x96>
100024e8:	f1c2 0320 	rsb	r3, r2, #32
100024ec:	fa20 f103 	lsr.w	r1, r0, r3
100024f0:	4095      	lsls	r5, r2
100024f2:	4090      	lsls	r0, r2
100024f4:	fa2e f303 	lsr.w	r3, lr, r3
100024f8:	4303      	orrs	r3, r0
100024fa:	ea4f 4e15 	mov.w	lr, r5, lsr #16
100024fe:	b2af      	uxth	r7, r5
10002500:	fbb1 fcfe 	udiv	ip, r1, lr
10002504:	fb0e 101c 	mls	r0, lr, ip, r1
10002508:	0c19      	lsrs	r1, r3, #16
1000250a:	fb0c f807 	mul.w	r8, ip, r7
1000250e:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
10002512:	4588      	cmp	r8, r1
10002514:	fa04 f402 	lsl.w	r4, r4, r2
10002518:	d922      	bls.n	10002560 <__udivmoddi4+0x18c>
1000251a:	1869      	adds	r1, r5, r1
1000251c:	f10c 30ff 	add.w	r0, ip, #4294967295
10002520:	d204      	bcs.n	1000252c <__udivmoddi4+0x158>
10002522:	4588      	cmp	r8, r1
10002524:	d902      	bls.n	1000252c <__udivmoddi4+0x158>
10002526:	f1ac 0002 	sub.w	r0, ip, #2
1000252a:	4429      	add	r1, r5
1000252c:	eba1 0108 	sub.w	r1, r1, r8
10002530:	b29b      	uxth	r3, r3
10002532:	fbb1 fcfe 	udiv	ip, r1, lr
10002536:	fb0e 111c 	mls	r1, lr, ip, r1
1000253a:	fb0c f707 	mul.w	r7, ip, r7
1000253e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
10002542:	429f      	cmp	r7, r3
10002544:	d90e      	bls.n	10002564 <__udivmoddi4+0x190>
10002546:	18eb      	adds	r3, r5, r3
10002548:	f10c 31ff 	add.w	r1, ip, #4294967295
1000254c:	d204      	bcs.n	10002558 <__udivmoddi4+0x184>
1000254e:	429f      	cmp	r7, r3
10002550:	d902      	bls.n	10002558 <__udivmoddi4+0x184>
10002552:	f1ac 0102 	sub.w	r1, ip, #2
10002556:	442b      	add	r3, r5
10002558:	1bdb      	subs	r3, r3, r7
1000255a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
1000255e:	e792      	b.n	10002486 <__udivmoddi4+0xb2>
10002560:	4660      	mov	r0, ip
10002562:	e7e3      	b.n	1000252c <__udivmoddi4+0x158>
10002564:	4661      	mov	r1, ip
10002566:	e7f7      	b.n	10002558 <__udivmoddi4+0x184>
10002568:	4660      	mov	r0, ip
1000256a:	e7a3      	b.n	100024b4 <__udivmoddi4+0xe0>
1000256c:	4663      	mov	r3, ip
1000256e:	e7b7      	b.n	100024e0 <__udivmoddi4+0x10c>
10002570:	4283      	cmp	r3, r0
10002572:	d906      	bls.n	10002582 <__udivmoddi4+0x1ae>
10002574:	b916      	cbnz	r6, 1000257c <__udivmoddi4+0x1a8>
10002576:	2100      	movs	r1, #0
10002578:	4608      	mov	r0, r1
1000257a:	e77b      	b.n	10002474 <__udivmoddi4+0xa0>
1000257c:	e9c6 e000 	strd	lr, r0, [r6]
10002580:	e7f9      	b.n	10002576 <__udivmoddi4+0x1a2>
10002582:	fab3 f783 	clz	r7, r3
10002586:	b98f      	cbnz	r7, 100025ac <__udivmoddi4+0x1d8>
10002588:	4283      	cmp	r3, r0
1000258a:	d301      	bcc.n	10002590 <__udivmoddi4+0x1bc>
1000258c:	4572      	cmp	r2, lr
1000258e:	d808      	bhi.n	100025a2 <__udivmoddi4+0x1ce>
10002590:	ebbe 0402 	subs.w	r4, lr, r2
10002594:	eb60 0303 	sbc.w	r3, r0, r3
10002598:	2001      	movs	r0, #1
1000259a:	469c      	mov	ip, r3
1000259c:	b91e      	cbnz	r6, 100025a6 <__udivmoddi4+0x1d2>
1000259e:	2100      	movs	r1, #0
100025a0:	e768      	b.n	10002474 <__udivmoddi4+0xa0>
100025a2:	4638      	mov	r0, r7
100025a4:	e7fa      	b.n	1000259c <__udivmoddi4+0x1c8>
100025a6:	e9c6 4c00 	strd	r4, ip, [r6]
100025aa:	e7f8      	b.n	1000259e <__udivmoddi4+0x1ca>
100025ac:	f1c7 0c20 	rsb	ip, r7, #32
100025b0:	40bb      	lsls	r3, r7
100025b2:	fa22 f40c 	lsr.w	r4, r2, ip
100025b6:	431c      	orrs	r4, r3
100025b8:	fa2e f10c 	lsr.w	r1, lr, ip
100025bc:	fa20 f30c 	lsr.w	r3, r0, ip
100025c0:	40b8      	lsls	r0, r7
100025c2:	4301      	orrs	r1, r0
100025c4:	ea4f 4914 	mov.w	r9, r4, lsr #16
100025c8:	fa0e f507 	lsl.w	r5, lr, r7
100025cc:	fbb3 f8f9 	udiv	r8, r3, r9
100025d0:	fa1f fe84 	uxth.w	lr, r4
100025d4:	fb09 3018 	mls	r0, r9, r8, r3
100025d8:	0c0b      	lsrs	r3, r1, #16
100025da:	fb08 fa0e 	mul.w	sl, r8, lr
100025de:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
100025e2:	459a      	cmp	sl, r3
100025e4:	fa02 f207 	lsl.w	r2, r2, r7
100025e8:	d940      	bls.n	1000266c <__udivmoddi4+0x298>
100025ea:	18e3      	adds	r3, r4, r3
100025ec:	f108 30ff 	add.w	r0, r8, #4294967295
100025f0:	d204      	bcs.n	100025fc <__udivmoddi4+0x228>
100025f2:	459a      	cmp	sl, r3
100025f4:	d902      	bls.n	100025fc <__udivmoddi4+0x228>
100025f6:	f1a8 0002 	sub.w	r0, r8, #2
100025fa:	4423      	add	r3, r4
100025fc:	eba3 030a 	sub.w	r3, r3, sl
10002600:	b289      	uxth	r1, r1
10002602:	fbb3 f8f9 	udiv	r8, r3, r9
10002606:	fb09 3318 	mls	r3, r9, r8, r3
1000260a:	fb08 fe0e 	mul.w	lr, r8, lr
1000260e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
10002612:	458e      	cmp	lr, r1
10002614:	d92c      	bls.n	10002670 <__udivmoddi4+0x29c>
10002616:	1861      	adds	r1, r4, r1
10002618:	f108 33ff 	add.w	r3, r8, #4294967295
1000261c:	d204      	bcs.n	10002628 <__udivmoddi4+0x254>
1000261e:	458e      	cmp	lr, r1
10002620:	d902      	bls.n	10002628 <__udivmoddi4+0x254>
10002622:	f1a8 0302 	sub.w	r3, r8, #2
10002626:	4421      	add	r1, r4
10002628:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
1000262c:	fba0 9802 	umull	r9, r8, r0, r2
10002630:	eba1 010e 	sub.w	r1, r1, lr
10002634:	4541      	cmp	r1, r8
10002636:	46ce      	mov	lr, r9
10002638:	4643      	mov	r3, r8
1000263a:	d302      	bcc.n	10002642 <__udivmoddi4+0x26e>
1000263c:	d106      	bne.n	1000264c <__udivmoddi4+0x278>
1000263e:	454d      	cmp	r5, r9
10002640:	d204      	bcs.n	1000264c <__udivmoddi4+0x278>
10002642:	ebb9 0e02 	subs.w	lr, r9, r2
10002646:	eb68 0304 	sbc.w	r3, r8, r4
1000264a:	3801      	subs	r0, #1
1000264c:	2e00      	cmp	r6, #0
1000264e:	d0a6      	beq.n	1000259e <__udivmoddi4+0x1ca>
10002650:	ebb5 020e 	subs.w	r2, r5, lr
10002654:	eb61 0103 	sbc.w	r1, r1, r3
10002658:	fa01 fc0c 	lsl.w	ip, r1, ip
1000265c:	fa22 f307 	lsr.w	r3, r2, r7
10002660:	ea4c 0303 	orr.w	r3, ip, r3
10002664:	40f9      	lsrs	r1, r7
10002666:	e9c6 3100 	strd	r3, r1, [r6]
1000266a:	e798      	b.n	1000259e <__udivmoddi4+0x1ca>
1000266c:	4640      	mov	r0, r8
1000266e:	e7c5      	b.n	100025fc <__udivmoddi4+0x228>
10002670:	4643      	mov	r3, r8
10002672:	e7d9      	b.n	10002628 <__udivmoddi4+0x254>
10002674:	0000      	movs	r0, r0
	...

10002678 <Cy_SysClk_FllConfigure>:
    return retStatus;
}


cy_en_sysclk_status_t Cy_SysClk_FllConfigure(uint32_t inputFreq, uint32_t outputFreq, cy_en_fll_pll_output_mode_t outputMode)
{
10002678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cy_en_sysclk_status_t retVal = CY_SYSCLK_SUCCESS;

    /* check for errors */
    if ((outputFreq < CY_SYSCLK_FLL_MIN_OUTPUT_FREQ) || (CY_SYSCLK_FLL_MAX_OUTPUT_FREQ < outputFreq) || /* invalid output frequency */
1000267c:	f1a1 73b7 	sub.w	r3, r1, #23986176	; 0x16e0000
{
10002680:	460e      	mov	r6, r1
    if ((outputFreq < CY_SYSCLK_FLL_MIN_OUTPUT_FREQ) || (CY_SYSCLK_FLL_MAX_OUTPUT_FREQ < outputFreq) || /* invalid output frequency */
10002682:	49a7      	ldr	r1, [pc, #668]	; (10002920 <Cy_SysClk_FllConfigure+0x2a8>)
10002684:	f5a3 5358 	sub.w	r3, r3, #13824	; 0x3600
10002688:	428b      	cmp	r3, r1
{
1000268a:	b093      	sub	sp, #76	; 0x4c
1000268c:	4604      	mov	r4, r0
    if ((outputFreq < CY_SYSCLK_FLL_MIN_OUTPUT_FREQ) || (CY_SYSCLK_FLL_MAX_OUTPUT_FREQ < outputFreq) || /* invalid output frequency */
1000268e:	f200 813e 	bhi.w	1000290e <Cy_SysClk_FllConfigure+0x296>
      (((outputFreq * 5UL) / inputFreq) < 11UL)) /* check output/input frequency ratio */
10002692:	eb06 0386 	add.w	r3, r6, r6, lsl #2
10002696:	fbb3 f3f0 	udiv	r3, r3, r0
    if ((outputFreq < CY_SYSCLK_FLL_MIN_OUTPUT_FREQ) || (CY_SYSCLK_FLL_MAX_OUTPUT_FREQ < outputFreq) || /* invalid output frequency */
1000269a:	2b0a      	cmp	r3, #10
1000269c:	f240 8137 	bls.w	1000290e <Cy_SysClk_FllConfigure+0x296>
    else /* no errors */
    {
        /* If output mode is bypass (input routed directly to output), then done.
           The output frequency equals the input frequency regardless of the
           frequency parameters. */
        if (outputMode != CY_SYSCLK_FLLPLL_OUTPUT_INPUT)
100026a0:	2a02      	cmp	r2, #2
100026a2:	f000 8129 	beq.w	100028f8 <Cy_SysClk_FllConfigure+0x280>
        {
            cy_stc_fll_manual_config_t config;
            uint32_t ccoFreq;
            bool wcoSource = (CY_SYSCLK_CLKPATH_IN_WCO == Cy_SysClk_ClkPathGetSource(0UL/*FLL*/)) ? true : false;
100026a6:	2000      	movs	r0, #0
100026a8:	f002 fd9c 	bl	100051e4 <Cy_SysClk_ClkPathGetSource>

            config.outputMode = outputMode;
            /* 1. Output division by 2 is always required */
            config.enableOutputDiv = true;
100026ac:	2301      	movs	r3, #1
100026ae:	f88d 3013 	strb.w	r3, [sp, #19]
            /* 2. Compute the target CCO frequency from the target output frequency and output division */
            ccoFreq = outputFreq * 2UL;
100026b2:	fa06 fa03 	lsl.w	sl, r6, r3
            /* 3. Compute the CCO range value from the CCO frequency */
            config.ccoRange = ((ccoFreq >= 150339200UL) ? CY_SYSCLK_FLL_CCO_RANGE4 :
100026b6:	4b9b      	ldr	r3, [pc, #620]	; (10002924 <Cy_SysClk_FllConfigure+0x2ac>)
            config.outputMode = outputMode;
100026b8:	f88d 201a 	strb.w	r2, [sp, #26]
            config.ccoRange = ((ccoFreq >= 150339200UL) ? CY_SYSCLK_FLL_CCO_RANGE4 :
100026bc:	ebb3 0f46 	cmp.w	r3, r6, lsl #1
            bool wcoSource = (CY_SYSCLK_CLKPATH_IN_WCO == Cy_SysClk_ClkPathGetSource(0UL/*FLL*/)) ? true : false;
100026c0:	4680      	mov	r8, r0
            config.ccoRange = ((ccoFreq >= 150339200UL) ? CY_SYSCLK_FLL_CCO_RANGE4 :
100026c2:	d37a      	bcc.n	100027ba <Cy_SysClk_FllConfigure+0x142>
100026c4:	4b98      	ldr	r3, [pc, #608]	; (10002928 <Cy_SysClk_FllConfigure+0x2b0>)
100026c6:	459a      	cmp	sl, r3
100026c8:	d87a      	bhi.n	100027c0 <Cy_SysClk_FllConfigure+0x148>
100026ca:	4b98      	ldr	r3, [pc, #608]	; (1000292c <Cy_SysClk_FllConfigure+0x2b4>)
100026cc:	459a      	cmp	sl, r3
100026ce:	d87a      	bhi.n	100027c6 <Cy_SysClk_FllConfigure+0x14e>
100026d0:	4b97      	ldr	r3, [pc, #604]	; (10002930 <Cy_SysClk_FllConfigure+0x2b8>)
100026d2:	459a      	cmp	sl, r3
100026d4:	bf94      	ite	ls
100026d6:	f04f 0900 	movls.w	r9, #0
100026da:	f04f 0901 	movhi.w	r9, #1
                                 ((ccoFreq >=  63855600UL) ? CY_SYSCLK_FLL_CCO_RANGE1 : CY_SYSCLK_FLL_CCO_RANGE0))));

        /* 4. Compute the FLL reference divider value.
              refDiv is a constant if the WCO is the FLL source, otherwise the formula is
              refDiv = ROUNDUP((inputFreq / outputFreq) * 250) */
            config.refDiv = wcoSource ? 19U : (uint16_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)inputFreq * 250ULL, (uint64_t)outputFreq);
100026de:	f240 1311 	movw	r3, #273	; 0x111
100026e2:	4598      	cmp	r8, r3
            config.ccoRange = ((ccoFreq >= 150339200UL) ? CY_SYSCLK_FLL_CCO_RANGE4 :
100026e4:	f88d 9012 	strb.w	r9, [sp, #18]
            config.refDiv = wcoSource ? 19U : (uint16_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)inputFreq * 250ULL, (uint64_t)outputFreq);
100026e8:	d070      	beq.n	100027cc <Cy_SysClk_FllConfigure+0x154>
100026ea:	f04f 30ff 	mov.w	r0, #4294967295
100026ee:	25fa      	movs	r5, #250	; 0xfa
100026f0:	4601      	mov	r1, r0
100026f2:	fbe4 0105 	umlal	r0, r1, r4, r5
100026f6:	4632      	mov	r2, r6
100026f8:	2300      	movs	r3, #0
100026fa:	f7ff fe51 	bl	100023a0 <__aeabi_uldivmod>
100026fe:	1c45      	adds	r5, r0, #1
10002700:	b2ad      	uxth	r5, r5

        /* 5. Compute the FLL multiplier value.
              Formula is fllMult = ccoFreq / (inputFreq / refDiv) */
            config.fllMult = (uint32_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)ccoFreq * (uint64_t)config.refDiv, (uint64_t)inputFreq);
10002702:	f04f 30ff 	mov.w	r0, #4294967295
10002706:	4601      	mov	r1, r0
10002708:	4622      	mov	r2, r4
1000270a:	2300      	movs	r3, #0
1000270c:	fbea 0105 	umlal	r0, r1, sl, r5
            config.refDiv = wcoSource ? 19U : (uint16_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)inputFreq * 250ULL, (uint64_t)outputFreq);
10002710:	f8ad 5010 	strh.w	r5, [sp, #16]
            config.fllMult = (uint32_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)ccoFreq * (uint64_t)config.refDiv, (uint64_t)inputFreq);
10002714:	f7ff fe44 	bl	100023a0 <__aeabi_uldivmod>
        /* 6. Compute the lock tolerance.
              Formula is lock tolerance = 1.5 * fllMult * (((1 + CCO accuracy) / (1 - source clock accuracy)) - 1)
              We assume CCO accuracy is 0.25%.
              We assume the source clock accuracy = 1%. This is the accuracy of the IMO.
              Therefore the formula is lock tolerance = 1.5 * fllMult * 0.012626 = 0.018939 * fllMult */
            config.lockTolerance = (uint16_t)CY_SYSLIB_DIV_ROUNDUP(config.fllMult * 18939UL, 1000000UL);
10002718:	f644 13fb 	movw	r3, #18939	; 0x49fb
            config.fllMult = (uint32_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)ccoFreq * (uint64_t)config.refDiv, (uint64_t)inputFreq);
1000271c:	3001      	adds	r0, #1
1000271e:	9003      	str	r0, [sp, #12]

            {
                /* constants indexed by ccoRange */
                const uint32_t trimSteps[] = {110340UL, 110200UL, 110000UL, 110000UL, 117062UL}; /* Scaled by 10^8 */
10002720:	4f84      	ldr	r7, [pc, #528]	; (10002934 <Cy_SysClk_FllConfigure+0x2bc>)
            config.lockTolerance = (uint16_t)CY_SYSLIB_DIV_ROUNDUP(config.fllMult * 18939UL, 1000000UL);
10002722:	4358      	muls	r0, r3
10002724:	3801      	subs	r0, #1
10002726:	4b84      	ldr	r3, [pc, #528]	; (10002938 <Cy_SysClk_FllConfigure+0x2c0>)
10002728:	fbb0 f0f3 	udiv	r0, r0, r3
1000272c:	3001      	adds	r0, #1
1000272e:	f8ad 0014 	strh.w	r0, [sp, #20]
                const uint32_t trimSteps[] = {110340UL, 110200UL, 110000UL, 110000UL, 117062UL}; /* Scaled by 10^8 */
10002732:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
10002734:	f10d 0c20 	add.w	ip, sp, #32
10002738:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
1000273c:	f857 3b04 	ldr.w	r3, [r7], #4
10002740:	f8cc 3000 	str.w	r3, [ip]
                const uint32_t margin[] = {436UL, 581UL, 772UL, 1030UL, 1320UL}; /* Scaled by 10^5 */
10002744:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
10002746:	f10d 0c34 	add.w	ip, sp, #52	; 0x34
1000274a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
1000274e:	683b      	ldr	r3, [r7, #0]
10002750:	f8cc 3000 	str.w	r3, [ip]
        /* 7. Compute the CCO igain and pgain */
                {
                    /* intermediate parameters */
                    uint32_t kcco = (trimSteps[config.ccoRange] * margin[config.ccoRange]);
10002754:	ab12      	add	r3, sp, #72	; 0x48
10002756:	eb03 0989 	add.w	r9, r3, r9, lsl #2
                    uint32_t ki_p = (uint32_t)CY_SYSLIB_DIV_ROUND(850ULL * CY_SYSCLK_FLL_INT_COEF * inputFreq, (uint64_t)kcco * (uint64_t)config.refDiv);
1000275a:	4878      	ldr	r0, [pc, #480]	; (1000293c <Cy_SysClk_FllConfigure+0x2c4>)
                    uint32_t kcco = (trimSteps[config.ccoRange] * margin[config.ccoRange]);
1000275c:	f859 7c28 	ldr.w	r7, [r9, #-40]
10002760:	f859 9c14 	ldr.w	r9, [r9, #-20]
10002764:	fb09 f207 	mul.w	r2, r9, r7
                    uint32_t ki_p = (uint32_t)CY_SYSLIB_DIV_ROUND(850ULL * CY_SYSCLK_FLL_INT_COEF * inputFreq, (uint64_t)kcco * (uint64_t)config.refDiv);
10002768:	fba2 2305 	umull	r2, r3, r2, r5
1000276c:	ea4f 0c52 	mov.w	ip, r2, lsr #1
10002770:	ea4c 7cc3 	orr.w	ip, ip, r3, lsl #31
10002774:	fba4 0100 	umull	r0, r1, r4, r0
10002778:	eb10 000c 	adds.w	r0, r0, ip
1000277c:	eb01 1184 	add.w	r1, r1, r4, lsl #6
10002780:	eb41 0153 	adc.w	r1, r1, r3, lsr #1
10002784:	f7ff fe0c 	bl	100023a0 <__aeabi_uldivmod>

                    /* find the largest IGAIN value that is less than or equal to ki_p */
                    uint32_t locigain = CY_SYSCLK_FLL_GAIN_VAL;
10002788:	4a6d      	ldr	r2, [pc, #436]	; (10002940 <Cy_SysClk_FllConfigure+0x2c8>)
                    uint32_t ki_p = (uint32_t)CY_SYSLIB_DIV_ROUND(850ULL * CY_SYSCLK_FLL_INT_COEF * inputFreq, (uint64_t)kcco * (uint64_t)config.refDiv);
1000278a:	230b      	movs	r3, #11
1000278c:	f04f 0c00 	mov.w	ip, #0
                    uint32_t locpgain = CY_SYSCLK_FLL_GAIN_VAL;

                    /* find the largest IGAIN value that is less than or equal to ki_p */
                    for(config.igain = CY_SYSCLK_FLL_GAIN_IDX; config.igain != 0UL; config.igain--)
                    {
                       if(locigain <= ki_p)
10002790:	4619      	mov	r1, r3
10002792:	4282      	cmp	r2, r0
10002794:	f103 33ff 	add.w	r3, r3, #4294967295
10002798:	b2db      	uxtb	r3, r3
1000279a:	d81c      	bhi.n	100027d6 <Cy_SysClk_FllConfigure+0x15e>
1000279c:	f1bc 0f00 	cmp.w	ip, #0
100027a0:	d116      	bne.n	100027d0 <Cy_SysClk_FllConfigure+0x158>
                    for(config.igain = CY_SYSCLK_FLL_GAIN_IDX; config.igain != 0UL; config.igain--)
100027a2:	230b      	movs	r3, #11
100027a4:	f88d 3016 	strb.w	r3, [sp, #22]
                          break;
                       }
                       locigain >>= 1U;
                    }
                    /* decrement igain if the WCO is the FLL source */
                    if (wcoSource && (config.igain > 0U))
100027a8:	f240 1311 	movw	r3, #273	; 0x111
100027ac:	4598      	cmp	r8, r3
100027ae:	d119      	bne.n	100027e4 <Cy_SysClk_FllConfigure+0x16c>
                    {
                        config.igain--;
100027b0:	1e4b      	subs	r3, r1, #1
100027b2:	f88d 3016 	strb.w	r3, [sp, #22]
                        locigain >>= 1U;
100027b6:	0852      	lsrs	r2, r2, #1
100027b8:	e014      	b.n	100027e4 <Cy_SysClk_FllConfigure+0x16c>
            config.ccoRange = ((ccoFreq >= 150339200UL) ? CY_SYSCLK_FLL_CCO_RANGE4 :
100027ba:	f04f 0904 	mov.w	r9, #4
100027be:	e78e      	b.n	100026de <Cy_SysClk_FllConfigure+0x66>
100027c0:	f04f 0903 	mov.w	r9, #3
100027c4:	e78b      	b.n	100026de <Cy_SysClk_FllConfigure+0x66>
100027c6:	f04f 0902 	mov.w	r9, #2
100027ca:	e788      	b.n	100026de <Cy_SysClk_FllConfigure+0x66>
            config.refDiv = wcoSource ? 19U : (uint16_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)inputFreq * 250ULL, (uint64_t)outputFreq);
100027cc:	2513      	movs	r5, #19
100027ce:	e798      	b.n	10002702 <Cy_SysClk_FllConfigure+0x8a>
100027d0:	f88d 1016 	strb.w	r1, [sp, #22]
100027d4:	e7e8      	b.n	100027a8 <Cy_SysClk_FllConfigure+0x130>
                       locigain >>= 1U;
100027d6:	0852      	lsrs	r2, r2, #1
                    for(config.igain = CY_SYSCLK_FLL_GAIN_IDX; config.igain != 0UL; config.igain--)
100027d8:	f04f 0c01 	mov.w	ip, #1
100027dc:	2b00      	cmp	r3, #0
100027de:	d1d7      	bne.n	10002790 <Cy_SysClk_FllConfigure+0x118>
100027e0:	f88d 3016 	strb.w	r3, [sp, #22]
                    uint32_t locpgain = CY_SYSCLK_FLL_GAIN_VAL;
100027e4:	4956      	ldr	r1, [pc, #344]	; (10002940 <Cy_SysClk_FllConfigure+0x2c8>)
                    uint32_t locigain = CY_SYSCLK_FLL_GAIN_VAL;
100027e6:	230b      	movs	r3, #11
100027e8:	f04f 0c00 	mov.w	ip, #0
                    }

                    /* then find the largest PGAIN value that is less than or equal to ki_p - igain */
                    for(config.pgain = CY_SYSCLK_FLL_GAIN_IDX; config.pgain != 0UL; config.pgain--)
                    {
                      if(locpgain <= (ki_p - locigain))
100027ec:	1a80      	subs	r0, r0, r2
100027ee:	461a      	mov	r2, r3
100027f0:	4281      	cmp	r1, r0
100027f2:	f103 33ff 	add.w	r3, r3, #4294967295
100027f6:	b2db      	uxtb	r3, r3
100027f8:	d80e      	bhi.n	10002818 <Cy_SysClk_FllConfigure+0x1a0>
100027fa:	f1bc 0f00 	cmp.w	ip, #0
100027fe:	d108      	bne.n	10002812 <Cy_SysClk_FllConfigure+0x19a>
                    for(config.pgain = CY_SYSCLK_FLL_GAIN_IDX; config.pgain != 0UL; config.pgain--)
10002800:	230b      	movs	r3, #11
10002802:	f88d 3017 	strb.w	r3, [sp, #23]
                      }
                      locpgain >>= 1U;
                    }

                    /* decrement pgain if the WCO is the FLL source */
                    if (wcoSource && (config.pgain > 0U))
10002806:	f240 1311 	movw	r3, #273	; 0x111
1000280a:	4598      	cmp	r8, r3
1000280c:	d10b      	bne.n	10002826 <Cy_SysClk_FllConfigure+0x1ae>
                    {
                        config.pgain--;
1000280e:	1e53      	subs	r3, r2, #1
10002810:	e007      	b.n	10002822 <Cy_SysClk_FllConfigure+0x1aa>
10002812:	f88d 2017 	strb.w	r2, [sp, #23]
10002816:	e7f6      	b.n	10002806 <Cy_SysClk_FllConfigure+0x18e>
                      locpgain >>= 1U;
10002818:	0849      	lsrs	r1, r1, #1
                    for(config.pgain = CY_SYSCLK_FLL_GAIN_IDX; config.pgain != 0UL; config.pgain--)
1000281a:	f04f 0c01 	mov.w	ip, #1
1000281e:	2b00      	cmp	r3, #0
10002820:	d1e5      	bne.n	100027ee <Cy_SysClk_FllConfigure+0x176>
                        config.pgain--;
10002822:	f88d 3017 	strb.w	r3, [sp, #23]
                    }
                }

        /* 8. Compute the CCO_FREQ bits in CLK_FLL_CONFIG4 register */
                {
                    uint64_t cmp = CY_SYSLIB_DIV_ROUND(((TRIM_STEPS_SCALE / MARGIN_SCALE) * (uint64_t)ccoFreq), (uint64_t)margin[config.ccoRange]);
10002826:	f04f 0b00 	mov.w	fp, #0
1000282a:	ea4f 0059 	mov.w	r0, r9, lsr #1
1000282e:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
10002832:	4659      	mov	r1, fp
10002834:	464a      	mov	r2, r9
10002836:	465b      	mov	r3, fp
10002838:	fbea 010c 	umlal	r0, r1, sl, ip
1000283c:	f7ff fdb0 	bl	100023a0 <__aeabi_uldivmod>
                    uint64_t mlt = TRIM_STEPS_SCALE + (uint64_t)trimSteps[config.ccoRange];
10002840:	4b40      	ldr	r3, [pc, #256]	; (10002944 <Cy_SysClk_FllConfigure+0x2cc>)
                    uint64_t cmp = CY_SYSLIB_DIV_ROUND(((TRIM_STEPS_SCALE / MARGIN_SCALE) * (uint64_t)ccoFreq), (uint64_t)margin[config.ccoRange]);
10002842:	9101      	str	r1, [sp, #4]
                    uint64_t mlt = TRIM_STEPS_SCALE + (uint64_t)trimSteps[config.ccoRange];
10002844:	18ff      	adds	r7, r7, r3
10002846:	f14b 0a00 	adc.w	sl, fp, #0
                    uint64_t cmp = CY_SYSLIB_DIV_ROUND(((TRIM_STEPS_SCALE / MARGIN_SCALE) * (uint64_t)ccoFreq), (uint64_t)margin[config.ccoRange]);
1000284a:	4681      	mov	r9, r0
                    uint64_t res = mlt;
1000284c:	4651      	mov	r1, sl
1000284e:	4638      	mov	r0, r7

                    config.cco_Freq = 0U;

                    while(res < cmp)
10002850:	465b      	mov	r3, fp
10002852:	465a      	mov	r2, fp
10002854:	f8dd c004 	ldr.w	ip, [sp, #4]
10002858:	4548      	cmp	r0, r9
1000285a:	eb71 0c0c 	sbcs.w	ip, r1, ip
1000285e:	f103 0b01 	add.w	fp, r3, #1
10002862:	d328      	bcc.n	100028b6 <Cy_SysClk_FllConfigure+0x23e>
                    config.cco_Freq = 0U;
10002864:	2a00      	cmp	r2, #0
10002866:	bf18      	it	ne
10002868:	469b      	movne	fp, r3
            {
                uint64_t fref = CY_SYSLIB_DIV_ROUND(6000ULL * (uint64_t)inputFreq, (uint64_t)config.refDiv);
                uint32_t divval = CY_SYSLIB_DIV_ROUNDUP(inputFreq, 1000000UL);
                uint32_t altval = (uint32_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)divval * fref, 6000000ULL) + 1UL;

                config.settlingCount = wcoSource ? 200U : (uint16_t)
1000286a:	f240 1311 	movw	r3, #273	; 0x111
                    config.cco_Freq = 0U;
1000286e:	bf08      	it	eq
10002870:	4693      	moveq	fp, r2
                config.settlingCount = wcoSource ? 200U : (uint16_t)
10002872:	4598      	cmp	r8, r3
                    config.cco_Freq = 0U;
10002874:	f8ad b01c 	strh.w	fp, [sp, #28]
                config.settlingCount = wcoSource ? 200U : (uint16_t)
10002878:	d03c      	beq.n	100028f4 <Cy_SysClk_FllConfigure+0x27c>
                uint64_t fref = CY_SYSLIB_DIV_ROUND(6000ULL * (uint64_t)inputFreq, (uint64_t)config.refDiv);
1000287a:	2700      	movs	r7, #0
1000287c:	f241 7c70 	movw	ip, #6000	; 0x1770
10002880:	4639      	mov	r1, r7
10002882:	0868      	lsrs	r0, r5, #1
10002884:	463b      	mov	r3, r7
10002886:	fbe4 010c 	umlal	r0, r1, r4, ip
1000288a:	462a      	mov	r2, r5
1000288c:	f7ff fd88 	bl	100023a0 <__aeabi_uldivmod>
                config.settlingCount = wcoSource ? 200U : (uint16_t)
10002890:	4286      	cmp	r6, r0
10002892:	418f      	sbcs	r7, r1
                uint32_t divval = CY_SYSLIB_DIV_ROUNDUP(inputFreq, 1000000UL);
10002894:	4b28      	ldr	r3, [pc, #160]	; (10002938 <Cy_SysClk_FllConfigure+0x2c0>)
10002896:	f104 34ff 	add.w	r4, r4, #4294967295
1000289a:	fbb4 f4f3 	udiv	r4, r4, r3
1000289e:	f104 0401 	add.w	r4, r4, #1
                config.settlingCount = wcoSource ? 200U : (uint16_t)
100028a2:	d217      	bcs.n	100028d4 <Cy_SysClk_FllConfigure+0x25c>
100028a4:	b2a4      	uxth	r4, r4
                          ((outputFreq < fref) ? divval :
                            ((divval > altval) ? divval : altval));
            }
        /* Configure FLL based on calculated values */
            retVal = Cy_SysClk_FllManualConfigure(&config);
100028a6:	a803      	add	r0, sp, #12
                config.settlingCount = wcoSource ? 200U : (uint16_t)
100028a8:	f8ad 4018 	strh.w	r4, [sp, #24]
            retVal = Cy_SysClk_FllManualConfigure(&config);
100028ac:	f002 fd16 	bl	100052dc <Cy_SysClk_FllManualConfigure>
            CY_REG32_CLR_SET(SRSS_CLK_FLL_CONFIG3, SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_INPUT);
        }
    }

    return (retVal);
}
100028b0:	b013      	add	sp, #76	; 0x4c
100028b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        res *= mlt;
100028b6:	fb00 f30a 	mul.w	r3, r0, sl
100028ba:	fb07 3101 	mla	r1, r7, r1, r3
100028be:	fba0 0c07 	umull	r0, ip, r0, r7
                        res /= TRIM_STEPS_SCALE;
100028c2:	a315      	add	r3, pc, #84	; (adr r3, 10002918 <Cy_SysClk_FllConfigure+0x2a0>)
100028c4:	e9d3 2300 	ldrd	r2, r3, [r3]
100028c8:	4461      	add	r1, ip
100028ca:	f7ff fd69 	bl	100023a0 <__aeabi_uldivmod>
100028ce:	465b      	mov	r3, fp
100028d0:	2201      	movs	r2, #1
100028d2:	e7bf      	b.n	10002854 <Cy_SysClk_FllConfigure+0x1dc>
                uint32_t altval = (uint32_t)CY_SYSLIB_DIV_ROUNDUP((uint64_t)divval * fref, 6000000ULL) + 1UL;
100028d4:	fba4 0300 	umull	r0, r3, r4, r0
100028d8:	3801      	subs	r0, #1
100028da:	fb04 3101 	mla	r1, r4, r1, r3
100028de:	f161 0100 	sbc.w	r1, r1, #0
100028e2:	4a19      	ldr	r2, [pc, #100]	; (10002948 <Cy_SysClk_FllConfigure+0x2d0>)
100028e4:	2300      	movs	r3, #0
100028e6:	f7ff fd5b 	bl	100023a0 <__aeabi_uldivmod>
100028ea:	3002      	adds	r0, #2
                config.settlingCount = wcoSource ? 200U : (uint16_t)
100028ec:	4284      	cmp	r4, r0
100028ee:	d8d9      	bhi.n	100028a4 <Cy_SysClk_FllConfigure+0x22c>
100028f0:	b284      	uxth	r4, r0
100028f2:	e7d8      	b.n	100028a6 <Cy_SysClk_FllConfigure+0x22e>
100028f4:	24c8      	movs	r4, #200	; 0xc8
100028f6:	e7d6      	b.n	100028a6 <Cy_SysClk_FllConfigure+0x22e>
            CY_REG32_CLR_SET(SRSS_CLK_FLL_CONFIG3, SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_INPUT);
100028f8:	4a14      	ldr	r2, [pc, #80]	; (1000294c <Cy_SysClk_FllConfigure+0x2d4>)
100028fa:	f8d2 3588 	ldr.w	r3, [r2, #1416]	; 0x588
100028fe:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
10002902:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
10002906:	f8c2 3588 	str.w	r3, [r2, #1416]	; 0x588
    cy_en_sysclk_status_t retVal = CY_SYSCLK_SUCCESS;
1000290a:	2000      	movs	r0, #0
1000290c:	e7d0      	b.n	100028b0 <Cy_SysClk_FllConfigure+0x238>
        retVal = CY_SYSCLK_BAD_PARAM;
1000290e:	4810      	ldr	r0, [pc, #64]	; (10002950 <Cy_SysClk_FllConfigure+0x2d8>)
    return (retVal);
10002910:	e7ce      	b.n	100028b0 <Cy_SysClk_FllConfigure+0x238>
10002912:	bf00      	nop
10002914:	f3af 8000 	nop.w
10002918:	05f5e100 	.word	0x05f5e100
1000291c:	00000000 	.word	0x00000000
10002920:	0487ab00 	.word	0x0487ab00
10002924:	08f5fe7f 	.word	0x08f5fe7f
10002928:	06bc62e3 	.word	0x06bc62e3
1000292c:	051036db 	.word	0x051036db
10002930:	03ce5bef 	.word	0x03ce5bef
10002934:	10009104 	.word	0x10009104
10002938:	000f4240 	.word	0x000f4240
1000293c:	d9900000 	.word	0xd9900000
10002940:	9c400000 	.word	0x9c400000
10002944:	05f5e100 	.word	0x05f5e100
10002948:	005b8d80 	.word	0x005b8d80
1000294c:	40260000 	.word	0x40260000
10002950:	004a0001 	.word	0x004a0001

10002954 <button_pressed>:
static struct gpio_dt_spec led = GPIO_DT_SPEC_GET_OR(DT_ALIAS(led0), gpios,
						     {0});

void button_pressed(const struct device *dev, struct gpio_callback *cb,
		    uint32_t pins)
{
10002954:	b508      	push	{r3, lr}
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
10002956:	f001 fb3b 	bl	10003fd0 <sys_clock_cycle_get_32>
	printk("Button pressed at %" PRIu32 "\n", k_cycle_get_32());
}
1000295a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
1000295e:	4601      	mov	r1, r0
	printk("Button pressed at %" PRIu32 "\n", k_cycle_get_32());
10002960:	4801      	ldr	r0, [pc, #4]	; (10002968 <button_pressed+0x14>)
10002962:	f005 ba2f 	b.w	10007dc4 <printk>
10002966:	bf00      	nop
10002968:	10009820 	.word	0x10009820

1000296c <main>:

int main(void)
{
1000296c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
1000296e:	4d49      	ldr	r5, [pc, #292]	; (10002a94 <main+0x128>)
10002970:	4628      	mov	r0, r5
10002972:	f006 fa61 	bl	10008e38 <z_device_is_ready>
	int ret;

	if (!gpio_is_ready_dt(&button)) {
10002976:	b930      	cbnz	r0, 10002986 <main+0x1a>
		printk("Error: button device %s is not ready\n",
10002978:	6829      	ldr	r1, [r5, #0]
1000297a:	4847      	ldr	r0, [pc, #284]	; (10002a98 <main+0x12c>)
1000297c:	f005 fa22 	bl	10007dc4 <printk>
			}
			k_msleep(SLEEP_TIME_MS);
		}
	}
	return 0;
}
10002980:	2000      	movs	r0, #0
10002982:	b003      	add	sp, #12
10002984:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ret = gpio_pin_configure_dt(&button, GPIO_INPUT);
10002986:	f44f 3180 	mov.w	r1, #65536	; 0x10000
1000298a:	4844      	ldr	r0, [pc, #272]	; (10002a9c <main+0x130>)
1000298c:	f005 fa03 	bl	10007d96 <gpio_pin_configure_dt>
	if (ret != 0) {
10002990:	4601      	mov	r1, r0
10002992:	b128      	cbz	r0, 100029a0 <main+0x34>
		printk("Error %d: failed to configure %s pin %d\n",
10002994:	682a      	ldr	r2, [r5, #0]
10002996:	4842      	ldr	r0, [pc, #264]	; (10002aa0 <main+0x134>)
10002998:	2304      	movs	r3, #4
		printk("Error %d: failed to configure interrupt on %s pin %d\n",
1000299a:	f005 fa13 	bl	10007dc4 <printk>
		return 0;
1000299e:	e7ef      	b.n	10002980 <main+0x14>

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
100029a0:	692b      	ldr	r3, [r5, #16]
	const struct gpio_driver_api *api =
100029a2:	68ae      	ldr	r6, [r5, #8]
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
100029a4:	681b      	ldr	r3, [r3, #0]
					     GPIO_INT_ENABLE_DISABLE_ONLY));
#else
	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
#endif /* CONFIG_GPIO_ENABLE_DISABLE_INTERRUPT */

	return api->pin_interrupt_configure(port, pin, mode, trig);
100029a6:	69b4      	ldr	r4, [r6, #24]
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
100029a8:	f013 0f10 	tst.w	r3, #16
	return api->pin_interrupt_configure(port, pin, mode, trig);
100029ac:	f04f 0104 	mov.w	r1, #4
100029b0:	bf14      	ite	ne
100029b2:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
100029b6:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
100029ba:	f04f 72a0 	mov.w	r2, #20971520	; 0x1400000
100029be:	4628      	mov	r0, r5
100029c0:	47a0      	blx	r4
			ret, button.port->name, button.pin);
100029c2:	682c      	ldr	r4, [r5, #0]
	if (ret != 0) {
100029c4:	4601      	mov	r1, r0
100029c6:	b118      	cbz	r0, 100029d0 <main+0x64>
		printk("Error %d: failed to configure interrupt on %s pin %d\n",
100029c8:	4836      	ldr	r0, [pc, #216]	; (10002aa4 <main+0x138>)
100029ca:	2304      	movs	r3, #4
100029cc:	4622      	mov	r2, r4
100029ce:	e7e4      	b.n	1000299a <main+0x2e>
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
100029d0:	4935      	ldr	r1, [pc, #212]	; (10002aa8 <main+0x13c>)
100029d2:	4b36      	ldr	r3, [pc, #216]	; (10002aac <main+0x140>)
100029d4:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
100029d6:	2310      	movs	r3, #16
100029d8:	608b      	str	r3, [r1, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
100029da:	69f3      	ldr	r3, [r6, #28]
100029dc:	b113      	cbz	r3, 100029e4 <main+0x78>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
100029de:	2201      	movs	r2, #1
100029e0:	4628      	mov	r0, r5
100029e2:	4798      	blx	r3
	printk("Set up button at %s pin %d\n", button.port->name, button.pin);
100029e4:	4621      	mov	r1, r4
	if (led.port && !device_is_ready(led.port)) {
100029e6:	4c32      	ldr	r4, [pc, #200]	; (10002ab0 <main+0x144>)
	printk("Set up button at %s pin %d\n", button.port->name, button.pin);
100029e8:	4832      	ldr	r0, [pc, #200]	; (10002ab4 <main+0x148>)
100029ea:	2204      	movs	r2, #4
100029ec:	f005 f9ea 	bl	10007dc4 <printk>
	if (led.port && !device_is_ready(led.port)) {
100029f0:	6820      	ldr	r0, [r4, #0]
100029f2:	b150      	cbz	r0, 10002a0a <main+0x9e>
100029f4:	f006 fa20 	bl	10008e38 <z_device_is_ready>
		       ret, led.port->name);
100029f8:	6823      	ldr	r3, [r4, #0]
	if (led.port && !device_is_ready(led.port)) {
100029fa:	4606      	mov	r6, r0
100029fc:	bb08      	cbnz	r0, 10002a42 <main+0xd6>
		printk("Error %d: LED device %s is not ready; ignoring it\n",
100029fe:	4601      	mov	r1, r0
10002a00:	681a      	ldr	r2, [r3, #0]
10002a02:	482d      	ldr	r0, [pc, #180]	; (10002ab8 <main+0x14c>)
10002a04:	f005 f9de 	bl	10007dc4 <printk>
		led.port = NULL;
10002a08:	6026      	str	r6, [r4, #0]
	printk("Press the button\n");
10002a0a:	482c      	ldr	r0, [pc, #176]	; (10002abc <main+0x150>)
10002a0c:	f005 f9da 	bl	10007dc4 <printk>
	if (led.port) {
10002a10:	6823      	ldr	r3, [r4, #0]
10002a12:	2b00      	cmp	r3, #0
10002a14:	d0b4      	beq.n	10002980 <main+0x14>
	const struct gpio_driver_data *const data =
10002a16:	692e      	ldr	r6, [r5, #16]
	return api->port_get_raw(port, value);
10002a18:	4f1e      	ldr	r7, [pc, #120]	; (10002a94 <main+0x128>)
10002a1a:	68ab      	ldr	r3, [r5, #8]
10002a1c:	a901      	add	r1, sp, #4
10002a1e:	685b      	ldr	r3, [r3, #4]
10002a20:	4638      	mov	r0, r7
10002a22:	4798      	blx	r3
	if (ret == 0) {
10002a24:	1e03      	subs	r3, r0, #0
10002a26:	d025      	beq.n	10002a74 <main+0x108>
			if (val >= 0) {
10002a28:	db2f      	blt.n	10002a8a <main+0x11e>
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
10002a2a:	7922      	ldrb	r2, [r4, #4]
	return gpio_pin_set(spec->port, spec->pin, value);
10002a2c:	6820      	ldr	r0, [r4, #0]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
10002a2e:	2101      	movs	r1, #1
10002a30:	4091      	lsls	r1, r2
10002a32:	6902      	ldr	r2, [r0, #16]
10002a34:	6812      	ldr	r2, [r2, #0]
10002a36:	4211      	tst	r1, r2
10002a38:	d022      	beq.n	10002a80 <main+0x114>
	if (value != 0)	{
10002a3a:	b31b      	cbz	r3, 10002a84 <main+0x118>
	return api->port_clear_bits_raw(port, pins);
10002a3c:	6883      	ldr	r3, [r0, #8]
10002a3e:	691b      	ldr	r3, [r3, #16]
10002a40:	e022      	b.n	10002a88 <main+0x11c>
	if (led.port) {
10002a42:	2b00      	cmp	r3, #0
10002a44:	d0e1      	beq.n	10002a0a <main+0x9e>
		ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT);
10002a46:	f44f 3100 	mov.w	r1, #131072	; 0x20000
10002a4a:	4620      	mov	r0, r4
10002a4c:	f005 f9a3 	bl	10007d96 <gpio_pin_configure_dt>
		if (ret != 0) {
10002a50:	7923      	ldrb	r3, [r4, #4]
10002a52:	4601      	mov	r1, r0
10002a54:	b138      	cbz	r0, 10002a66 <main+0xfa>
			       ret, led.port->name, led.pin);
10002a56:	6822      	ldr	r2, [r4, #0]
			printk("Error %d: failed to configure LED device %s pin %d\n",
10002a58:	4819      	ldr	r0, [pc, #100]	; (10002ac0 <main+0x154>)
10002a5a:	6812      	ldr	r2, [r2, #0]
10002a5c:	f005 f9b2 	bl	10007dc4 <printk>
			led.port = NULL;
10002a60:	2300      	movs	r3, #0
10002a62:	6023      	str	r3, [r4, #0]
10002a64:	e7d1      	b.n	10002a0a <main+0x9e>
			printk("Set up LED at %s pin %d\n", led.port->name, led.pin);
10002a66:	6821      	ldr	r1, [r4, #0]
10002a68:	4816      	ldr	r0, [pc, #88]	; (10002ac4 <main+0x158>)
10002a6a:	6809      	ldr	r1, [r1, #0]
10002a6c:	461a      	mov	r2, r3
10002a6e:	f005 f9a9 	bl	10007dc4 <printk>
10002a72:	e7ca      	b.n	10002a0a <main+0x9e>
		*value ^= data->invert;
10002a74:	6832      	ldr	r2, [r6, #0]
10002a76:	9b01      	ldr	r3, [sp, #4]
10002a78:	4053      	eors	r3, r2
		ret = (value & (gpio_port_pins_t)BIT(pin)) != 0 ? 1 : 0;
10002a7a:	f3c3 1300 	ubfx	r3, r3, #4, #1
			if (val >= 0) {
10002a7e:	e7d4      	b.n	10002a2a <main+0xbe>
	if (value != 0)	{
10002a80:	2b00      	cmp	r3, #0
10002a82:	d0db      	beq.n	10002a3c <main+0xd0>
	return api->port_set_bits_raw(port, pins);
10002a84:	6883      	ldr	r3, [r0, #8]
10002a86:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
10002a88:	4798      	blx	r3
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm0 = { .val = timeout };
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
10002a8a:	2100      	movs	r1, #0
10002a8c:	200a      	movs	r0, #10
10002a8e:	f004 ffa3 	bl	100079d8 <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
10002a92:	e7c2      	b.n	10002a1a <main+0xae>
10002a94:	100090d0 	.word	0x100090d0
10002a98:	10009836 	.word	0x10009836
10002a9c:	1000912c 	.word	0x1000912c
10002aa0:	1000985c 	.word	0x1000985c
10002aa4:	10009885 	.word	0x10009885
10002aa8:	08003008 	.word	0x08003008
10002aac:	10002955 	.word	0x10002955
10002ab0:	08002800 	.word	0x08002800
10002ab4:	100098bb 	.word	0x100098bb
10002ab8:	100098d7 	.word	0x100098d7
10002abc:	10009957 	.word	0x10009957
10002ac0:	1000990a 	.word	0x1000990a
10002ac4:	1000993e 	.word	0x1000993e

10002ac8 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
10002ac8:	4b01      	ldr	r3, [pc, #4]	; (10002ad0 <char_out+0x8>)
10002aca:	681b      	ldr	r3, [r3, #0]
10002acc:	4718      	bx	r3
10002ace:	bf00      	nop
10002ad0:	08002808 	.word	0x08002808

10002ad4 <__printk_hook_install>:
	_char_out = fn;
10002ad4:	4b01      	ldr	r3, [pc, #4]	; (10002adc <__printk_hook_install+0x8>)
10002ad6:	6018      	str	r0, [r3, #0]
}
10002ad8:	4770      	bx	lr
10002ada:	bf00      	nop
10002adc:	08002808 	.word	0x08002808

10002ae0 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
10002ae0:	b507      	push	{r0, r1, r2, lr}
10002ae2:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
10002ae4:	2100      	movs	r1, #0
10002ae6:	4602      	mov	r2, r0
10002ae8:	9100      	str	r1, [sp, #0]
10002aea:	4803      	ldr	r0, [pc, #12]	; (10002af8 <vprintk+0x18>)
10002aec:	f000 f806 	bl	10002afc <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
10002af0:	b003      	add	sp, #12
10002af2:	f85d fb04 	ldr.w	pc, [sp], #4
10002af6:	bf00      	nop
10002af8:	10002ac9 	.word	0x10002ac9

10002afc <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
10002afc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
10002b00:	4681      	mov	r9, r0
10002b02:	b095      	sub	sp, #84	; 0x54
10002b04:	468b      	mov	fp, r1
10002b06:	4617      	mov	r7, r2
10002b08:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
10002b0a:	2500      	movs	r5, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
10002b0c:	7838      	ldrb	r0, [r7, #0]
10002b0e:	b908      	cbnz	r0, 10002b14 <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
10002b10:	4628      	mov	r0, r5
10002b12:	e358      	b.n	100031c6 <z_cbvprintf_impl+0x6ca>
			OUTC(*fp++);
10002b14:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
10002b16:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
10002b18:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
10002b1a:	d006      	beq.n	10002b2a <z_cbvprintf_impl+0x2e>
			OUTC('%');
10002b1c:	4659      	mov	r1, fp
10002b1e:	47c8      	blx	r9
10002b20:	2800      	cmp	r0, #0
10002b22:	f2c0 8350 	blt.w	100031c6 <z_cbvprintf_impl+0x6ca>
10002b26:	3501      	adds	r5, #1
		if (bps == NULL) {
10002b28:	e1fb      	b.n	10002f22 <z_cbvprintf_impl+0x426>
		} state = {
10002b2a:	2218      	movs	r2, #24
10002b2c:	2100      	movs	r1, #0
10002b2e:	a80e      	add	r0, sp, #56	; 0x38
10002b30:	f005 fa06 	bl	10007f40 <memset>
	if (*sp == '%') {
10002b34:	787b      	ldrb	r3, [r7, #1]
10002b36:	2b25      	cmp	r3, #37	; 0x25
10002b38:	d07d      	beq.n	10002c36 <z_cbvprintf_impl+0x13a>
10002b3a:	2300      	movs	r3, #0
10002b3c:	1c78      	adds	r0, r7, #1
10002b3e:	4698      	mov	r8, r3
10002b40:	469e      	mov	lr, r3
10002b42:	469c      	mov	ip, r3
10002b44:	461e      	mov	r6, r3
10002b46:	4601      	mov	r1, r0
		switch (*sp) {
10002b48:	f810 2b01 	ldrb.w	r2, [r0], #1
10002b4c:	2a2b      	cmp	r2, #43	; 0x2b
10002b4e:	f000 80a1 	beq.w	10002c94 <z_cbvprintf_impl+0x198>
10002b52:	f200 8098 	bhi.w	10002c86 <z_cbvprintf_impl+0x18a>
10002b56:	2a20      	cmp	r2, #32
10002b58:	f000 809f 	beq.w	10002c9a <z_cbvprintf_impl+0x19e>
10002b5c:	2a23      	cmp	r2, #35	; 0x23
10002b5e:	f000 809f 	beq.w	10002ca0 <z_cbvprintf_impl+0x1a4>
10002b62:	b12b      	cbz	r3, 10002b70 <z_cbvprintf_impl+0x74>
10002b64:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
10002b68:	f043 0340 	orr.w	r3, r3, #64	; 0x40
10002b6c:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
10002b70:	f1b8 0f00 	cmp.w	r8, #0
10002b74:	d005      	beq.n	10002b82 <z_cbvprintf_impl+0x86>
10002b76:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
10002b7a:	f043 0320 	orr.w	r3, r3, #32
10002b7e:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
10002b82:	f1be 0f00 	cmp.w	lr, #0
10002b86:	d005      	beq.n	10002b94 <z_cbvprintf_impl+0x98>
10002b88:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
10002b8c:	f043 0310 	orr.w	r3, r3, #16
10002b90:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
10002b94:	f1bc 0f00 	cmp.w	ip, #0
10002b98:	d005      	beq.n	10002ba6 <z_cbvprintf_impl+0xaa>
10002b9a:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
10002b9e:	f043 0308 	orr.w	r3, r3, #8
10002ba2:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
10002ba6:	b12e      	cbz	r6, 10002bb4 <z_cbvprintf_impl+0xb8>
10002ba8:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
10002bac:	f043 0304 	orr.w	r3, r3, #4
10002bb0:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
10002bb4:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
10002bb8:	f003 0044 	and.w	r0, r3, #68	; 0x44
10002bbc:	2844      	cmp	r0, #68	; 0x44
10002bbe:	d103      	bne.n	10002bc8 <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
10002bc0:	f36f 1386 	bfc	r3, #6, #1
10002bc4:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
10002bc8:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
10002bcc:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
10002bce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
10002bd2:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
10002bd6:	d17f      	bne.n	10002cd8 <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
10002bd8:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
10002bdc:	f042 0201 	orr.w	r2, r2, #1
		return ++sp;
10002be0:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
10002be2:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
10002be6:	781a      	ldrb	r2, [r3, #0]
10002be8:	2a2e      	cmp	r2, #46	; 0x2e
10002bea:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
10002bee:	bf0c      	ite	eq
10002bf0:	2101      	moveq	r1, #1
10002bf2:	2100      	movne	r1, #0
10002bf4:	f361 0241 	bfi	r2, r1, #1, #1
10002bf8:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
10002bfc:	d178      	bne.n	10002cf0 <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
10002bfe:	785a      	ldrb	r2, [r3, #1]
10002c00:	2a2a      	cmp	r2, #42	; 0x2a
10002c02:	d06e      	beq.n	10002ce2 <z_cbvprintf_impl+0x1e6>
	++sp;
10002c04:	3301      	adds	r3, #1
	size_t val = 0;
10002c06:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
10002c08:	f04f 0c0a 	mov.w	ip, #10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
10002c0c:	4619      	mov	r1, r3
10002c0e:	f811 0b01 	ldrb.w	r0, [r1], #1
10002c12:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
10002c16:	2e09      	cmp	r6, #9
10002c18:	f240 8095 	bls.w	10002d46 <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
10002c1c:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
10002c20:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
10002c22:	f3c1 0040 	ubfx	r0, r1, #1, #1
10002c26:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
10002c2a:	460a      	mov	r2, r1
10002c2c:	f360 0241 	bfi	r2, r0, #1, #1
10002c30:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
10002c34:	e05c      	b.n	10002cf0 <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
10002c36:	1cba      	adds	r2, r7, #2
10002c38:	9203      	str	r2, [sp, #12]
10002c3a:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->width_star) {
10002c3e:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
10002c42:	07da      	lsls	r2, r3, #31
10002c44:	f140 812e 	bpl.w	10002ea4 <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
10002c48:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
10002c4c:	f1b8 0f00 	cmp.w	r8, #0
10002c50:	da07      	bge.n	10002c62 <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
10002c52:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
10002c56:	f042 0204 	orr.w	r2, r2, #4
10002c5a:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				width = -width;
10002c5e:	f1c8 0800 	rsb	r8, r8, #0
		if (conv->prec_star) {
10002c62:	075e      	lsls	r6, r3, #29
10002c64:	f140 8127 	bpl.w	10002eb6 <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
10002c68:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
10002c6c:	f1ba 0f00 	cmp.w	sl, #0
10002c70:	f280 8126 	bge.w	10002ec0 <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
10002c74:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
10002c78:	f36f 0341 	bfc	r3, #1, #1
10002c7c:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
10002c80:	f04f 3aff 	mov.w	sl, #4294967295
10002c84:	e11c      	b.n	10002ec0 <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
10002c86:	2a2d      	cmp	r2, #45	; 0x2d
10002c88:	d00d      	beq.n	10002ca6 <z_cbvprintf_impl+0x1aa>
10002c8a:	2a30      	cmp	r2, #48	; 0x30
10002c8c:	f47f af69 	bne.w	10002b62 <z_cbvprintf_impl+0x66>
10002c90:	2301      	movs	r3, #1
	} while (loop);
10002c92:	e758      	b.n	10002b46 <z_cbvprintf_impl+0x4a>
		switch (*sp) {
10002c94:	f04f 0c01 	mov.w	ip, #1
10002c98:	e755      	b.n	10002b46 <z_cbvprintf_impl+0x4a>
10002c9a:	f04f 0e01 	mov.w	lr, #1
10002c9e:	e752      	b.n	10002b46 <z_cbvprintf_impl+0x4a>
10002ca0:	f04f 0801 	mov.w	r8, #1
10002ca4:	e74f      	b.n	10002b46 <z_cbvprintf_impl+0x4a>
10002ca6:	2601      	movs	r6, #1
10002ca8:	e74d      	b.n	10002b46 <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
10002caa:	fb0e 6202 	mla	r2, lr, r2, r6
10002cae:	3a30      	subs	r2, #48	; 0x30
10002cb0:	4603      	mov	r3, r0
10002cb2:	4618      	mov	r0, r3
10002cb4:	f810 6b01 	ldrb.w	r6, [r0], #1
10002cb8:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
10002cbc:	f1bc 0f09 	cmp.w	ip, #9
10002cc0:	d9f3      	bls.n	10002caa <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
10002cc2:	4299      	cmp	r1, r3
10002cc4:	d08f      	beq.n	10002be6 <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
10002cc6:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
10002cca:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
10002ccc:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
10002cce:	f362 0141 	bfi	r1, r2, #1, #1
10002cd2:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
10002cd6:	e786      	b.n	10002be6 <z_cbvprintf_impl+0xea>
10002cd8:	460b      	mov	r3, r1
	size_t val = 0;
10002cda:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
10002cdc:	f04f 0e0a 	mov.w	lr, #10
10002ce0:	e7e7      	b.n	10002cb2 <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
10002ce2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
10002ce6:	f042 0204 	orr.w	r2, r2, #4
10002cea:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		return ++sp;
10002cee:	3302      	adds	r3, #2
	switch (*sp) {
10002cf0:	781a      	ldrb	r2, [r3, #0]
10002cf2:	2a6c      	cmp	r2, #108	; 0x6c
10002cf4:	d047      	beq.n	10002d86 <z_cbvprintf_impl+0x28a>
10002cf6:	d82b      	bhi.n	10002d50 <z_cbvprintf_impl+0x254>
10002cf8:	2a68      	cmp	r2, #104	; 0x68
10002cfa:	d031      	beq.n	10002d60 <z_cbvprintf_impl+0x264>
10002cfc:	2a6a      	cmp	r2, #106	; 0x6a
10002cfe:	d04b      	beq.n	10002d98 <z_cbvprintf_impl+0x29c>
10002d00:	2a4c      	cmp	r2, #76	; 0x4c
10002d02:	d051      	beq.n	10002da8 <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
10002d04:	461a      	mov	r2, r3
10002d06:	f812 3b01 	ldrb.w	r3, [r2], #1
10002d0a:	9203      	str	r2, [sp, #12]
	switch (conv->specifier) {
10002d0c:	2b78      	cmp	r3, #120	; 0x78
		if (conv->length_mod == LENGTH_UPPER_L) {
10002d0e:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	conv->specifier = *sp++;
10002d12:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
	switch (conv->specifier) {
10002d16:	f200 80be 	bhi.w	10002e96 <z_cbvprintf_impl+0x39a>
10002d1a:	2b6d      	cmp	r3, #109	; 0x6d
10002d1c:	d851      	bhi.n	10002dc2 <z_cbvprintf_impl+0x2c6>
10002d1e:	2b69      	cmp	r3, #105	; 0x69
10002d20:	f200 80b9 	bhi.w	10002e96 <z_cbvprintf_impl+0x39a>
10002d24:	2b57      	cmp	r3, #87	; 0x57
10002d26:	d867      	bhi.n	10002df8 <z_cbvprintf_impl+0x2fc>
10002d28:	2b41      	cmp	r3, #65	; 0x41
10002d2a:	d003      	beq.n	10002d34 <z_cbvprintf_impl+0x238>
10002d2c:	3b45      	subs	r3, #69	; 0x45
10002d2e:	2b02      	cmp	r3, #2
10002d30:	f200 80b1 	bhi.w	10002e96 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
10002d34:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
10002d38:	2204      	movs	r2, #4
10002d3a:	f362 0302 	bfi	r3, r2, #0, #3
10002d3e:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
10002d42:	2301      	movs	r3, #1
			break;
10002d44:	e073      	b.n	10002e2e <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
10002d46:	fb0c 0202 	mla	r2, ip, r2, r0
10002d4a:	3a30      	subs	r2, #48	; 0x30
10002d4c:	460b      	mov	r3, r1
10002d4e:	e75d      	b.n	10002c0c <z_cbvprintf_impl+0x110>
	switch (*sp) {
10002d50:	2a74      	cmp	r2, #116	; 0x74
10002d52:	d025      	beq.n	10002da0 <z_cbvprintf_impl+0x2a4>
10002d54:	2a7a      	cmp	r2, #122	; 0x7a
10002d56:	d1d5      	bne.n	10002d04 <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
10002d58:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
10002d5c:	2106      	movs	r1, #6
10002d5e:	e00c      	b.n	10002d7a <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
10002d60:	785a      	ldrb	r2, [r3, #1]
10002d62:	2a68      	cmp	r2, #104	; 0x68
10002d64:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
10002d68:	d106      	bne.n	10002d78 <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
10002d6a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
10002d6c:	f361 02c6 	bfi	r2, r1, #3, #4
10002d70:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
10002d74:	3302      	adds	r3, #2
10002d76:	e7c5      	b.n	10002d04 <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
10002d78:	2102      	movs	r1, #2
10002d7a:	f361 02c6 	bfi	r2, r1, #3, #4
10002d7e:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
10002d82:	3301      	adds	r3, #1
10002d84:	e7be      	b.n	10002d04 <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
10002d86:	785a      	ldrb	r2, [r3, #1]
10002d88:	2a6c      	cmp	r2, #108	; 0x6c
10002d8a:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
10002d8e:	d101      	bne.n	10002d94 <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
10002d90:	2104      	movs	r1, #4
10002d92:	e7eb      	b.n	10002d6c <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
10002d94:	2103      	movs	r1, #3
10002d96:	e7f0      	b.n	10002d7a <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
10002d98:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
10002d9c:	2105      	movs	r1, #5
10002d9e:	e7ec      	b.n	10002d7a <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
10002da0:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
10002da4:	2107      	movs	r1, #7
10002da6:	e7e8      	b.n	10002d7a <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
10002da8:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
10002dac:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
10002db0:	f022 0202 	bic.w	r2, r2, #2
10002db4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
10002db8:	f042 0202 	orr.w	r2, r2, #2
10002dbc:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
10002dc0:	e7df      	b.n	10002d82 <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
10002dc2:	3b6e      	subs	r3, #110	; 0x6e
10002dc4:	b2d9      	uxtb	r1, r3
10002dc6:	2301      	movs	r3, #1
10002dc8:	408b      	lsls	r3, r1
10002dca:	f240 4182 	movw	r1, #1154	; 0x482
10002dce:	420b      	tst	r3, r1
10002dd0:	d137      	bne.n	10002e42 <z_cbvprintf_impl+0x346>
10002dd2:	f013 0f24 	tst.w	r3, #36	; 0x24
10002dd6:	d151      	bne.n	10002e7c <z_cbvprintf_impl+0x380>
10002dd8:	07d8      	lsls	r0, r3, #31
10002dda:	d55c      	bpl.n	10002e96 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
10002ddc:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
10002de0:	2103      	movs	r1, #3
10002de2:	f361 0302 	bfi	r3, r1, #0, #3
10002de6:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
10002dea:	f002 0378 	and.w	r3, r2, #120	; 0x78
10002dee:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
10002df2:	424b      	negs	r3, r1
10002df4:	414b      	adcs	r3, r1
10002df6:	e01a      	b.n	10002e2e <z_cbvprintf_impl+0x332>
	switch (conv->specifier) {
10002df8:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
10002dfc:	b2c9      	uxtb	r1, r1
10002dfe:	2001      	movs	r0, #1
10002e00:	fa00 f101 	lsl.w	r1, r0, r1
10002e04:	f411 4f62 	tst.w	r1, #57856	; 0xe200
10002e08:	d194      	bne.n	10002d34 <z_cbvprintf_impl+0x238>
10002e0a:	f640 0601 	movw	r6, #2049	; 0x801
10002e0e:	4231      	tst	r1, r6
10002e10:	d11d      	bne.n	10002e4e <z_cbvprintf_impl+0x352>
10002e12:	f411 3f04 	tst.w	r1, #135168	; 0x21000
10002e16:	d03e      	beq.n	10002e96 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
10002e18:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
10002e1c:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
10002e20:	f002 0278 	and.w	r2, r2, #120	; 0x78
10002e24:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_SINT;
10002e26:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
10002e2a:	d034      	beq.n	10002e96 <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
10002e2c:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
10002e2e:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
10002e32:	f3c2 0140 	ubfx	r1, r2, #1, #1
10002e36:	430b      	orrs	r3, r1
10002e38:	f363 0241 	bfi	r2, r3, #1, #1
10002e3c:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
10002e40:	e6fd      	b.n	10002c3e <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
10002e42:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
10002e46:	2102      	movs	r1, #2
10002e48:	f361 0302 	bfi	r3, r1, #0, #3
10002e4c:	e7e8      	b.n	10002e20 <z_cbvprintf_impl+0x324>
10002e4e:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
10002e52:	2002      	movs	r0, #2
		if (conv->length_mod == LENGTH_UPPER_L) {
10002e54:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
10002e58:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
10002e5c:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
10002e5e:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
10002e62:	bf02      	ittt	eq
10002e64:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
10002e68:	f041 0101 	orreq.w	r1, r1, #1
10002e6c:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
10002e70:	2b63      	cmp	r3, #99	; 0x63
10002e72:	d1db      	bne.n	10002e2c <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
10002e74:	1e13      	subs	r3, r2, #0
10002e76:	bf18      	it	ne
10002e78:	2301      	movne	r3, #1
10002e7a:	e7d8      	b.n	10002e2e <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
10002e7c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
10002e80:	2103      	movs	r1, #3
10002e82:	f361 0302 	bfi	r3, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
10002e86:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
10002e8a:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
10002e8e:	bf14      	ite	ne
10002e90:	2301      	movne	r3, #1
10002e92:	2300      	moveq	r3, #0
10002e94:	e7cb      	b.n	10002e2e <z_cbvprintf_impl+0x332>
		conv->invalid = true;
10002e96:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
10002e9a:	f043 0301 	orr.w	r3, r3, #1
10002e9e:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
10002ea2:	e7c3      	b.n	10002e2c <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
10002ea4:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
10002ea8:	2a00      	cmp	r2, #0
			width = conv->width_value;
10002eaa:	bfb4      	ite	lt
10002eac:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
		int width = -1;
10002eb0:	f04f 38ff 	movge.w	r8, #4294967295
10002eb4:	e6d5      	b.n	10002c62 <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
10002eb6:	0798      	lsls	r0, r3, #30
10002eb8:	f57f aee2 	bpl.w	10002c80 <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
10002ebc:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
			= (enum length_mod_enum)conv->length_mod;
10002ec0:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		conv->pad0_value = 0;
10002ec4:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
10002ec6:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
10002eca:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
		enum specifier_cat_enum specifier_cat
10002ece:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
10002ed2:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
10002ed4:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
10002ed8:	d133      	bne.n	10002f42 <z_cbvprintf_impl+0x446>
			switch (length_mod) {
10002eda:	1ecb      	subs	r3, r1, #3
10002edc:	2b04      	cmp	r3, #4
10002ede:	d804      	bhi.n	10002eea <z_cbvprintf_impl+0x3ee>
10002ee0:	e8df f003 	tbb	[pc, r3]
10002ee4:	21464621 	.word	0x21464621
10002ee8:	21          	.byte	0x21
10002ee9:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
10002eea:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
10002eec:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
10002eee:	ea4f 72e3 	mov.w	r2, r3, asr #31
10002ef2:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
10002ef6:	d11c      	bne.n	10002f32 <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
10002ef8:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
10002efc:	17da      	asrs	r2, r3, #31
10002efe:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
10002f02:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
10002f04:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
10002f08:	f013 0603 	ands.w	r6, r3, #3
10002f0c:	d050      	beq.n	10002fb0 <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
10002f0e:	9b03      	ldr	r3, [sp, #12]
10002f10:	463a      	mov	r2, r7
10002f12:	4659      	mov	r1, fp
10002f14:	4648      	mov	r0, r9
10002f16:	f004 ffb2 	bl	10007e7e <outs>
10002f1a:	2800      	cmp	r0, #0
10002f1c:	f2c0 8153 	blt.w	100031c6 <z_cbvprintf_impl+0x6ca>
10002f20:	4405      	add	r5, r0
			continue;
10002f22:	9f03      	ldr	r7, [sp, #12]
10002f24:	e5f2      	b.n	10002b0c <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
10002f26:	f854 3b04 	ldr.w	r3, [r4], #4
10002f2a:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
10002f2c:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
10002f30:	e7e8      	b.n	10002f04 <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
10002f32:	2902      	cmp	r1, #2
10002f34:	d1e5      	bne.n	10002f02 <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
10002f36:	b21a      	sxth	r2, r3
10002f38:	f343 33c0 	sbfx	r3, r3, #15, #1
10002f3c:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
10002f40:	e7df      	b.n	10002f02 <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
10002f42:	2b02      	cmp	r3, #2
10002f44:	d124      	bne.n	10002f90 <z_cbvprintf_impl+0x494>
			switch (length_mod) {
10002f46:	1ecb      	subs	r3, r1, #3
10002f48:	2b04      	cmp	r3, #4
10002f4a:	d804      	bhi.n	10002f56 <z_cbvprintf_impl+0x45a>
10002f4c:	e8df f003 	tbb	[pc, r3]
10002f50:	18101018 	.word	0x18101018
10002f54:	18          	.byte	0x18
10002f55:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
10002f56:	2901      	cmp	r1, #1
				value->uint = va_arg(ap, unsigned int);
10002f58:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
10002f5c:	f04f 0200 	mov.w	r2, #0
10002f60:	d014      	beq.n	10002f8c <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
10002f62:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
10002f64:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
10002f68:	d1cc      	bne.n	10002f04 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
10002f6a:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
10002f6c:	930e      	str	r3, [sp, #56]	; 0x38
10002f6e:	e7c9      	b.n	10002f04 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
10002f70:	3407      	adds	r4, #7
10002f72:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
10002f76:	e8f4 2302 	ldrd	r2, r3, [r4], #8
10002f7a:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
10002f7e:	e7c1      	b.n	10002f04 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
10002f80:	f854 3b04 	ldr.w	r3, [r4], #4
10002f84:	930e      	str	r3, [sp, #56]	; 0x38
10002f86:	2300      	movs	r3, #0
10002f88:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
10002f8a:	e7bb      	b.n	10002f04 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
10002f8c:	b2db      	uxtb	r3, r3
10002f8e:	e7cd      	b.n	10002f2c <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
10002f90:	2b04      	cmp	r3, #4
10002f92:	d108      	bne.n	10002fa6 <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
10002f94:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
10002f96:	f024 0407 	bic.w	r4, r4, #7
10002f9a:	e9d4 2300 	ldrd	r2, r3, [r4]
10002f9e:	3408      	adds	r4, #8
10002fa0:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
10002fa4:	e7ae      	b.n	10002f04 <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
10002fa6:	2b03      	cmp	r3, #3
10002fa8:	d1ac      	bne.n	10002f04 <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
10002faa:	f854 3b04 	ldr.w	r3, [r4], #4
10002fae:	e7dd      	b.n	10002f6c <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
10002fb0:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
10002fb4:	2878      	cmp	r0, #120	; 0x78
10002fb6:	d8b4      	bhi.n	10002f22 <z_cbvprintf_impl+0x426>
10002fb8:	2862      	cmp	r0, #98	; 0x62
10002fba:	d81c      	bhi.n	10002ff6 <z_cbvprintf_impl+0x4fa>
10002fbc:	2825      	cmp	r0, #37	; 0x25
10002fbe:	f43f adad 	beq.w	10002b1c <z_cbvprintf_impl+0x20>
10002fc2:	2858      	cmp	r0, #88	; 0x58
10002fc4:	d1ad      	bne.n	10002f22 <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
10002fc6:	f10d 0336 	add.w	r3, sp, #54	; 0x36
10002fca:	9300      	str	r3, [sp, #0]
10002fcc:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
10002fd0:	ab08      	add	r3, sp, #32
10002fd2:	aa10      	add	r2, sp, #64	; 0x40
10002fd4:	f004 ff0d 	bl	10007df2 <encode_uint>
			if (precision >= 0) {
10002fd8:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
10002fdc:	4607      	mov	r7, r0
			if (precision >= 0) {
10002fde:	f280 809a 	bge.w	10003116 <z_cbvprintf_impl+0x61a>
		if (bps == NULL) {
10002fe2:	2f00      	cmp	r7, #0
10002fe4:	d09d      	beq.n	10002f22 <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
10002fe6:	f10d 0336 	add.w	r3, sp, #54	; 0x36
10002fea:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
10002fec:	2e00      	cmp	r6, #0
10002fee:	f000 80c1 	beq.w	10003174 <z_cbvprintf_impl+0x678>
			nj_len += 1U;
10002ff2:	3001      	adds	r0, #1
10002ff4:	e0be      	b.n	10003174 <z_cbvprintf_impl+0x678>
		switch (conv->specifier) {
10002ff6:	3863      	subs	r0, #99	; 0x63
10002ff8:	2815      	cmp	r0, #21
10002ffa:	d892      	bhi.n	10002f22 <z_cbvprintf_impl+0x426>
10002ffc:	a201      	add	r2, pc, #4	; (adr r2, 10003004 <z_cbvprintf_impl+0x508>)
10002ffe:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
10003002:	bf00      	nop
10003004:	100030d9 	.word	0x100030d9
10003008:	100030eb 	.word	0x100030eb
1000300c:	10002f23 	.word	0x10002f23
10003010:	10002f23 	.word	0x10002f23
10003014:	10002f23 	.word	0x10002f23
10003018:	10002f23 	.word	0x10002f23
1000301c:	100030eb 	.word	0x100030eb
10003020:	10002f23 	.word	0x10002f23
10003024:	10002f23 	.word	0x10002f23
10003028:	10002f23 	.word	0x10002f23
1000302c:	10002f23 	.word	0x10002f23
10003030:	10003179 	.word	0x10003179
10003034:	10003111 	.word	0x10003111
10003038:	10003137 	.word	0x10003137
1000303c:	10002f23 	.word	0x10002f23
10003040:	10002f23 	.word	0x10002f23
10003044:	1000305d 	.word	0x1000305d
10003048:	10002f23 	.word	0x10002f23
1000304c:	10003111 	.word	0x10003111
10003050:	10002f23 	.word	0x10002f23
10003054:	10002f23 	.word	0x10002f23
10003058:	10003111 	.word	0x10003111
			if (precision >= 0) {
1000305c:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
10003060:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
10003062:	db35      	blt.n	100030d0 <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
10003064:	4651      	mov	r1, sl
10003066:	4638      	mov	r0, r7
10003068:	f004 ff76 	bl	10007f58 <strnlen>
			bpe = bps + len;
1000306c:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
10003070:	2f00      	cmp	r7, #0
10003072:	f43f af56 	beq.w	10002f22 <z_cbvprintf_impl+0x426>
		char sign = 0;
10003076:	2600      	movs	r6, #0
		if (conv->altform_0c) {
10003078:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
1000307c:	f013 0210 	ands.w	r2, r3, #16
10003080:	9205      	str	r2, [sp, #20]
10003082:	f000 8093 	beq.w	100031ac <z_cbvprintf_impl+0x6b0>
			nj_len += 2U;
10003086:	3002      	adds	r0, #2
		if (conv->pad_fp) {
10003088:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
1000308a:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
1000308c:	bf48      	it	mi
1000308e:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
10003090:	9204      	str	r2, [sp, #16]
10003092:	4410      	add	r0, r2
			nj_len += conv->pad0_pre_exp;
10003094:	bf48      	it	mi
10003096:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
10003098:	f1b8 0f00 	cmp.w	r8, #0
1000309c:	f340 80a0 	ble.w	100031e0 <z_cbvprintf_impl+0x6e4>
			if (!conv->flag_dash) {
100030a0:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
100030a4:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
100030a8:	f3c2 0380 	ubfx	r3, r2, #2, #1
100030ac:	0750      	lsls	r0, r2, #29
100030ae:	9306      	str	r3, [sp, #24]
100030b0:	f100 8096 	bmi.w	100031e0 <z_cbvprintf_impl+0x6e4>
				if (conv->flag_zero) {
100030b4:	0651      	lsls	r1, r2, #25
100030b6:	f140 8089 	bpl.w	100031cc <z_cbvprintf_impl+0x6d0>
					if (sign != 0) {
100030ba:	b13e      	cbz	r6, 100030cc <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
100030bc:	4659      	mov	r1, fp
100030be:	4630      	mov	r0, r6
100030c0:	47c8      	blx	r9
100030c2:	2800      	cmp	r0, #0
100030c4:	db7f      	blt.n	100031c6 <z_cbvprintf_impl+0x6ca>
100030c6:	9b06      	ldr	r3, [sp, #24]
100030c8:	3501      	adds	r5, #1
100030ca:	461e      	mov	r6, r3
					pad = '0';
100030cc:	2230      	movs	r2, #48	; 0x30
100030ce:	e07e      	b.n	100031ce <z_cbvprintf_impl+0x6d2>
				len = strlen(bps);
100030d0:	4638      	mov	r0, r7
100030d2:	f004 ff23 	bl	10007f1c <strlen>
100030d6:	e7c9      	b.n	1000306c <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
100030d8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
100030da:	f88d 3020 	strb.w	r3, [sp, #32]
		char sign = 0;
100030de:	2600      	movs	r6, #0
			bps = buf;
100030e0:	af08      	add	r7, sp, #32
			bpe = buf + 1;
100030e2:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
		size_t nj_len = (bpe - bps);
100030e6:	2001      	movs	r0, #1
100030e8:	e7c6      	b.n	10003078 <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
100030ea:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
100030ec:	bf5c      	itt	pl
100030ee:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
100030f2:	015e      	lslpl	r6, r3, #5
			sint = value->sint;
100030f4:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
				sign = '+';
100030f8:	bf48      	it	mi
100030fa:	262b      	movmi	r6, #43	; 0x2b
			if (sint < 0) {
100030fc:	2b00      	cmp	r3, #0
100030fe:	f6bf af62 	bge.w	10002fc6 <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
10003102:	4252      	negs	r2, r2
10003104:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
10003108:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
				sign = '-';
1000310c:	262d      	movs	r6, #45	; 0x2d
1000310e:	e75a      	b.n	10002fc6 <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
10003110:	2600      	movs	r6, #0
10003112:	e758      	b.n	10002fc6 <z_cbvprintf_impl+0x4ca>
		char sign = 0;
10003114:	2600      	movs	r6, #0
				conv->flag_zero = false;
10003116:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
1000311a:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1000311e:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
10003120:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
10003124:	459a      	cmp	sl, r3
				conv->flag_zero = false;
10003126:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
1000312a:	f67f af5a 	bls.w	10002fe2 <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
1000312e:	ebaa 0303 	sub.w	r3, sl, r3
10003132:	9311      	str	r3, [sp, #68]	; 0x44
10003134:	e755      	b.n	10002fe2 <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
10003136:	980e      	ldr	r0, [sp, #56]	; 0x38
10003138:	b390      	cbz	r0, 100031a0 <z_cbvprintf_impl+0x6a4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
1000313a:	f10d 0336 	add.w	r3, sp, #54	; 0x36
1000313e:	9300      	str	r3, [sp, #0]
10003140:	aa10      	add	r2, sp, #64	; 0x40
10003142:	ab08      	add	r3, sp, #32
10003144:	2100      	movs	r1, #0
10003146:	f004 fe54 	bl	10007df2 <encode_uint>
				conv->altform_0c = true;
1000314a:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
1000314e:	f003 03ef 	and.w	r3, r3, #239	; 0xef
10003152:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
10003156:	f043 0310 	orr.w	r3, r3, #16
			if (precision >= 0) {
1000315a:	f1ba 0f00 	cmp.w	sl, #0
				bps = encode_uint((uintptr_t)value->ptr, conv,
1000315e:	4607      	mov	r7, r0
				conv->altform_0c = true;
10003160:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
10003164:	dad6      	bge.n	10003114 <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
10003166:	2800      	cmp	r0, #0
10003168:	f43f aedb 	beq.w	10002f22 <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
1000316c:	f10d 0336 	add.w	r3, sp, #54	; 0x36
10003170:	1a18      	subs	r0, r3, r0
		char sign = 0;
10003172:	2600      	movs	r6, #0
10003174:	469a      	mov	sl, r3
10003176:	e77f      	b.n	10003078 <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
10003178:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
1000317a:	2907      	cmp	r1, #7
1000317c:	f63f aed1 	bhi.w	10002f22 <z_cbvprintf_impl+0x426>
10003180:	e8df f001 	tbb	[pc, r1]
10003184:	0c06040c 	.word	0x0c06040c
10003188:	0c0c0808 	.word	0x0c0c0808
		*(signed char *)dp = (signed char)count;
1000318c:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
1000318e:	e6c8      	b.n	10002f22 <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
10003190:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
10003192:	e6c6      	b.n	10002f22 <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
10003194:	17ea      	asrs	r2, r5, #31
10003196:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
1000319a:	e6c2      	b.n	10002f22 <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
1000319c:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
1000319e:	e6c0      	b.n	10002f22 <z_cbvprintf_impl+0x426>
100031a0:	4f2e      	ldr	r7, [pc, #184]	; (1000325c <z_cbvprintf_impl+0x760>)
		char sign = 0;
100031a2:	4606      	mov	r6, r0
			bpe = bps + 5;
100031a4:	f107 0a05 	add.w	sl, r7, #5
		size_t nj_len = (bpe - bps);
100031a8:	2005      	movs	r0, #5
100031aa:	e765      	b.n	10003078 <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
100031ac:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
100031ae:	bf48      	it	mi
100031b0:	3001      	addmi	r0, #1
100031b2:	e769      	b.n	10003088 <z_cbvprintf_impl+0x58c>
100031b4:	9307      	str	r3, [sp, #28]
					OUTC(pad);
100031b6:	4610      	mov	r0, r2
100031b8:	9206      	str	r2, [sp, #24]
100031ba:	4659      	mov	r1, fp
100031bc:	47c8      	blx	r9
100031be:	2800      	cmp	r0, #0
100031c0:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
100031c4:	da04      	bge.n	100031d0 <z_cbvprintf_impl+0x6d4>
#undef OUTS
#undef OUTC
}
100031c6:	b015      	add	sp, #84	; 0x54
100031c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
100031cc:	2220      	movs	r2, #32
					pad = '0';
100031ce:	4643      	mov	r3, r8
				while (width-- > 0) {
100031d0:	4619      	mov	r1, r3
100031d2:	2900      	cmp	r1, #0
100031d4:	f103 33ff 	add.w	r3, r3, #4294967295
100031d8:	dcec      	bgt.n	100031b4 <z_cbvprintf_impl+0x6b8>
100031da:	4445      	add	r5, r8
100031dc:	1a6d      	subs	r5, r5, r1
100031de:	4698      	mov	r8, r3
		if (sign != 0) {
100031e0:	b12e      	cbz	r6, 100031ee <z_cbvprintf_impl+0x6f2>
			OUTC(sign);
100031e2:	4659      	mov	r1, fp
100031e4:	4630      	mov	r0, r6
100031e6:	47c8      	blx	r9
100031e8:	2800      	cmp	r0, #0
100031ea:	dbec      	blt.n	100031c6 <z_cbvprintf_impl+0x6ca>
100031ec:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
100031ee:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
100031f2:	06da      	lsls	r2, r3, #27
100031f4:	d401      	bmi.n	100031fa <z_cbvprintf_impl+0x6fe>
100031f6:	071b      	lsls	r3, r3, #28
100031f8:	d505      	bpl.n	10003206 <z_cbvprintf_impl+0x70a>
				OUTC('0');
100031fa:	4659      	mov	r1, fp
100031fc:	2030      	movs	r0, #48	; 0x30
100031fe:	47c8      	blx	r9
10003200:	2800      	cmp	r0, #0
10003202:	dbe0      	blt.n	100031c6 <z_cbvprintf_impl+0x6ca>
10003204:	3501      	adds	r5, #1
			if (conv->altform_0c) {
10003206:	9b05      	ldr	r3, [sp, #20]
10003208:	b133      	cbz	r3, 10003218 <z_cbvprintf_impl+0x71c>
				OUTC(conv->specifier);
1000320a:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
1000320e:	4659      	mov	r1, fp
10003210:	47c8      	blx	r9
10003212:	2800      	cmp	r0, #0
10003214:	dbd7      	blt.n	100031c6 <z_cbvprintf_impl+0x6ca>
10003216:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
10003218:	9e04      	ldr	r6, [sp, #16]
1000321a:	442e      	add	r6, r5
1000321c:	e005      	b.n	1000322a <z_cbvprintf_impl+0x72e>
				OUTC('0');
1000321e:	4659      	mov	r1, fp
10003220:	2030      	movs	r0, #48	; 0x30
10003222:	47c8      	blx	r9
10003224:	2800      	cmp	r0, #0
10003226:	dbce      	blt.n	100031c6 <z_cbvprintf_impl+0x6ca>
10003228:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
1000322a:	1b73      	subs	r3, r6, r5
1000322c:	2b00      	cmp	r3, #0
1000322e:	dcf6      	bgt.n	1000321e <z_cbvprintf_impl+0x722>
			OUTS(bps, bpe);
10003230:	4653      	mov	r3, sl
10003232:	463a      	mov	r2, r7
10003234:	4659      	mov	r1, fp
10003236:	4648      	mov	r0, r9
10003238:	f004 fe21 	bl	10007e7e <outs>
1000323c:	2800      	cmp	r0, #0
1000323e:	dbc2      	blt.n	100031c6 <z_cbvprintf_impl+0x6ca>
10003240:	4405      	add	r5, r0
		while (width > 0) {
10003242:	44a8      	add	r8, r5
10003244:	eba8 0305 	sub.w	r3, r8, r5
10003248:	2b00      	cmp	r3, #0
1000324a:	f77f ae6a 	ble.w	10002f22 <z_cbvprintf_impl+0x426>
			OUTC(' ');
1000324e:	4659      	mov	r1, fp
10003250:	2020      	movs	r0, #32
10003252:	47c8      	blx	r9
10003254:	2800      	cmp	r0, #0
10003256:	dbb6      	blt.n	100031c6 <z_cbvprintf_impl+0x6ca>
10003258:	3501      	adds	r5, #1
			--width;
1000325a:	e7f3      	b.n	10003244 <z_cbvprintf_impl+0x748>
1000325c:	1000997a 	.word	0x1000997a

10003260 <z_isr_install>:
#endif /* CONFIG_MULTI_LEVEL_INTERRUPTS */

	/* If dynamic IRQs are enabled, then the _sw_isr_table is in RAM and
	 * can be modified
	 */
	_sw_isr_table[table_idx].arg = param;
10003260:	4b03      	ldr	r3, [pc, #12]	; (10003270 <z_isr_install+0x10>)
10003262:	f843 2030 	str.w	r2, [r3, r0, lsl #3]
	_sw_isr_table[table_idx].isr = routine;
10003266:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
1000326a:	6059      	str	r1, [r3, #4]
}
1000326c:	4770      	bx	lr
1000326e:	bf00      	nop
10003270:	08002984 	.word	0x08002984

10003274 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
10003274:	4901      	ldr	r1, [pc, #4]	; (1000327c <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
10003276:	2210      	movs	r2, #16
	str	r2, [r1]
10003278:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
1000327a:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
1000327c:	e000ed10 	.word	0xe000ed10

10003280 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
10003280:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
10003282:	4040      	eors	r0, r0
	msr	BASEPRI, r0
10003284:	f380 8811 	msr	BASEPRI, r0
	isb
10003288:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
1000328c:	f3bf 8f4f 	dsb	sy
10003290:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
10003292:	b662      	cpsie	i
	isb
10003294:	f3bf 8f6f 	isb	sy

	bx	lr
10003298:	4770      	bx	lr
1000329a:	bf00      	nop

1000329c <__NVIC_SetPriority>:
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
1000329c:	2800      	cmp	r0, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1000329e:	bfac      	ite	ge
100032a0:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
100032a4:	4b06      	ldrlt	r3, [pc, #24]	; (100032c0 <__NVIC_SetPriority+0x24>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
100032a6:	ea4f 1141 	mov.w	r1, r1, lsl #5
100032aa:	bfac      	ite	ge
100032ac:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
100032b0:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
100032b4:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
100032b6:	bfb4      	ite	lt
100032b8:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
100032ba:	f880 1300 	strbge.w	r1, [r0, #768]	; 0x300
  }
}
100032be:	4770      	bx	lr
100032c0:	e000ed14 	.word	0xe000ed14

100032c4 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
100032c4:	bf30      	wfi
    b z_SysNmiOnReset
100032c6:	f7ff bffd 	b.w	100032c4 <z_SysNmiOnReset>
100032ca:	bf00      	nop

100032cc <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
100032cc:	4a0f      	ldr	r2, [pc, #60]	; (1000330c <z_arm_prep_c+0x40>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
100032ce:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
100032d0:	4b0f      	ldr	r3, [pc, #60]	; (10003310 <z_arm_prep_c+0x44>)
100032d2:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
100032d6:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
100032d8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
100032dc:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
100032e0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
100032e4:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
100032e8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
100032ec:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
100032f0:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
100032f4:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
100032f8:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
100032fc:	f003 ffec 	bl	100072d8 <z_bss_zero>
	z_data_copy();
10003300:	f004 fbe8 	bl	10007ad4 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
10003304:	f000 fa14 	bl	10003730 <z_arm_interrupt_init>
	z_cstart();
10003308:	f004 f838 	bl	1000737c <z_cstart>
1000330c:	10002000 	.word	0x10002000
10003310:	e000ed00 	.word	0xe000ed00

10003314 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
10003314:	4a09      	ldr	r2, [pc, #36]	; (1000333c <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
10003316:	490a      	ldr	r1, [pc, #40]	; (10003340 <arch_swap+0x2c>)
	_current->arch.basepri = key;
10003318:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
1000331a:	6809      	ldr	r1, [r1, #0]
1000331c:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
1000331e:	4909      	ldr	r1, [pc, #36]	; (10003344 <arch_swap+0x30>)
	_current->arch.basepri = key;
10003320:	6758      	str	r0, [r3, #116]	; 0x74
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
10003322:	684b      	ldr	r3, [r1, #4]
10003324:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
10003328:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
1000332a:	2300      	movs	r3, #0
1000332c:	f383 8811 	msr	BASEPRI, r3
10003330:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
10003334:	6893      	ldr	r3, [r2, #8]
}
10003336:	6f98      	ldr	r0, [r3, #120]	; 0x78
10003338:	4770      	bx	lr
1000333a:	bf00      	nop
1000333c:	080037a0 	.word	0x080037a0
10003340:	1000978c 	.word	0x1000978c
10003344:	e000ed00 	.word	0xe000ed00

10003348 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
10003348:	4912      	ldr	r1, [pc, #72]	; (10003394 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
1000334a:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
1000334c:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
10003350:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
10003352:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
10003356:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
1000335a:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
1000335c:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
10003360:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
10003364:	4f0c      	ldr	r7, [pc, #48]	; (10003398 <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
10003366:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
1000336a:	694a      	ldr	r2, [r1, #20]

    str r2, [r1, #_kernel_offset_to_current]
1000336c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
1000336e:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
10003370:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
10003372:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
10003374:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
10003376:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
1000337a:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
1000337c:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
1000337e:	f000 fa1b 	bl	100037b8 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
10003382:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
10003386:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
1000338a:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
1000338e:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
10003392:	4770      	bx	lr
    ldr r1, =_kernel
10003394:	080037a0 	.word	0x080037a0
    ldr v4, =_SCS_ICSR
10003398:	e000ed04 	.word	0xe000ed04

1000339c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
1000339c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
100033a0:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
100033a2:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
100033a6:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
100033aa:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
100033ac:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
100033b0:	2902      	cmp	r1, #2
    beq _oops
100033b2:	d0ff      	beq.n	100033b4 <_oops>

100033b4 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
100033b4:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
100033b6:	f004 fd95 	bl	10007ee4 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
100033ba:	bd01      	pop	{r0, pc}

100033bc <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
100033bc:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
100033c0:	9b00      	ldr	r3, [sp, #0]
100033c2:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->pc &= 0xfffffffe;
100033c6:	490a      	ldr	r1, [pc, #40]	; (100033f0 <arch_new_thread+0x34>)
	iframe->a3 = (uint32_t)p2;
100033c8:	9b01      	ldr	r3, [sp, #4]
100033ca:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
100033ce:	9b02      	ldr	r3, [sp, #8]
100033d0:	f842 3c14 	str.w	r3, [r2, #-20]
	iframe->pc &= 0xfffffffe;
100033d4:	f021 0101 	bic.w	r1, r1, #1

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
100033d8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
100033dc:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->pc &= 0xfffffffe;
100033e0:	f842 1c08 	str.w	r1, [r2, #-8]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
100033e4:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
100033e6:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
100033e8:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
100033ea:	6743      	str	r3, [r0, #116]	; 0x74
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
100033ec:	4770      	bx	lr
100033ee:	bf00      	nop
100033f0:	10007ddf 	.word	0x10007ddf

100033f4 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
100033f4:	4a09      	ldr	r2, [pc, #36]	; (1000341c <z_check_thread_stack_fail+0x28>)
{
100033f6:	4603      	mov	r3, r0
	const struct k_thread *thread = _current;
100033f8:	6890      	ldr	r0, [r2, #8]

	if (thread == NULL) {
100033fa:	b170      	cbz	r0, 1000341a <z_check_thread_stack_fail+0x26>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
100033fc:	f113 0f16 	cmn.w	r3, #22
10003400:	6e40      	ldr	r0, [r0, #100]	; 0x64
10003402:	d005      	beq.n	10003410 <z_check_thread_stack_fail+0x1c>
10003404:	f1a0 0240 	sub.w	r2, r0, #64	; 0x40
10003408:	429a      	cmp	r2, r3
1000340a:	d805      	bhi.n	10003418 <z_check_thread_stack_fail+0x24>
1000340c:	4283      	cmp	r3, r0
1000340e:	d203      	bcs.n	10003418 <z_check_thread_stack_fail+0x24>
		return 0;
10003410:	4281      	cmp	r1, r0
10003412:	bf28      	it	cs
10003414:	2000      	movcs	r0, #0
10003416:	4770      	bx	lr
10003418:	2000      	movs	r0, #0
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
}
1000341a:	4770      	bx	lr
1000341c:	080037a0 	.word	0x080037a0

10003420 <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
10003420:	b508      	push	{r3, lr}
	z_arm_prepare_switch_to_main();

	_current = main_thread;
10003422:	4b09      	ldr	r3, [pc, #36]	; (10003448 <arch_switch_to_main_thread+0x28>)
{
10003424:	460d      	mov	r5, r1
10003426:	4614      	mov	r4, r2
	_current = main_thread;
10003428:	6098      	str	r0, [r3, #8]
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
1000342a:	f000 f9c5 	bl	100037b8 <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
1000342e:	4620      	mov	r0, r4
10003430:	f385 8809 	msr	PSP, r5
10003434:	2100      	movs	r1, #0
10003436:	b663      	cpsie	if
10003438:	f381 8811 	msr	BASEPRI, r1
1000343c:	f3bf 8f6f 	isb	sy
10003440:	2200      	movs	r2, #0
10003442:	2300      	movs	r3, #0
10003444:	f004 fccb 	bl	10007dde <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
10003448:	080037a0 	.word	0x080037a0

1000344c <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
1000344c:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
1000344e:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
10003452:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
10003456:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
1000345a:	4904      	ldr	r1, [pc, #16]	; (1000346c <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
1000345c:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
1000345e:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
10003460:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
10003462:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
10003466:	4902      	ldr	r1, [pc, #8]	; (10003470 <_isr_wrapper+0x24>)
	bx r1
10003468:	4708      	bx	r1
1000346a:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
1000346c:	08002984 	.word	0x08002984
	ldr r1, =z_arm_int_exit
10003470:	10003475 	.word	0x10003475

10003474 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
10003474:	4b04      	ldr	r3, [pc, #16]	; (10003488 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
10003476:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
10003478:	6958      	ldr	r0, [r3, #20]
	cmp r0, r1
1000347a:	4288      	cmp	r0, r1
	beq _EXIT_EXC
1000347c:	d003      	beq.n	10003486 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
1000347e:	4903      	ldr	r1, [pc, #12]	; (1000348c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
10003480:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
10003484:	600a      	str	r2, [r1, #0]

10003486 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
10003486:	4770      	bx	lr
	ldr r3, =_kernel
10003488:	080037a0 	.word	0x080037a0
	ldr r1, =_SCS_ICSR
1000348c:	e000ed04 	.word	0xe000ed04

10003490 <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
10003490:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
10003492:	4b26      	ldr	r3, [pc, #152]	; (1000352c <mem_manage_fault+0x9c>)
{
10003494:	4615      	mov	r5, r2
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
10003496:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
10003498:	f012 0f10 	tst.w	r2, #16
		reason = K_ERR_ARM_MEM_STACKING;
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
1000349c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
1000349e:	bf14      	ite	ne
100034a0:	2411      	movne	r4, #17
100034a2:	2410      	moveq	r4, #16
		reason = K_ERR_ARM_MEM_UNSTACKING;
100034a4:	f012 0f08 	tst.w	r2, #8
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
100034a8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_UNSTACKING;
100034aa:	bf18      	it	ne
100034ac:	2412      	movne	r4, #18
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
100034ae:	0792      	lsls	r2, r2, #30
{
100034b0:	4606      	mov	r6, r0
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
100034b2:	d50a      	bpl.n	100034ca <mem_manage_fault+0x3a>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
100034b4:	6b58      	ldr	r0, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
100034b6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
100034b8:	0614      	lsls	r4, r2, #24
100034ba:	d534      	bpl.n	10003526 <mem_manage_fault+0x96>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault != 0) {
100034bc:	b119      	cbz	r1, 100034c6 <mem_manage_fault+0x36>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
100034be:	6a9a      	ldr	r2, [r3, #40]	; 0x28
100034c0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
100034c4:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
100034c6:	2413      	movs	r4, #19
100034c8:	e001      	b.n	100034ce <mem_manage_fault+0x3e>
	uint32_t mmfar = -EINVAL;
100034ca:	f06f 0015 	mvn.w	r0, #21
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
100034ce:	4b17      	ldr	r3, [pc, #92]	; (1000352c <mem_manage_fault+0x9c>)
100034d0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
100034d2:	f012 0f01 	tst.w	r2, #1
		PR_FAULT_INFO("  Instruction Access Violation");
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
100034d6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
100034d8:	bf18      	it	ne
100034da:	2414      	movne	r4, #20
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
100034dc:	f012 0f20 	tst.w	r2, #32
	 * crossed into an area beyond the thread stack.]
	 *
	 * Data Access Violation errors may or may not be caused by
	 * thread stack overflows.
	 */
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
100034e0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
100034e2:	bf18      	it	ne
100034e4:	2415      	movne	r4, #21
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
100034e6:	06d2      	lsls	r2, r2, #27
100034e8:	d402      	bmi.n	100034f0 <mem_manage_fault+0x60>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
100034ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
100034ec:	079b      	lsls	r3, r3, #30
100034ee:	d50a      	bpl.n	10003506 <mem_manage_fault+0x76>
		 * not accompanied by a data access violation error (i.e.
		 * when stack overflows due to the exception entry frame
		 * stacking): z_check_thread_stack_fail() shall be able to
		 * handle the case of 'mmfar' holding the -EINVAL value.
		 */
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
100034f0:	4b0e      	ldr	r3, [pc, #56]	; (1000352c <mem_manage_fault+0x9c>)
100034f2:	685b      	ldr	r3, [r3, #4]
100034f4:	0519      	lsls	r1, r3, #20
100034f6:	d506      	bpl.n	10003506 <mem_manage_fault+0x76>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
100034f8:	4631      	mov	r1, r6
100034fa:	f7ff ff7b 	bl	100033f4 <z_check_thread_stack_fail>
				((uint32_t) &esf[0]));

			if (min_stack_ptr) {
100034fe:	b110      	cbz	r0, 10003506 <mem_manage_fault+0x76>
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
10003500:	f380 8809 	msr	PSP, r0
				 * fatal error and a thread that corrupted its
				 * stack needs to be aborted.
				 */
				__set_PSP(min_stack_ptr);

				reason = K_ERR_STACK_CHK_FAIL;
10003504:	2402      	movs	r4, #2
	 * lazy stacking Memory Manage fault. At the time of writing, this
	 * can happen when printing.  If that's true, we should clear the
	 * pending flag in addition to the clearing the reason for the fault
	 */
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
10003506:	4b09      	ldr	r3, [pc, #36]	; (1000352c <mem_manage_fault+0x9c>)
10003508:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1000350a:	0692      	lsls	r2, r2, #26
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
1000350c:	bf42      	ittt	mi
1000350e:	6a5a      	ldrmi	r2, [r3, #36]	; 0x24
10003510:	f422 5200 	bicmi.w	r2, r2, #8192	; 0x2000
10003514:	625a      	strmi	r2, [r3, #36]	; 0x24
	}
#endif /* CONFIG_ARMV7_M_ARMV8_M_FP */

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
10003516:	6a9a      	ldr	r2, [r3, #40]	; 0x28
10003518:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
1000351c:	629a      	str	r2, [r3, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);
1000351e:	2300      	movs	r3, #0
10003520:	702b      	strb	r3, [r5, #0]

	return reason;
}
10003522:	4620      	mov	r0, r4
10003524:	bd70      	pop	{r4, r5, r6, pc}
	uint32_t mmfar = -EINVAL;
10003526:	f06f 0015 	mvn.w	r0, #21
1000352a:	e7cc      	b.n	100034c6 <mem_manage_fault+0x36>
1000352c:	e000ed00 	.word	0xe000ed00

10003530 <usage_fault.constprop.0>:
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
10003530:	4b13      	ldr	r3, [pc, #76]	; (10003580 <usage_fault.constprop.0+0x50>)
10003532:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
10003534:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
		reason = K_ERR_ARM_USAGE_DIV_0;
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
10003538:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
1000353a:	bf14      	ite	ne
1000353c:	201e      	movne	r0, #30
1000353e:	201d      	moveq	r0, #29
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
10003540:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
10003544:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
10003546:	bf18      	it	ne
10003548:	201f      	movne	r0, #31
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
1000354a:	f412 2f00 	tst.w	r2, #524288	; 0x80000
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
1000354e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
10003550:	bf18      	it	ne
10003552:	2021      	movne	r0, #33	; 0x21
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
10003554:	f412 2f80 	tst.w	r2, #262144	; 0x40000
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
10003558:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
1000355a:	bf18      	it	ne
1000355c:	2022      	movne	r0, #34	; 0x22
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
1000355e:	f412 3f00 	tst.w	r2, #131072	; 0x20000
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
10003562:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
10003564:	bf18      	it	ne
10003566:	2023      	movne	r0, #35	; 0x23
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
10003568:	f412 3f80 	tst.w	r2, #65536	; 0x10000
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
1000356c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
1000356e:	ea6f 4202 	mvn.w	r2, r2, lsl #16
10003572:	ea6f 4212 	mvn.w	r2, r2, lsr #16
10003576:	629a      	str	r2, [r3, #40]	; 0x28

	return reason;
}
10003578:	bf18      	it	ne
1000357a:	2024      	movne	r0, #36	; 0x24
1000357c:	4770      	bx	lr
1000357e:	bf00      	nop
10003580:	e000ed00 	.word	0xe000ed00

10003584 <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
10003584:	b510      	push	{r4, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
10003586:	4b19      	ldr	r3, [pc, #100]	; (100035ec <bus_fault.constprop.0+0x68>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
10003588:	4602      	mov	r2, r0
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
1000358a:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
1000358c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
1000358e:	f410 5f80 	tst.w	r0, #4096	; 0x1000
10003592:	bf14      	ite	ne
10003594:	2017      	movne	r0, #23
10003596:	2016      	moveq	r0, #22
		reason = K_ERR_ARM_BUS_UNSTACKING;
10003598:	f414 6f00 	tst.w	r4, #2048	; 0x800
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
1000359c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_UNSTACKING;
1000359e:	bf18      	it	ne
100035a0:	2018      	movne	r0, #24
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
100035a2:	05a4      	lsls	r4, r4, #22
100035a4:	d509      	bpl.n	100035ba <bus_fault.constprop.0+0x36>
		STORE_xFAR(bfar, SCB->BFAR);
100035a6:	6b98      	ldr	r0, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
100035a8:	6a98      	ldr	r0, [r3, #40]	; 0x28
100035aa:	0400      	lsls	r0, r0, #16
100035ac:	d504      	bpl.n	100035b8 <bus_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
100035ae:	b11a      	cbz	r2, 100035b8 <bus_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
100035b0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
100035b2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
100035b6:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
100035b8:	2019      	movs	r0, #25
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
100035ba:	4b0c      	ldr	r3, [pc, #48]	; (100035ec <bus_fault.constprop.0+0x68>)
100035bc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
100035be:	f412 6f80 	tst.w	r2, #1024	; 0x400
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
100035c2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
100035c4:	bf18      	it	ne
100035c6:	201a      	movne	r0, #26
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
100035c8:	05d2      	lsls	r2, r2, #23
100035ca:	d40c      	bmi.n	100035e6 <bus_fault.constprop.0+0x62>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
100035cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
100035ce:	f413 5f00 	tst.w	r3, #8192	; 0x2000
100035d2:	bf18      	it	ne
100035d4:	201c      	movne	r0, #28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
100035d6:	4a05      	ldr	r2, [pc, #20]	; (100035ec <bus_fault.constprop.0+0x68>)
100035d8:	6a93      	ldr	r3, [r2, #40]	; 0x28
100035da:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
100035de:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
100035e0:	2300      	movs	r3, #0
100035e2:	700b      	strb	r3, [r1, #0]
}
100035e4:	bd10      	pop	{r4, pc}
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
100035e6:	201b      	movs	r0, #27
100035e8:	e7f5      	b.n	100035d6 <bus_fault.constprop.0+0x52>
100035ea:	bf00      	nop
100035ec:	e000ed00 	.word	0xe000ed00

100035f0 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
100035f0:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
100035f2:	4b45      	ldr	r3, [pc, #276]	; (10003708 <z_arm_fault+0x118>)
100035f4:	685b      	ldr	r3, [r3, #4]
{
100035f6:	b08a      	sub	sp, #40	; 0x28
100035f8:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
100035fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
100035fe:	2600      	movs	r6, #0
10003600:	f386 8811 	msr	BASEPRI, r6
10003604:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
10003608:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
1000360c:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
10003610:	d111      	bne.n	10003636 <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
10003612:	f002 000c 	and.w	r0, r2, #12
10003616:	2808      	cmp	r0, #8
10003618:	d00d      	beq.n	10003636 <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
1000361a:	0710      	lsls	r0, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
1000361c:	bf4c      	ite	mi
1000361e:	460d      	movmi	r5, r1
			*nested_exc = true;
10003620:	2601      	movpl	r6, #1
	*recoverable = false;
10003622:	2200      	movs	r2, #0
	switch (fault) {
10003624:	3b03      	subs	r3, #3
	*recoverable = false;
10003626:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
1000362a:	2b03      	cmp	r3, #3
1000362c:	d805      	bhi.n	1000363a <z_arm_fault+0x4a>
1000362e:	e8df f003 	tbb	[pc, r3]
10003632:	5d1e      	.short	0x5d1e
10003634:	5a61      	.short	0x5a61
		return NULL;
10003636:	4635      	mov	r5, r6
10003638:	e7f3      	b.n	10003622 <z_arm_fault+0x32>
1000363a:	2400      	movs	r4, #0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
1000363c:	f89d 3007 	ldrb.w	r3, [sp, #7]
10003640:	b99b      	cbnz	r3, 1000366a <z_arm_fault+0x7a>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
10003642:	2220      	movs	r2, #32
10003644:	4629      	mov	r1, r5
10003646:	a802      	add	r0, sp, #8
10003648:	f004 fc6f 	bl	10007f2a <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
1000364c:	9b09      	ldr	r3, [sp, #36]	; 0x24
1000364e:	2e00      	cmp	r6, #0
10003650:	d054      	beq.n	100036fc <z_arm_fault+0x10c>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
10003652:	f3c3 0208 	ubfx	r2, r3, #0, #9
10003656:	b922      	cbnz	r2, 10003662 <z_arm_fault+0x72>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
10003658:	ea6f 2353 	mvn.w	r3, r3, lsr #9
1000365c:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
10003660:	9309      	str	r3, [sp, #36]	; 0x24

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
	}

	z_arm_fatal_error(reason, &esf_copy);
10003662:	a902      	add	r1, sp, #8
10003664:	4620      	mov	r0, r4
10003666:	f004 fc3b 	bl	10007ee0 <z_arm_fatal_error>
}
1000366a:	b00a      	add	sp, #40	; 0x28
1000366c:	bd70      	pop	{r4, r5, r6, pc}
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
1000366e:	4b26      	ldr	r3, [pc, #152]	; (10003708 <z_arm_fault+0x118>)
10003670:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003672:	0791      	lsls	r1, r2, #30
10003674:	d4e1      	bmi.n	1000363a <z_arm_fault+0x4a>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
10003676:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003678:	2a00      	cmp	r2, #0
1000367a:	dbde      	blt.n	1000363a <z_arm_fault+0x4a>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
1000367c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000367e:	0052      	lsls	r2, r2, #1
10003680:	d5db      	bpl.n	1000363a <z_arm_fault+0x4a>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
10003682:	695a      	ldr	r2, [r3, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
10003684:	69a9      	ldr	r1, [r5, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
10003686:	f442 7280 	orr.w	r2, r2, #256	; 0x100
1000368a:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
1000368c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
10003690:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
10003694:	695a      	ldr	r2, [r3, #20]
	uint16_t fault_insn = *(ret_addr - 1);
10003696:	f831 1c02 	ldrh.w	r1, [r1, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
1000369a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
1000369e:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
100036a0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
100036a4:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
100036a8:	f64d 7202 	movw	r2, #57090	; 0xdf02
100036ac:	4291      	cmp	r1, r2
100036ae:	d00a      	beq.n	100036c6 <z_arm_fault+0xd6>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
100036b0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
100036b2:	b2d2      	uxtb	r2, r2
100036b4:	b14a      	cbz	r2, 100036ca <z_arm_fault+0xda>
			reason = mem_manage_fault(esf, 1, recoverable);
100036b6:	f10d 0207 	add.w	r2, sp, #7
100036ba:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
100036bc:	4628      	mov	r0, r5
100036be:	f7ff fee7 	bl	10003490 <mem_manage_fault>
		reason = usage_fault(esf);
100036c2:	4604      	mov	r4, r0
		break;
100036c4:	e7ba      	b.n	1000363c <z_arm_fault+0x4c>
			reason = esf->basic.r0;
100036c6:	682c      	ldr	r4, [r5, #0]
100036c8:	e7b8      	b.n	1000363c <z_arm_fault+0x4c>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
100036ca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
100036cc:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
100036d0:	d005      	beq.n	100036de <z_arm_fault+0xee>
			reason = bus_fault(esf, 1, recoverable);
100036d2:	f10d 0107 	add.w	r1, sp, #7
100036d6:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
100036d8:	f7ff ff54 	bl	10003584 <bus_fault.constprop.0>
100036dc:	e7f1      	b.n	100036c2 <z_arm_fault+0xd2>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
100036de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
100036e0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
100036e4:	d3a9      	bcc.n	1000363a <z_arm_fault+0x4a>
		reason = usage_fault(esf);
100036e6:	f7ff ff23 	bl	10003530 <usage_fault.constprop.0>
100036ea:	e7ea      	b.n	100036c2 <z_arm_fault+0xd2>
		reason = mem_manage_fault(esf, 0, recoverable);
100036ec:	f10d 0207 	add.w	r2, sp, #7
100036f0:	2100      	movs	r1, #0
100036f2:	e7e3      	b.n	100036bc <z_arm_fault+0xcc>
		reason = bus_fault(esf, 0, recoverable);
100036f4:	f10d 0107 	add.w	r1, sp, #7
100036f8:	2000      	movs	r0, #0
100036fa:	e7ed      	b.n	100036d8 <z_arm_fault+0xe8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
100036fc:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
10003700:	f023 0301 	bic.w	r3, r3, #1
10003704:	e7ac      	b.n	10003660 <z_arm_fault+0x70>
10003706:	bf00      	nop
10003708:	e000ed00 	.word	0xe000ed00

1000370c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
1000370c:	4a02      	ldr	r2, [pc, #8]	; (10003718 <z_arm_fault_init+0xc>)
1000370e:	6953      	ldr	r3, [r2, #20]
10003710:	f043 0310 	orr.w	r3, r3, #16
10003714:	6153      	str	r3, [r2, #20]
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
10003716:	4770      	bx	lr
10003718:	e000ed00 	.word	0xe000ed00

1000371c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
1000371c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
10003720:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
10003724:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
10003726:	4672      	mov	r2, lr
	bl z_arm_fault
10003728:	f7ff ff62 	bl	100035f0 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
1000372c:	bd01      	pop	{r0, pc}
1000372e:	bf00      	nop

10003730 <z_arm_interrupt_init>:
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
10003730:	4804      	ldr	r0, [pc, #16]	; (10003744 <z_arm_interrupt_init+0x14>)
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
10003732:	2300      	movs	r3, #0
10003734:	2120      	movs	r1, #32
10003736:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
10003738:	3301      	adds	r3, #1
1000373a:	2ba8      	cmp	r3, #168	; 0xa8
1000373c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
10003740:	d1f9      	bne.n	10003736 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
10003742:	4770      	bx	lr
10003744:	e000e100 	.word	0xe000e100

10003748 <__start>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
10003748:	2020      	movs	r0, #32
    msr BASEPRI, r0
1000374a:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
1000374e:	4808      	ldr	r0, [pc, #32]	; (10003770 <__start+0x28>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
10003750:	f44f 6104 	mov.w	r1, #2112	; 0x840
    adds r0, r0, r1
10003754:	1840      	adds	r0, r0, r1
    msr PSP, r0
10003756:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
1000375a:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
1000375e:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
10003760:	4308      	orrs	r0, r1
    msr CONTROL, r0
10003762:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
10003766:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
1000376a:	f7ff fdaf 	bl	100032cc <z_arm_prep_c>
1000376e:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
10003770:	08003840 	.word	0x08003840

10003774 <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
10003774:	4b08      	ldr	r3, [pc, #32]	; (10003798 <z_impl_k_thread_abort+0x24>)
10003776:	689b      	ldr	r3, [r3, #8]
10003778:	4283      	cmp	r3, r0
1000377a:	d10b      	bne.n	10003794 <z_impl_k_thread_abort+0x20>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
1000377c:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
10003780:	b143      	cbz	r3, 10003794 <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
10003782:	4b06      	ldr	r3, [pc, #24]	; (1000379c <z_impl_k_thread_abort+0x28>)
10003784:	685a      	ldr	r2, [r3, #4]
10003786:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
1000378a:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
1000378c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
1000378e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
10003792:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
10003794:	f004 b93e 	b.w	10007a14 <z_thread_abort>
10003798:	080037a0 	.word	0x080037a0
1000379c:	e000ed00 	.word	0xe000ed00

100037a0 <z_arm_configure_static_mpu_regions>:
	 * into account the unused SRAM area, as well.
	 */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_static_mpu_regions(static_regions,
100037a0:	4b02      	ldr	r3, [pc, #8]	; (100037ac <z_arm_configure_static_mpu_regions+0xc>)
100037a2:	4a03      	ldr	r2, [pc, #12]	; (100037b0 <z_arm_configure_static_mpu_regions+0x10>)
100037a4:	4803      	ldr	r0, [pc, #12]	; (100037b4 <z_arm_configure_static_mpu_regions+0x14>)
100037a6:	2101      	movs	r1, #1
100037a8:	f000 b870 	b.w	1000388c <arm_core_mpu_configure_static_mpu_regions>
100037ac:	08100000 	.word	0x08100000
100037b0:	08000000 	.word	0x08000000
100037b4:	10009134 	.word	0x10009134

100037b8 <z_arm_configure_dynamic_mpu_regions>:
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
100037b8:	6e42      	ldr	r2, [r0, #100]	; 0x64
	}

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
100037ba:	4b05      	ldr	r3, [pc, #20]	; (100037d0 <z_arm_configure_dynamic_mpu_regions+0x18>)
		guard_start = thread->stack_info.start - guard_size;
100037bc:	3a40      	subs	r2, #64	; 0x40
	dynamic_regions[region_num].start = guard_start;
100037be:	601a      	str	r2, [r3, #0]
	dynamic_regions[region_num].size = guard_size;
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
100037c0:	4a04      	ldr	r2, [pc, #16]	; (100037d4 <z_arm_configure_dynamic_mpu_regions+0x1c>)
100037c2:	2140      	movs	r1, #64	; 0x40
100037c4:	e9c3 1201 	strd	r1, r2, [r3, #4]

	/* Configure the dynamic MPU regions */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
100037c8:	4618      	mov	r0, r3
100037ca:	2101      	movs	r1, #1
100037cc:	f000 b868 	b.w	100038a0 <arm_core_mpu_configure_dynamic_mpu_regions>
100037d0:	08003014 	.word	0x08003014
100037d4:	150b0000 	.word	0x150b0000

100037d8 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
100037d8:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
100037da:	4e20      	ldr	r6, [pc, #128]	; (1000385c <mpu_configure_regions+0x84>)
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
100037dc:	2500      	movs	r5, #0
100037de:	428d      	cmp	r5, r1
100037e0:	da39      	bge.n	10003856 <mpu_configure_regions+0x7e>
		if (regions[i].size == 0U) {
100037e2:	6844      	ldr	r4, [r0, #4]
100037e4:	b374      	cbz	r4, 10003844 <mpu_configure_regions+0x6c>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
100037e6:	b153      	cbz	r3, 100037fe <mpu_configure_regions+0x26>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
100037e8:	f104 3cff 	add.w	ip, r4, #4294967295
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
100037ec:	ea14 0f0c 	tst.w	r4, ip
100037f0:	d12f      	bne.n	10003852 <mpu_configure_regions+0x7a>
		&&
100037f2:	2c1f      	cmp	r4, #31
100037f4:	d92d      	bls.n	10003852 <mpu_configure_regions+0x7a>
		((part->start & (part->size - 1U)) == 0U);
100037f6:	6807      	ldr	r7, [r0, #0]
		&&
100037f8:	ea1c 0f07 	tst.w	ip, r7
100037fc:	d129      	bne.n	10003852 <mpu_configure_regions+0x7a>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
100037fe:	2c20      	cmp	r4, #32
	region_conf.base = new_region->start;
10003800:	6807      	ldr	r7, [r0, #0]
#if defined(CONFIG_CPU_AARCH32_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
10003802:	f8d0 c008 	ldr.w	ip, [r0, #8]
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, &regions[i]);
10003806:	fa5f fe82 	uxtb.w	lr, r2
	if (size <= 32U) {
1000380a:	d91e      	bls.n	1000384a <mpu_configure_regions+0x72>
	if (size > (1UL << 31)) {
1000380c:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
10003810:	d81d      	bhi.n	1000384e <mpu_configure_regions+0x76>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
10003812:	3c01      	subs	r4, #1
10003814:	fab4 f484 	clz	r4, r4
10003818:	f1c4 041f 	rsb	r4, r4, #31
1000381c:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
1000381e:	f1be 0f07 	cmp.w	lr, #7
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
10003822:	ea4c 0c04 	orr.w	ip, ip, r4
10003826:	d814      	bhi.n	10003852 <mpu_configure_regions+0x7a>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
10003828:	f027 041f 	bic.w	r4, r7, #31
				| MPU_RBAR_VALID_Msk | index;
1000382c:	4314      	orrs	r4, r2
1000382e:	f044 0410 	orr.w	r4, r4, #16
10003832:	f8c6 2098 	str.w	r2, [r6, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
10003836:	f8c6 409c 	str.w	r4, [r6, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
1000383a:	f04c 0401 	orr.w	r4, ip, #1
1000383e:	f8c6 40a0 	str.w	r4, [r6, #160]	; 0xa0
		if (reg_index == -EINVAL) {
			return reg_index;
		}

		/* Increment number of programmed MPU indices. */
		reg_index++;
10003842:	3201      	adds	r2, #1
	for (i = 0; i < regions_num; i++) {
10003844:	3501      	adds	r5, #1
10003846:	300c      	adds	r0, #12
10003848:	e7c9      	b.n	100037de <mpu_configure_regions+0x6>
		return REGION_32B;
1000384a:	2408      	movs	r4, #8
1000384c:	e7e7      	b.n	1000381e <mpu_configure_regions+0x46>
		return REGION_4G;
1000384e:	243e      	movs	r4, #62	; 0x3e
10003850:	e7e5      	b.n	1000381e <mpu_configure_regions+0x46>
			return -EINVAL;
10003852:	f06f 0215 	mvn.w	r2, #21
	}

	return reg_index;
}
10003856:	4610      	mov	r0, r2
10003858:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000385a:	bf00      	nop
1000385c:	e000ed00 	.word	0xe000ed00

10003860 <arm_core_mpu_enable>:
	 * background region for privileged software access if desired.
	 */
#if defined(CONFIG_MPU_DISABLE_BACKGROUND_MAP)
	MPU->CTRL = MPU_CTRL_ENABLE_Msk;
#else
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
10003860:	4b04      	ldr	r3, [pc, #16]	; (10003874 <arm_core_mpu_enable+0x14>)
10003862:	2205      	movs	r2, #5
10003864:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
10003868:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
1000386c:	f3bf 8f6f 	isb	sy
#endif

	/* Make sure that all the registers are set before proceeding */
	barrier_dsync_fence_full();
	barrier_isync_fence_full();
}
10003870:	4770      	bx	lr
10003872:	bf00      	nop
10003874:	e000ed00 	.word	0xe000ed00

10003878 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
10003878:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	barrier_dmem_fence_full();

	/* Disable MPU */
	MPU->CTRL = 0;
1000387c:	4b02      	ldr	r3, [pc, #8]	; (10003888 <arm_core_mpu_disable+0x10>)
1000387e:	2200      	movs	r2, #0
10003880:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
10003884:	4770      	bx	lr
10003886:	bf00      	nop
10003888:	e000ed00 	.word	0xe000ed00

1000388c <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	*static_regions, const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
1000388c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
1000388e:	4c03      	ldr	r4, [pc, #12]	; (1000389c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
10003890:	2301      	movs	r3, #1
10003892:	7822      	ldrb	r2, [r4, #0]
10003894:	f7ff ffa0 	bl	100037d8 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
10003898:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
1000389a:	bd10      	pop	{r4, pc}
1000389c:	080037dc 	.word	0x080037dc

100038a0 <arm_core_mpu_configure_dynamic_mpu_regions>:
/**
 * @brief configure dynamic MPU regions.
 */
void arm_core_mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	*dynamic_regions, uint8_t regions_num)
{
100038a0:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
100038a2:	4a09      	ldr	r2, [pc, #36]	; (100038c8 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
100038a4:	2300      	movs	r3, #0
100038a6:	7812      	ldrb	r2, [r2, #0]
100038a8:	f7ff ff96 	bl	100037d8 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
100038ac:	f110 0f16 	cmn.w	r0, #22
100038b0:	d002      	beq.n	100038b8 <arm_core_mpu_configure_dynamic_mpu_regions+0x18>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
100038b2:	4a06      	ldr	r2, [pc, #24]	; (100038cc <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>)

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
100038b4:	2807      	cmp	r0, #7
100038b6:	dd00      	ble.n	100038ba <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
		== -EINVAL) {

		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
			regions_num);
	}
}
100038b8:	bd08      	pop	{r3, pc}
100038ba:	f8c2 0098 	str.w	r0, [r2, #152]	; 0x98
  MPU->RASR = 0U;
100038be:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
100038c2:	3001      	adds	r0, #1
100038c4:	e7f6      	b.n	100038b4 <arm_core_mpu_configure_dynamic_mpu_regions+0x14>
100038c6:	bf00      	nop
100038c8:	080037dc 	.word	0x080037dc
100038cc:	e000ed00 	.word	0xe000ed00

100038d0 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
100038d0:	4914      	ldr	r1, [pc, #80]	; (10003924 <z_arm_mpu_init+0x54>)
100038d2:	6808      	ldr	r0, [r1, #0]
100038d4:	2808      	cmp	r0, #8
{
100038d6:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
100038d8:	d821      	bhi.n	1000391e <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
100038da:	f7ff ffcd 	bl	10003878 <arm_core_mpu_disable>
100038de:	4c12      	ldr	r4, [pc, #72]	; (10003928 <z_arm_mpu_init+0x58>)
100038e0:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
100038e2:	2200      	movs	r2, #0
100038e4:	4290      	cmp	r0, r2
100038e6:	f101 010c 	add.w	r1, r1, #12
100038ea:	d105      	bne.n	100038f8 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
100038ec:	4b0f      	ldr	r3, [pc, #60]	; (1000392c <z_arm_mpu_init+0x5c>)
100038ee:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
100038f0:	f7ff ffb6 	bl	10003860 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
100038f4:	2000      	movs	r0, #0
}
100038f6:	bd10      	pop	{r4, pc}
100038f8:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
100038fc:	f851 3c0c 	ldr.w	r3, [r1, #-12]
10003900:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
10003904:	4313      	orrs	r3, r2
10003906:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
1000390a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
1000390e:	f851 3c04 	ldr.w	r3, [r1, #-4]
10003912:	f043 0301 	orr.w	r3, r3, #1
10003916:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
1000391a:	3201      	adds	r2, #1
1000391c:	e7e2      	b.n	100038e4 <z_arm_mpu_init+0x14>
		return -1;
1000391e:	f04f 30ff 	mov.w	r0, #4294967295
10003922:	e7e8      	b.n	100038f6 <z_arm_mpu_init+0x26>
10003924:	10009140 	.word	0x10009140
10003928:	e000ed00 	.word	0xe000ed00
1000392c:	080037dc 	.word	0x080037dc

10003930 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
10003930:	4b01      	ldr	r3, [pc, #4]	; (10003938 <__stdout_hook_install+0x8>)
10003932:	6018      	str	r0, [r3, #0]
}
10003934:	4770      	bx	lr
10003936:	bf00      	nop
10003938:	0800280c 	.word	0x0800280c

1000393c <_get_hal_obj_from_ord>:

	return rslt;
}

static cyhal_clock_t *_get_hal_obj_from_ord(uint32_t dt_ord)
{
1000393c:	b510      	push	{r4, lr}
1000393e:	4908      	ldr	r1, [pc, #32]	; (10003960 <_get_hal_obj_from_ord+0x24>)
	cyhal_clock_t *ret_obj = NULL;

	for (uint32_t i = 0u; i < INFINEON_CAT1_ENABLED_CLOCK_COUNT; i++) {
10003940:	2200      	movs	r2, #0
10003942:	460b      	mov	r3, r1
		if (clock_info_table[i].dt_ord == dt_ord) {
10003944:	688c      	ldr	r4, [r1, #8]
10003946:	4284      	cmp	r4, r0
10003948:	d103      	bne.n	10003952 <_get_hal_obj_from_ord+0x16>
			ret_obj = &clock_info_table[i].obj;
1000394a:	210c      	movs	r1, #12
1000394c:	fb01 3002 	mla	r0, r1, r2, r3
			return ret_obj;
		}
	}
	return ret_obj;
}
10003950:	bd10      	pop	{r4, pc}
	for (uint32_t i = 0u; i < INFINEON_CAT1_ENABLED_CLOCK_COUNT; i++) {
10003952:	3201      	adds	r2, #1
10003954:	2a08      	cmp	r2, #8
10003956:	f101 010c 	add.w	r1, r1, #12
1000395a:	d1f3      	bne.n	10003944 <_get_hal_obj_from_ord+0x8>
	return ret_obj;
1000395c:	2000      	movs	r0, #0
1000395e:	e7f7      	b.n	10003950 <_get_hal_obj_from_ord+0x14>
10003960:	08002810 	.word	0x08002810

10003964 <clock_control_infineon_cat1_init>:

static int clock_control_infineon_cat1_init(const struct device *dev)
{
10003964:	b510      	push	{r4, lr}
	uint32 clock_div;

	/* Configure IMO */
#if DT_NODE_HAS_STATUS(DT_NODELABEL(clk_imo), okay)
	clock_obj = &clock_info_table[INFINEON_CAT1_CLOCK_IMO].obj;
	if (cyhal_clock_get(clock_obj, &CYHAL_CLOCK_RSC_IMO)) {
10003966:	493f      	ldr	r1, [pc, #252]	; (10003a64 <clock_control_infineon_cat1_init+0x100>)
10003968:	483f      	ldr	r0, [pc, #252]	; (10003a68 <clock_control_infineon_cat1_init+0x104>)
1000396a:	f003 f839 	bl	100069e0 <cyhal_clock_get>
1000396e:	b110      	cbz	r0, 10003976 <clock_control_infineon_cat1_init+0x12>
		return -EIO;
10003970:	f06f 0004 	mvn.w	r0, #4
		return -EIO;
	}
#endif

	return (int) rslt;
}
10003974:	bd10      	pop	{r4, pc}
	clock_source_obj = _get_hal_obj_from_ord(GET_CLK_SOURCE_ORD(path_mux0));
10003976:	2008      	movs	r0, #8
10003978:	f7ff ffe0 	bl	1000393c <_get_hal_obj_from_ord>
	rslt = cyhal_clock_reserve(clock_obj, reserve_obj);
1000397c:	493b      	ldr	r1, [pc, #236]	; (10003a6c <clock_control_infineon_cat1_init+0x108>)
	clock_source_obj = _get_hal_obj_from_ord(GET_CLK_SOURCE_ORD(path_mux0));
1000397e:	4604      	mov	r4, r0
	rslt = cyhal_clock_reserve(clock_obj, reserve_obj);
10003980:	483b      	ldr	r0, [pc, #236]	; (10003a70 <clock_control_infineon_cat1_init+0x10c>)
10003982:	f005 f979 	bl	10008c78 <cyhal_clock_reserve>
	if (rslt == CY_RSLT_SUCCESS) {
10003986:	2800      	cmp	r0, #0
10003988:	d1f2      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_source(clock_obj, clock_source_obj);
1000398a:	4839      	ldr	r0, [pc, #228]	; (10003a70 <clock_control_infineon_cat1_init+0x10c>)
1000398c:	4621      	mov	r1, r4
1000398e:	f003 f857 	bl	10006a40 <cyhal_clock_set_source>
	if (_configure_path_mux(clock_obj, clock_source_obj, &CYHAL_CLOCK_PATHMUX[0])) {
10003992:	2800      	cmp	r0, #0
10003994:	d1ec      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
	clock_source_obj = _get_hal_obj_from_ord(GET_CLK_SOURCE_ORD(path_mux1));
10003996:	2008      	movs	r0, #8
10003998:	f7ff ffd0 	bl	1000393c <_get_hal_obj_from_ord>
	rslt = cyhal_clock_reserve(clock_obj, reserve_obj);
1000399c:	4935      	ldr	r1, [pc, #212]	; (10003a74 <clock_control_infineon_cat1_init+0x110>)
	clock_source_obj = _get_hal_obj_from_ord(GET_CLK_SOURCE_ORD(path_mux1));
1000399e:	4604      	mov	r4, r0
	rslt = cyhal_clock_reserve(clock_obj, reserve_obj);
100039a0:	4835      	ldr	r0, [pc, #212]	; (10003a78 <clock_control_infineon_cat1_init+0x114>)
100039a2:	f005 f969 	bl	10008c78 <cyhal_clock_reserve>
	if (rslt == CY_RSLT_SUCCESS) {
100039a6:	2800      	cmp	r0, #0
100039a8:	d1e2      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_source(clock_obj, clock_source_obj);
100039aa:	4833      	ldr	r0, [pc, #204]	; (10003a78 <clock_control_infineon_cat1_init+0x114>)
100039ac:	4621      	mov	r1, r4
100039ae:	f003 f847 	bl	10006a40 <cyhal_clock_set_source>
	if (_configure_path_mux(clock_obj, clock_source_obj, &CYHAL_CLOCK_PATHMUX[1])) {
100039b2:	2800      	cmp	r0, #0
100039b4:	d1dc      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
	rslt = cyhal_clock_reserve(clock_obj, reserve_obj);
100039b6:	4931      	ldr	r1, [pc, #196]	; (10003a7c <clock_control_infineon_cat1_init+0x118>)
100039b8:	4831      	ldr	r0, [pc, #196]	; (10003a80 <clock_control_infineon_cat1_init+0x11c>)
100039ba:	f005 f95d 	bl	10008c78 <cyhal_clock_reserve>
	if (rslt == CY_RSLT_SUCCESS) {
100039be:	4602      	mov	r2, r0
100039c0:	2800      	cmp	r0, #0
100039c2:	d1d5      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_frequency(clock_obj, frequency, NULL);
100039c4:	492f      	ldr	r1, [pc, #188]	; (10003a84 <clock_control_infineon_cat1_init+0x120>)
100039c6:	482e      	ldr	r0, [pc, #184]	; (10003a80 <clock_control_infineon_cat1_init+0x11c>)
100039c8:	f003 f828 	bl	10006a1c <cyhal_clock_set_frequency>
	if (rslt == CY_RSLT_SUCCESS) {
100039cc:	2800      	cmp	r0, #0
100039ce:	d1cf      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_enabled(clock_obj, true, true);
100039d0:	2201      	movs	r2, #1
100039d2:	482b      	ldr	r0, [pc, #172]	; (10003a80 <clock_control_infineon_cat1_init+0x11c>)
100039d4:	4611      	mov	r1, r2
100039d6:	f005 f96e 	bl	10008cb6 <cyhal_clock_set_enabled>
	if (rslt) {
100039da:	2800      	cmp	r0, #0
100039dc:	d1c8      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
	clock_source_obj = _get_hal_obj_from_ord(GET_CLK_SOURCE_ORD(clk_hf0));
100039de:	2006      	movs	r0, #6
100039e0:	f7ff ffac 	bl	1000393c <_get_hal_obj_from_ord>
	rslt = cyhal_clock_reserve(clock_obj, reserve_obj);
100039e4:	4928      	ldr	r1, [pc, #160]	; (10003a88 <clock_control_infineon_cat1_init+0x124>)
	clock_source_obj = _get_hal_obj_from_ord(GET_CLK_SOURCE_ORD(clk_hf0));
100039e6:	4604      	mov	r4, r0
	rslt = cyhal_clock_reserve(clock_obj, reserve_obj);
100039e8:	4828      	ldr	r0, [pc, #160]	; (10003a8c <clock_control_infineon_cat1_init+0x128>)
100039ea:	f005 f945 	bl	10008c78 <cyhal_clock_reserve>
	if (rslt == CY_RSLT_SUCCESS) {
100039ee:	2800      	cmp	r0, #0
100039f0:	d1be      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_source(clock_obj, clock_source_obj);
100039f2:	4826      	ldr	r0, [pc, #152]	; (10003a8c <clock_control_infineon_cat1_init+0x128>)
100039f4:	4621      	mov	r1, r4
100039f6:	f003 f823 	bl	10006a40 <cyhal_clock_set_source>
	if (rslt == CY_RSLT_SUCCESS) {
100039fa:	2800      	cmp	r0, #0
100039fc:	d1b8      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_divider(clock_obj, clock_div);
100039fe:	4823      	ldr	r0, [pc, #140]	; (10003a8c <clock_control_infineon_cat1_init+0x128>)
10003a00:	2101      	movs	r1, #1
10003a02:	f005 f966 	bl	10008cd2 <cyhal_clock_set_divider>
	if (rslt == CY_RSLT_SUCCESS) {
10003a06:	2800      	cmp	r0, #0
10003a08:	d1b2      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_enabled(clock_obj, true, true);
10003a0a:	2201      	movs	r2, #1
10003a0c:	481f      	ldr	r0, [pc, #124]	; (10003a8c <clock_control_infineon_cat1_init+0x128>)
10003a0e:	4611      	mov	r1, r2
10003a10:	f005 f951 	bl	10008cb6 <cyhal_clock_set_enabled>
	if (_configure_clk_hf(clock_obj, clock_source_obj, &CYHAL_CLOCK_HF[0], clock_div)) {
10003a14:	2800      	cmp	r0, #0
10003a16:	d1ab      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
	rslt = cyhal_clock_reserve(clock_obj, &CYHAL_CLOCK_FAST);
10003a18:	491d      	ldr	r1, [pc, #116]	; (10003a90 <clock_control_infineon_cat1_init+0x12c>)
10003a1a:	481e      	ldr	r0, [pc, #120]	; (10003a94 <clock_control_infineon_cat1_init+0x130>)
10003a1c:	f005 f92c 	bl	10008c78 <cyhal_clock_reserve>
	if (rslt == CY_RSLT_SUCCESS) {
10003a20:	2800      	cmp	r0, #0
10003a22:	d1a5      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_divider(clock_obj, clock_div);
10003a24:	481b      	ldr	r0, [pc, #108]	; (10003a94 <clock_control_infineon_cat1_init+0x130>)
10003a26:	2101      	movs	r1, #1
10003a28:	f005 f953 	bl	10008cd2 <cyhal_clock_set_divider>
	if (rslt) {
10003a2c:	2800      	cmp	r0, #0
10003a2e:	d19f      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
	rslt = cyhal_clock_reserve(clock_obj, &CYHAL_CLOCK_PERI);
10003a30:	4919      	ldr	r1, [pc, #100]	; (10003a98 <clock_control_infineon_cat1_init+0x134>)
10003a32:	481a      	ldr	r0, [pc, #104]	; (10003a9c <clock_control_infineon_cat1_init+0x138>)
10003a34:	f005 f920 	bl	10008c78 <cyhal_clock_reserve>
	if (rslt == CY_RSLT_SUCCESS) {
10003a38:	2800      	cmp	r0, #0
10003a3a:	d199      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_divider(clock_obj, clock_div);
10003a3c:	4817      	ldr	r0, [pc, #92]	; (10003a9c <clock_control_infineon_cat1_init+0x138>)
10003a3e:	2101      	movs	r1, #1
10003a40:	f005 f947 	bl	10008cd2 <cyhal_clock_set_divider>
	if (rslt) {
10003a44:	2800      	cmp	r0, #0
10003a46:	d193      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
	rslt = cyhal_clock_reserve(clock_obj, &CYHAL_CLOCK_SLOW);
10003a48:	4915      	ldr	r1, [pc, #84]	; (10003aa0 <clock_control_infineon_cat1_init+0x13c>)
10003a4a:	4816      	ldr	r0, [pc, #88]	; (10003aa4 <clock_control_infineon_cat1_init+0x140>)
10003a4c:	f005 f914 	bl	10008c78 <cyhal_clock_reserve>
	if (rslt == CY_RSLT_SUCCESS) {
10003a50:	2800      	cmp	r0, #0
10003a52:	d18d      	bne.n	10003970 <clock_control_infineon_cat1_init+0xc>
		rslt = cyhal_clock_set_divider(clock_obj, clock_div);
10003a54:	4813      	ldr	r0, [pc, #76]	; (10003aa4 <clock_control_infineon_cat1_init+0x140>)
10003a56:	2102      	movs	r1, #2
10003a58:	f005 f93b 	bl	10008cd2 <cyhal_clock_set_divider>
	if (rslt) {
10003a5c:	2800      	cmp	r0, #0
10003a5e:	d089      	beq.n	10003974 <clock_control_infineon_cat1_init+0x10>
10003a60:	e786      	b.n	10003970 <clock_control_infineon_cat1_init+0xc>
10003a62:	bf00      	nop
10003a64:	1000a14b 	.word	0x1000a14b
10003a68:	08002810 	.word	0x08002810
10003a6c:	100094fc 	.word	0x100094fc
10003a70:	0800281c 	.word	0x0800281c
10003a74:	10009504 	.word	0x10009504
10003a78:	08002828 	.word	0x08002828
10003a7c:	100094c4 	.word	0x100094c4
10003a80:	08002864 	.word	0x08002864
10003a84:	05f5e100 	.word	0x05f5e100
10003a88:	100094cc 	.word	0x100094cc
10003a8c:	08002834 	.word	0x08002834
10003a90:	100094bc 	.word	0x100094bc
10003a94:	08002840 	.word	0x08002840
10003a98:	100094b4 	.word	0x100094b4
10003a9c:	08002858 	.word	0x08002858
10003aa0:	100094ac 	.word	0x100094ac
10003aa4:	0800284c 	.word	0x0800284c

10003aa8 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(void)
{
10003aa8:	b508      	push	{r3, lr}
10003aaa:	4807      	ldr	r0, [pc, #28]	; (10003ac8 <uart_console_init+0x20>)
10003aac:	f005 f9c4 	bl	10008e38 <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
10003ab0:	b138      	cbz	r0, 10003ac2 <uart_console_init+0x1a>
	__stdout_hook_install(console_out);
10003ab2:	4806      	ldr	r0, [pc, #24]	; (10003acc <uart_console_init+0x24>)
10003ab4:	f7ff ff3c 	bl	10003930 <__stdout_hook_install>
	__printk_hook_install(console_out);
10003ab8:	4804      	ldr	r0, [pc, #16]	; (10003acc <uart_console_init+0x24>)
10003aba:	f7ff f80b 	bl	10002ad4 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
10003abe:	2000      	movs	r0, #0
}
10003ac0:	bd08      	pop	{r3, pc}
		return -ENODEV;
10003ac2:	f06f 0012 	mvn.w	r0, #18
10003ac6:	e7fb      	b.n	10003ac0 <uart_console_init+0x18>
10003ac8:	10009030 	.word	0x10009030
10003acc:	10003ad1 	.word	0x10003ad1

10003ad0 <console_out>:
	if ('\n' == c) {
10003ad0:	280a      	cmp	r0, #10
{
10003ad2:	b538      	push	{r3, r4, r5, lr}
10003ad4:	4d07      	ldr	r5, [pc, #28]	; (10003af4 <console_out+0x24>)
10003ad6:	4604      	mov	r4, r0
	if ('\n' == c) {
10003ad8:	d104      	bne.n	10003ae4 <console_out+0x14>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
10003ada:	68ab      	ldr	r3, [r5, #8]
10003adc:	210d      	movs	r1, #13
10003ade:	685b      	ldr	r3, [r3, #4]
10003ae0:	4628      	mov	r0, r5
10003ae2:	4798      	blx	r3
10003ae4:	68ab      	ldr	r3, [r5, #8]
10003ae6:	4803      	ldr	r0, [pc, #12]	; (10003af4 <console_out+0x24>)
10003ae8:	685b      	ldr	r3, [r3, #4]
10003aea:	b2e1      	uxtb	r1, r4
10003aec:	4798      	blx	r3
}
10003aee:	4620      	mov	r0, r4
10003af0:	bd38      	pop	{r3, r4, r5, pc}
10003af2:	bf00      	nop
10003af4:	10009030 	.word	0x10009030

10003af8 <gpio_cat1_pin_interrupt_configure>:
	const struct gpio_cat1_config *const cfg = dev->config;
	cyhal_gpio_callback_data_t *cb_data_ptr = cfg->cb_data_ptr;
	cyhal_gpio_event_t event = CYHAL_GPIO_IRQ_NONE;

	/* Level interrupts (GPIO_INT_MODE_LEVEL) is not supported */
	if (mode == GPIO_INT_MODE_LEVEL) {
10003af8:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
{
10003afc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10003afe:	4615      	mov	r5, r2
	if (mode == GPIO_INT_MODE_LEVEL) {
10003b00:	d03e      	beq.n	10003b80 <gpio_cat1_pin_interrupt_configure+0x88>
		return -ENOTSUP;
	}

	switch (trig) {
10003b02:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
10003b06:	d018      	beq.n	10003b3a <gpio_cat1_pin_interrupt_configure+0x42>
10003b08:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
10003b0c:	d138      	bne.n	10003b80 <gpio_cat1_pin_interrupt_configure+0x88>
10003b0e:	2601      	movs	r6, #1

	default:
		return -ENOTSUP;
	}

	cyhal_gpio_t gpio_pin = CYHAL_GET_GPIO(GET_PORT_NUM(dev), pin);
10003b10:	4b1d      	ldr	r3, [pc, #116]	; (10003b88 <gpio_cat1_pin_interrupt_configure+0x90>)
	const struct gpio_cat1_config *const cfg = dev->config;
10003b12:	6847      	ldr	r7, [r0, #4]
	cyhal_gpio_t gpio_pin = CYHAL_GET_GPIO(GET_PORT_NUM(dev), pin);
10003b14:	6818      	ldr	r0, [r3, #0]
10003b16:	68bb      	ldr	r3, [r7, #8]
10003b18:	6980      	ldr	r0, [r0, #24]
	cyhal_gpio_callback_data_t *cb_data_ptr = cfg->cb_data_ptr;
10003b1a:	687a      	ldr	r2, [r7, #4]

	/* Find index of free callback data structure */
	uint32_t index;

	for (index = 0u; index < cfg->ngpios; index++) {
10003b1c:	f897 c00c 	ldrb.w	ip, [r7, #12]
	cyhal_gpio_t gpio_pin = CYHAL_GET_GPIO(GET_PORT_NUM(dev), pin);
10003b20:	1a1b      	subs	r3, r3, r0
10003b22:	09db      	lsrs	r3, r3, #7
10003b24:	eb01 04c3 	add.w	r4, r1, r3, lsl #3
10003b28:	b2e4      	uxtb	r4, r4
	for (index = 0u; index < cfg->ngpios; index++) {
10003b2a:	4613      	mov	r3, r2
10003b2c:	2100      	movs	r1, #0
10003b2e:	458c      	cmp	ip, r1
10003b30:	d805      	bhi.n	10003b3e <gpio_cat1_pin_interrupt_configure+0x46>
		if ((cb_data_ptr[index].callback == NULL) || (cb_data_ptr[index].pin == gpio_pin)) {
			break;
		}
	}

	if (index != cfg->ngpios) {
10003b32:	d106      	bne.n	10003b42 <gpio_cat1_pin_interrupt_configure+0x4a>
		/* Enable/disable the specified GPIO event */
		cyhal_gpio_enable_event(gpio_pin, event, cfg->intr_priority,
					(mode == GPIO_INT_MODE_DISABLED) ? false : true);
		return 0;
	} else {
		return -EINVAL;
10003b34:	f06f 0015 	mvn.w	r0, #21
	}
}
10003b38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		event = CYHAL_GPIO_IRQ_FALL;
10003b3a:	2602      	movs	r6, #2
10003b3c:	e7e8      	b.n	10003b10 <gpio_cat1_pin_interrupt_configure+0x18>
		if ((cb_data_ptr[index].callback == NULL) || (cb_data_ptr[index].pin == gpio_pin)) {
10003b3e:	6818      	ldr	r0, [r3, #0]
10003b40:	b9b8      	cbnz	r0, 10003b72 <gpio_cat1_pin_interrupt_configure+0x7a>
		cb_data_ptr[index].callback = &gpio_event_callback;
10003b42:	010b      	lsls	r3, r1, #4
10003b44:	eb02 1101 	add.w	r1, r2, r1, lsl #4
		cyhal_gpio_register_callback(gpio_pin, (mode == GPIO_INT_MODE_DISABLED) ?
10003b48:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
		cb_data_ptr[index].callback = &gpio_event_callback;
10003b4c:	480f      	ldr	r0, [pc, #60]	; (10003b8c <gpio_cat1_pin_interrupt_configure+0x94>)
10003b4e:	50d0      	str	r0, [r2, r3]
		cb_data_ptr[index].callback_arg = (void *)(gpio_pin);
10003b50:	604c      	str	r4, [r1, #4]
		cyhal_gpio_register_callback(gpio_pin, (mode == GPIO_INT_MODE_DISABLED) ?
10003b52:	4620      	mov	r0, r4
10003b54:	bf08      	it	eq
10003b56:	2100      	moveq	r1, #0
10003b58:	f002 ffd8 	bl	10006b0c <cyhal_gpio_register_callback>
		cyhal_gpio_enable_event(gpio_pin, event, cfg->intr_priority,
10003b5c:	f5b5 1300 	subs.w	r3, r5, #2097152	; 0x200000
10003b60:	4620      	mov	r0, r4
10003b62:	7b7a      	ldrb	r2, [r7, #13]
10003b64:	bf18      	it	ne
10003b66:	2301      	movne	r3, #1
10003b68:	4631      	mov	r1, r6
10003b6a:	f002 fff5 	bl	10006b58 <cyhal_gpio_enable_event>
		return 0;
10003b6e:	2000      	movs	r0, #0
10003b70:	e7e2      	b.n	10003b38 <gpio_cat1_pin_interrupt_configure+0x40>
		if ((cb_data_ptr[index].callback == NULL) || (cb_data_ptr[index].pin == gpio_pin)) {
10003b72:	7b18      	ldrb	r0, [r3, #12]
10003b74:	42a0      	cmp	r0, r4
10003b76:	f103 0310 	add.w	r3, r3, #16
10003b7a:	d0e2      	beq.n	10003b42 <gpio_cat1_pin_interrupt_configure+0x4a>
	for (index = 0u; index < cfg->ngpios; index++) {
10003b7c:	3101      	adds	r1, #1
10003b7e:	e7d6      	b.n	10003b2e <gpio_cat1_pin_interrupt_configure+0x36>
		return -ENOTSUP;
10003b80:	f06f 0085 	mvn.w	r0, #133	; 0x85
10003b84:	e7d8      	b.n	10003b38 <gpio_cat1_pin_interrupt_configure+0x40>
10003b86:	bf00      	nop
10003b88:	08003550 	.word	0x08003550
10003b8c:	10003c51 	.word	0x10003c51

10003b90 <gpio_cat1_configure>:
{
10003b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10003b92:	4614      	mov	r4, r2
	cyhal_gpio_t gpio_pin = CYHAL_GET_GPIO(GET_PORT_NUM(dev), pin);
10003b94:	4a2c      	ldr	r2, [pc, #176]	; (10003c48 <gpio_cat1_configure+0xb8>)
10003b96:	6843      	ldr	r3, [r0, #4]
10003b98:	6812      	ldr	r2, [r2, #0]
10003b9a:	689b      	ldr	r3, [r3, #8]
10003b9c:	6992      	ldr	r2, [r2, #24]
10003b9e:	1a9b      	subs	r3, r3, r2
10003ba0:	09db      	lsrs	r3, r3, #7
10003ba2:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
	switch (flags & (GPIO_INPUT | GPIO_OUTPUT)) {
10003ba6:	f404 3340 	and.w	r3, r4, #196608	; 0x30000
10003baa:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
	cyhal_gpio_t gpio_pin = CYHAL_GET_GPIO(GET_PORT_NUM(dev), pin);
10003bae:	b2cd      	uxtb	r5, r1
	switch (flags & (GPIO_INPUT | GPIO_OUTPUT)) {
10003bb0:	d006      	beq.n	10003bc0 <gpio_cat1_configure+0x30>
10003bb2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
10003bb6:	d026      	beq.n	10003c06 <gpio_cat1_configure+0x76>
10003bb8:	b39b      	cbz	r3, 10003c22 <gpio_cat1_configure+0x92>
10003bba:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
10003bbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if ((flags & GPIO_PULL_UP) && (flags & GPIO_PULL_DOWN)) {
10003bc0:	f004 0330 	and.w	r3, r4, #48	; 0x30
10003bc4:	2b30      	cmp	r3, #48	; 0x30
10003bc6:	d031      	beq.n	10003c2c <gpio_cat1_configure+0x9c>
		} else if (flags & GPIO_PULL_UP) {
10003bc8:	f014 0310 	ands.w	r3, r4, #16
10003bcc:	d132      	bne.n	10003c34 <gpio_cat1_configure+0xa4>
		} else if (flags & GPIO_PULL_DOWN) {
10003bce:	f014 0420 	ands.w	r4, r4, #32
10003bd2:	d033      	beq.n	10003c3c <gpio_cat1_configure+0xac>
	bool pin_val = false;
10003bd4:	461c      	mov	r4, r3
		gpio_dir = CYHAL_GPIO_DIR_INPUT;
10003bd6:	461e      	mov	r6, r3
			gpio_mode = CYHAL_GPIO_DRIVE_PULLDOWN;
10003bd8:	2703      	movs	r7, #3
	status = cyhal_gpio_init(gpio_pin, gpio_dir, gpio_mode, pin_val);
10003bda:	4623      	mov	r3, r4
10003bdc:	463a      	mov	r2, r7
10003bde:	4631      	mov	r1, r6
10003be0:	4628      	mov	r0, r5
10003be2:	f005 f8a7 	bl	10008d34 <cyhal_gpio_init>
	if (status == CYHAL_HWMGR_RSLT_ERR_INUSE) {
10003be6:	4b19      	ldr	r3, [pc, #100]	; (10003c4c <gpio_cat1_configure+0xbc>)
10003be8:	4298      	cmp	r0, r3
10003bea:	d108      	bne.n	10003bfe <gpio_cat1_configure+0x6e>
		cyhal_gpio_free(gpio_pin);
10003bec:	4628      	mov	r0, r5
10003bee:	f003 f837 	bl	10006c60 <cyhal_gpio_free>
		status = cyhal_gpio_init(gpio_pin, gpio_dir, gpio_mode, pin_val);
10003bf2:	4623      	mov	r3, r4
10003bf4:	463a      	mov	r2, r7
10003bf6:	4631      	mov	r1, r6
10003bf8:	4628      	mov	r0, r5
10003bfa:	f005 f89b 	bl	10008d34 <cyhal_gpio_init>
	return (status == CY_RSLT_SUCCESS) ? 0 : -EIO;
10003bfe:	b198      	cbz	r0, 10003c28 <gpio_cat1_configure+0x98>
10003c00:	f06f 0004 	mvn.w	r0, #4
10003c04:	e7db      	b.n	10003bbe <gpio_cat1_configure+0x2e>
		if (flags & GPIO_SINGLE_ENDED) {
10003c06:	07a3      	lsls	r3, r4, #30
10003c08:	d506      	bpl.n	10003c18 <gpio_cat1_configure+0x88>
			if (flags & GPIO_LINE_OPEN_DRAIN) {
10003c0a:	f014 0404 	ands.w	r4, r4, #4
10003c0e:	d018      	beq.n	10003c42 <gpio_cat1_configure+0xb2>
				pin_val = true;
10003c10:	2401      	movs	r4, #1
		gpio_dir = CYHAL_GPIO_DIR_OUTPUT;
10003c12:	4626      	mov	r6, r4
				gpio_mode = CYHAL_GPIO_DRIVE_OPENDRAINDRIVESLOW;
10003c14:	2704      	movs	r7, #4
10003c16:	e7e0      	b.n	10003bda <gpio_cat1_configure+0x4a>
			pin_val = (flags & GPIO_OUTPUT_INIT_HIGH) ? true : false;
10003c18:	f3c4 44c0 	ubfx	r4, r4, #19, #1
		gpio_dir = CYHAL_GPIO_DIR_OUTPUT;
10003c1c:	2601      	movs	r6, #1
			gpio_mode = CYHAL_GPIO_DRIVE_STRONG;
10003c1e:	2706      	movs	r7, #6
10003c20:	e7db      	b.n	10003bda <gpio_cat1_configure+0x4a>
		cyhal_gpio_free(gpio_pin);
10003c22:	4628      	mov	r0, r5
10003c24:	f003 f81c 	bl	10006c60 <cyhal_gpio_free>
		return 0;
10003c28:	2000      	movs	r0, #0
10003c2a:	e7c8      	b.n	10003bbe <gpio_cat1_configure+0x2e>
	bool pin_val = false;
10003c2c:	2400      	movs	r4, #0
		gpio_dir = CYHAL_GPIO_DIR_INPUT;
10003c2e:	4626      	mov	r6, r4
			gpio_mode = CYHAL_GPIO_DRIVE_PULLUPDOWN;
10003c30:	2707      	movs	r7, #7
10003c32:	e7d2      	b.n	10003bda <gpio_cat1_configure+0x4a>
			pin_val = true;
10003c34:	2401      	movs	r4, #1
		gpio_dir = CYHAL_GPIO_DIR_INPUT;
10003c36:	2600      	movs	r6, #0
			gpio_mode = CYHAL_GPIO_DRIVE_PULLUP;
10003c38:	2702      	movs	r7, #2
10003c3a:	e7ce      	b.n	10003bda <gpio_cat1_configure+0x4a>
		gpio_dir = CYHAL_GPIO_DIR_INPUT;
10003c3c:	4626      	mov	r6, r4
			gpio_mode = CYHAL_GPIO_DRIVE_NONE;
10003c3e:	4627      	mov	r7, r4
10003c40:	e7cb      	b.n	10003bda <gpio_cat1_configure+0x4a>
		gpio_dir = CYHAL_GPIO_DIR_OUTPUT;
10003c42:	2601      	movs	r6, #1
				gpio_mode = CYHAL_GPIO_DRIVE_OPENDRAINDRIVESHIGH;
10003c44:	2705      	movs	r7, #5
10003c46:	e7c8      	b.n	10003bda <gpio_cat1_configure+0x4a>
10003c48:	08003550 	.word	0x08003550
10003c4c:	04020d01 	.word	0x04020d01

10003c50 <gpio_event_callback>:
	const struct device *dev = port_dev_obj[port_num];
10003c50:	4a0e      	ldr	r2, [pc, #56]	; (10003c8c <gpio_event_callback+0x3c>)
	uint32_t port_num = CYHAL_GET_PORT((uint32_t) callback_arg);
10003c52:	f3c0 01c4 	ubfx	r1, r0, #3, #5
{
10003c56:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev = port_dev_obj[port_num];
10003c58:	f852 6021 	ldr.w	r6, [r2, r1, lsl #2]
	if (dev) {
10003c5c:	b146      	cbz	r6, 10003c70 <gpio_event_callback+0x20>
		gpio_fire_callbacks(&((struct gpio_cat1_data *const)(dev)->data)->callbacks,
10003c5e:	6932      	ldr	r2, [r6, #16]
10003c60:	6891      	ldr	r1, [r2, #8]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
10003c62:	b129      	cbz	r1, 10003c70 <gpio_event_callback+0x20>
	uint32_t pin_num = CYHAL_GET_PIN((uint32_t) callback_arg);
10003c64:	f000 0307 	and.w	r3, r0, #7
				    dev, 1 << pin_num);
10003c68:	2501      	movs	r5, #1

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
10003c6a:	680c      	ldr	r4, [r1, #0]
10003c6c:	409d      	lsls	r5, r3
10003c6e:	b901      	cbnz	r1, 10003c72 <gpio_event_callback+0x22>
}
10003c70:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->pin_mask & pins) {
10003c72:	688a      	ldr	r2, [r1, #8]
10003c74:	402a      	ands	r2, r5
10003c76:	d002      	beq.n	10003c7e <gpio_event_callback+0x2e>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
10003c78:	684b      	ldr	r3, [r1, #4]
10003c7a:	4630      	mov	r0, r6
10003c7c:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
10003c7e:	b11c      	cbz	r4, 10003c88 <gpio_event_callback+0x38>
10003c80:	6823      	ldr	r3, [r4, #0]
10003c82:	4621      	mov	r1, r4
10003c84:	461c      	mov	r4, r3
10003c86:	e7f2      	b.n	10003c6e <gpio_event_callback+0x1e>
10003c88:	4623      	mov	r3, r4
10003c8a:	e7fa      	b.n	10003c82 <gpio_event_callback+0x32>
10003c8c:	10009210 	.word	0x10009210

10003c90 <pinctrl_configure_pins>:
	return drv_mode;
}

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
10003c90:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
		uint32_t hsiom = CAT1_PINMUX_GET_HSIOM_FUNC(pins[i].pinmux);
		uint32_t port_num = CAT1_PINMUX_GET_PORT_NUM(pins[i].pinmux);
		uint32_t pin_num = CAT1_PINMUX_GET_PIN_NUM(pins[i].pinmux);

		/* Initialize pin */
		Cy_GPIO_Pin_FastInit(gpio_ports[port_num], pin_num, drv_mode, 1, hsiom);
10003c94:	f8df 808c 	ldr.w	r8, [pc, #140]	; 10003d24 <pinctrl_configure_pins+0x94>
10003c98:	4605      	mov	r5, r0
10003c9a:	eb00 06c1 	add.w	r6, r0, r1, lsl #3
	for (uint8_t i = 0U; i < pin_cnt; i++) {
10003c9e:	42b5      	cmp	r5, r6
10003ca0:	d103      	bne.n	10003caa <pinctrl_configure_pins+0x1a>
			break;
		}
	}

	return 0;
}
10003ca2:	2000      	movs	r0, #0
10003ca4:	b003      	add	sp, #12
10003ca6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		uint32_t drv_mode = soc_gpio_get_drv_mode(pins[i].pincfg);
10003caa:	686b      	ldr	r3, [r5, #4]
	if (_flags & SOC_GPIO_OPENDRAIN) {
10003cac:	075c      	lsls	r4, r3, #29
10003cae:	d426      	bmi.n	10003cfe <pinctrl_configure_pins+0x6e>
	} else if (_flags & SOC_GPIO_OPENSOURCE) {
10003cb0:	0718      	lsls	r0, r3, #28
10003cb2:	d426      	bmi.n	10003d02 <pinctrl_configure_pins+0x72>
	} else if (_flags & SOC_GPIO_PUSHPULL) {
10003cb4:	06d9      	lsls	r1, r3, #27
10003cb6:	d426      	bmi.n	10003d06 <pinctrl_configure_pins+0x76>
	} else if ((_flags & SOC_GPIO_PULLUP) && (_flags & SOC_GPIO_PULLDOWN)) {
10003cb8:	f003 0203 	and.w	r2, r3, #3
10003cbc:	2a03      	cmp	r2, #3
10003cbe:	d024      	beq.n	10003d0a <pinctrl_configure_pins+0x7a>
	} else if (_flags & SOC_GPIO_PULLUP) {
10003cc0:	07da      	lsls	r2, r3, #31
10003cc2:	d424      	bmi.n	10003d0e <pinctrl_configure_pins+0x7e>
		drv_mode = CY_GPIO_DM_PULLDOWN_IN_OFF;
10003cc4:	f013 0402 	ands.w	r4, r3, #2
10003cc8:	bf18      	it	ne
10003cca:	2403      	movne	r4, #3
	if (_flags & SOC_GPIO_INPUTENABLE) {
10003ccc:	069b      	lsls	r3, r3, #26
		uint32_t hsiom = CAT1_PINMUX_GET_HSIOM_FUNC(pins[i].pinmux);
10003cce:	682b      	ldr	r3, [r5, #0]
		uint32_t port_num = CAT1_PINMUX_GET_PORT_NUM(pins[i].pinmux);
10003cd0:	b2da      	uxtb	r2, r3
		drv_mode |= CY_GPIO_DM_HIGHZ;
10003cd2:	bf48      	it	mi
10003cd4:	f044 0408 	orrmi.w	r4, r4, #8
		Cy_GPIO_Pin_FastInit(gpio_ports[port_num], pin_num, drv_mode, 1, hsiom);
10003cd8:	f858 7022 	ldr.w	r7, [r8, r2, lsl #2]
		uint32_t pin_num = CAT1_PINMUX_GET_PIN_NUM(pins[i].pinmux);
10003cdc:	f3c3 2907 	ubfx	r9, r3, #8, #8
		Cy_GPIO_Pin_FastInit(gpio_ports[port_num], pin_num, drv_mode, 1, hsiom);
10003ce0:	f3c3 4307 	ubfx	r3, r3, #16, #8
10003ce4:	9300      	str	r3, [sp, #0]
10003ce6:	4622      	mov	r2, r4
10003ce8:	2301      	movs	r3, #1
10003cea:	4649      	mov	r1, r9
10003cec:	4638      	mov	r0, r7
10003cee:	f000 fbc5 	bl	1000447c <Cy_GPIO_Pin_FastInit>
		switch (drv_mode) {
10003cf2:	2c0a      	cmp	r4, #10
10003cf4:	d00d      	beq.n	10003d12 <pinctrl_configure_pins+0x82>
10003cf6:	2c0b      	cmp	r4, #11
10003cf8:	d011      	beq.n	10003d1e <pinctrl_configure_pins+0x8e>
	for (uint8_t i = 0U; i < pin_cnt; i++) {
10003cfa:	3508      	adds	r5, #8
10003cfc:	e7cf      	b.n	10003c9e <pinctrl_configure_pins+0xe>
		drv_mode = CY_GPIO_DM_OD_DRIVESLOW_IN_OFF;
10003cfe:	2404      	movs	r4, #4
10003d00:	e7e4      	b.n	10003ccc <pinctrl_configure_pins+0x3c>
		drv_mode = CY_GPIO_DM_OD_DRIVESHIGH_IN_OFF;
10003d02:	2405      	movs	r4, #5
10003d04:	e7e2      	b.n	10003ccc <pinctrl_configure_pins+0x3c>
		drv_mode = CY_GPIO_DM_STRONG_IN_OFF;
10003d06:	2406      	movs	r4, #6
10003d08:	e7e0      	b.n	10003ccc <pinctrl_configure_pins+0x3c>
		drv_mode = CY_GPIO_DM_PULLUP_DOWN_IN_OFF;
10003d0a:	2407      	movs	r4, #7
10003d0c:	e7de      	b.n	10003ccc <pinctrl_configure_pins+0x3c>
		drv_mode = CY_GPIO_DM_PULLUP_IN_OFF;
10003d0e:	2402      	movs	r4, #2
10003d10:	e7dc      	b.n	10003ccc <pinctrl_configure_pins+0x3c>
			Cy_GPIO_Write(gpio_ports[port_num], pin_num, 1);
10003d12:	2201      	movs	r2, #1
			Cy_GPIO_Write(gpio_ports[port_num], pin_num, 0);
10003d14:	4649      	mov	r1, r9
10003d16:	4638      	mov	r0, r7
10003d18:	f004 fbdf 	bl	100084da <Cy_GPIO_Write>
			break;
10003d1c:	e7ed      	b.n	10003cfa <pinctrl_configure_pins+0x6a>
			Cy_GPIO_Write(gpio_ports[port_num], pin_num, 0);
10003d1e:	2200      	movs	r2, #0
10003d20:	e7f8      	b.n	10003d14 <pinctrl_configure_pins+0x84>
10003d22:	bf00      	nop
10003d24:	1000924c 	.word	0x1000924c

10003d28 <ifx_cat1_uart_init>:
}
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */


static int ifx_cat1_uart_init(const struct device *dev)
{
10003d28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
10003d2c:	b086      	sub	sp, #24
	struct ifx_cat1_uart_data *const data = dev->data;
10003d2e:	6904      	ldr	r4, [r0, #16]
	const struct ifx_cat1_uart_config *const config = dev->config;
	cy_rslt_t result;
	int ret;

	cyhal_uart_configurator_t uart_init_cfg = {
10003d30:	4a28      	ldr	r2, [pc, #160]	; (10003dd4 <ifx_cat1_uart_init+0xac>)
	const struct ifx_cat1_uart_config *const config = dev->config;
10003d32:	6846      	ldr	r6, [r0, #4]
	cyhal_uart_configurator_t uart_init_cfg = {
10003d34:	9203      	str	r2, [sp, #12]
10003d36:	2300      	movs	r3, #0
		.config = &_cyhal_uart_default_config,
		.clock = &data->clock,
	};

	/* Dedicate SCB HW resource */
	data->hw_resource.type = CYHAL_RSC_SCB;
10003d38:	2217      	movs	r2, #23
		.clock = &data->clock,
10003d3a:	f104 07b4 	add.w	r7, r4, #180	; 0xb4
	data->hw_resource.type = CYHAL_RSC_SCB;
10003d3e:	f884 20b0 	strb.w	r2, [r4, #176]	; 0xb0
	cyhal_uart_configurator_t uart_init_cfg = {
10003d42:	9305      	str	r3, [sp, #20]
10003d44:	9704      	str	r7, [sp, #16]
		.resource = &data->hw_resource,
10003d46:	f104 08b0 	add.w	r8, r4, #176	; 0xb0
	data->hw_resource.block_num = _get_hw_block_num(config->reg_addr);
10003d4a:	6871      	ldr	r1, [r6, #4]
	for (i = 0u; i < _SCB_ARRAY_SIZE; i++) {
10003d4c:	4a22      	ldr	r2, [pc, #136]	; (10003dd8 <ifx_cat1_uart_init+0xb0>)
	cyhal_uart_configurator_t uart_init_cfg = {
10003d4e:	f8cd 8008 	str.w	r8, [sp, #8]
{
10003d52:	4605      	mov	r5, r0
		if (_CYHAL_SCB_BASE_ADDRESSES[i] == reg_addr) {
10003d54:	f852 0b04 	ldr.w	r0, [r2], #4
10003d58:	4281      	cmp	r1, r0
10003d5a:	d004      	beq.n	10003d66 <ifx_cat1_uart_init+0x3e>
	for (i = 0u; i < _SCB_ARRAY_SIZE; i++) {
10003d5c:	3301      	adds	r3, #1
10003d5e:	2b0d      	cmp	r3, #13
10003d60:	d1f8      	bne.n	10003d54 <ifx_cat1_uart_init+0x2c>
	return -1;
10003d62:	f04f 33ff 	mov.w	r3, #4294967295
	data->hw_resource.block_num = _get_hw_block_num(config->reg_addr);
10003d66:	f884 30b1 	strb.w	r3, [r4, #177]	; 0xb1
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
10003d6a:	6830      	ldr	r0, [r6, #0]
10003d6c:	aa01      	add	r2, sp, #4
10003d6e:	2100      	movs	r1, #0
10003d70:	f004 f949 	bl	10008006 <pinctrl_lookup_state>
	if (ret < 0) {
10003d74:	2800      	cmp	r0, #0
10003d76:	db10      	blt.n	10003d9a <ifx_cat1_uart_init+0x72>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
10003d78:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
10003d7a:	2200      	movs	r2, #0
10003d7c:	7919      	ldrb	r1, [r3, #4]
10003d7e:	6818      	ldr	r0, [r3, #0]
10003d80:	f7ff ff86 	bl	10003c90 <pinctrl_configure_pins>

	/* Configure dt provided device signals when available */
	ret = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
	if (ret < 0) {
10003d84:	2800      	cmp	r0, #0
10003d86:	db08      	blt.n	10003d9a <ifx_cat1_uart_init+0x72>
		return ret;
	}

	/* Allocates clock for selected IP block */
	result = _cyhal_utils_allocate_clock(&data->clock, &data->hw_resource,
10003d88:	2301      	movs	r3, #1
10003d8a:	461a      	mov	r2, r3
10003d8c:	4641      	mov	r1, r8
10003d8e:	4638      	mov	r0, r7
10003d90:	f003 f9f0 	bl	10007174 <_cyhal_utils_allocate_clock>
					     CYHAL_CLOCK_BLOCK_PERIPHERAL_16BIT, true);
	if (result != CY_RSLT_SUCCESS) {
10003d94:	b120      	cbz	r0, 10003da0 <ifx_cat1_uart_init+0x78>
		return -ENOTSUP;
10003d96:	f06f 0085 	mvn.w	r0, #133	; 0x85
	/* Perform initial Uart configuration */
	data->obj.is_clock_owned = true;
	ret = ifx_cat1_uart_configure(dev, &config->dt_cfg);

	return ret;
}
10003d9a:	b006      	add	sp, #24
10003d9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	result = _cyhal_utils_peri_pclk_assign_divider(clk_idx, uart_init_cfg.clock);
10003da0:	9b04      	ldr	r3, [sp, #16]
static inline cy_rslt_t _cyhal_utils_peri_pclk_assign_divider(en_clk_dst_t clk_dest, const cyhal_clock_t *clock)
{
    #if defined(COMPONENT_CAT1B)
        return Cy_SysClk_PeriPclkAssignDivider(clk_dest, _CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
    #else
        return Cy_SysClk_PeriphAssignDivider(clk_dest, _CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
10003da2:	7819      	ldrb	r1, [r3, #0]
10003da4:	785a      	ldrb	r2, [r3, #1]
10003da6:	9b02      	ldr	r3, [sp, #8]
10003da8:	f001 0103 	and.w	r1, r1, #3
10003dac:	7858      	ldrb	r0, [r3, #1]
10003dae:	f000 fecf 	bl	10004b50 <Cy_SysClk_PeriphAssignDivider>
	if (result != CY_RSLT_SUCCESS) {
10003db2:	2800      	cmp	r0, #0
10003db4:	d1ef      	bne.n	10003d96 <ifx_cat1_uart_init+0x6e>
	result = cyhal_uart_init_cfg(&data->obj, &uart_init_cfg);
10003db6:	a902      	add	r1, sp, #8
10003db8:	4620      	mov	r0, r4
10003dba:	f004 fcb9 	bl	10008730 <cyhal_uart_init_cfg>
	if (result != CY_RSLT_SUCCESS) {
10003dbe:	2800      	cmp	r0, #0
10003dc0:	d1e9      	bne.n	10003d96 <ifx_cat1_uart_init+0x6e>
	data->obj.is_clock_owned = true;
10003dc2:	2301      	movs	r3, #1
10003dc4:	7363      	strb	r3, [r4, #13]
	ret = ifx_cat1_uart_configure(dev, &config->dt_cfg);
10003dc6:	f106 0108 	add.w	r1, r6, #8
10003dca:	4628      	mov	r0, r5
10003dcc:	f004 f949 	bl	10008062 <ifx_cat1_uart_configure>
	return ret;
10003dd0:	e7e3      	b.n	10003d9a <ifx_cat1_uart_init+0x72>
10003dd2:	bf00      	nop
10003dd4:	100092ec 	.word	0x100092ec
10003dd8:	10009420 	.word	0x10009420

10003ddc <elapsed>:
 *     - the timer reset or the last time the function was called
 *     - and until the current call of the function is completed.
 * - the function is invoked with interrupts disabled.
 */
static uint32_t elapsed(void)
{
10003ddc:	b510      	push	{r4, lr}
	uint32_t val1 = SysTick->VAL;	/* A */
10003dde:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
10003de2:	699a      	ldr	r2, [r3, #24]
	uint32_t ctrl = SysTick->CTRL;	/* B */
10003de4:	6919      	ldr	r1, [r3, #16]
	uint32_t val2 = SysTick->VAL;	/* C */
10003de6:	6998      	ldr	r0, [r3, #24]
	 * 4) After C we'll see it next time
	 *
	 * So the count in val2 is post-wrap and last_load needs to be
	 * added if and only if COUNTFLAG is set or val1 < val2.
	 */
	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
10003de8:	4b09      	ldr	r3, [pc, #36]	; (10003e10 <elapsed+0x34>)
10003dea:	f411 3f80 	tst.w	r1, #65536	; 0x10000
10003dee:	4909      	ldr	r1, [pc, #36]	; (10003e14 <elapsed+0x38>)
10003df0:	d101      	bne.n	10003df6 <elapsed+0x1a>
	    || (val1 < val2)) {
10003df2:	4282      	cmp	r2, r0
10003df4:	d206      	bcs.n	10003e04 <elapsed+0x28>
		overflow_cyc += last_load;
10003df6:	681a      	ldr	r2, [r3, #0]
10003df8:	680c      	ldr	r4, [r1, #0]
10003dfa:	4422      	add	r2, r4
10003dfc:	601a      	str	r2, [r3, #0]

		/* We know there was a wrap, but we might not have
		 * seen it in CTRL, so clear it. */
		(void)SysTick->CTRL;
10003dfe:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
10003e02:	6912      	ldr	r2, [r2, #16]
	}

	return (last_load - val2) + overflow_cyc;
10003e04:	681b      	ldr	r3, [r3, #0]
10003e06:	680a      	ldr	r2, [r1, #0]
10003e08:	4413      	add	r3, r2
}
10003e0a:	1a18      	subs	r0, r3, r0
10003e0c:	bd10      	pop	{r4, pc}
10003e0e:	bf00      	nop
10003e10:	08003548 	.word	0x08003548
10003e14:	0800354c 	.word	0x0800354c

10003e18 <sys_clock_driver_init>:
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
10003e18:	4b09      	ldr	r3, [pc, #36]	; (10003e40 <sys_clock_driver_init+0x28>)
10003e1a:	2220      	movs	r2, #32
10003e1c:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23

static int sys_clock_driver_init(void)
{

	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
	last_load = CYC_PER_TICK - 1;
10003e20:	4b08      	ldr	r3, [pc, #32]	; (10003e44 <sys_clock_driver_init+0x2c>)
10003e22:	f242 720f 	movw	r2, #9999	; 0x270f
10003e26:	601a      	str	r2, [r3, #0]
	overflow_cyc = 0U;
10003e28:	4b07      	ldr	r3, [pc, #28]	; (10003e48 <sys_clock_driver_init+0x30>)
10003e2a:	2000      	movs	r0, #0
10003e2c:	6018      	str	r0, [r3, #0]
	SysTick->LOAD = last_load;
10003e2e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
10003e32:	615a      	str	r2, [r3, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
10003e34:	6198      	str	r0, [r3, #24]
	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
10003e36:	691a      	ldr	r2, [r3, #16]
10003e38:	f042 0207 	orr.w	r2, r2, #7
10003e3c:	611a      	str	r2, [r3, #16]
			  SysTick_CTRL_TICKINT_Msk |
			  SysTick_CTRL_CLKSOURCE_Msk);
	return 0;
}
10003e3e:	4770      	bx	lr
10003e40:	e000ed00 	.word	0xe000ed00
10003e44:	0800354c 	.word	0x0800354c
10003e48:	08003548 	.word	0x08003548

10003e4c <sys_clock_isr>:
{
10003e4c:	b510      	push	{r4, lr}
	elapsed();
10003e4e:	f7ff ffc5 	bl	10003ddc <elapsed>
	cycle_count += overflow_cyc;
10003e52:	4b10      	ldr	r3, [pc, #64]	; (10003e94 <sys_clock_isr+0x48>)
10003e54:	4910      	ldr	r1, [pc, #64]	; (10003e98 <sys_clock_isr+0x4c>)
10003e56:	e9d3 4200 	ldrd	r4, r2, [r3]
10003e5a:	6808      	ldr	r0, [r1, #0]
10003e5c:	1900      	adds	r0, r0, r4
10003e5e:	f142 0200 	adc.w	r2, r2, #0
10003e62:	e9c3 0200 	strd	r0, r2, [r3]
		dcycles = cycle_count - announced_cycles;
10003e66:	4a0d      	ldr	r2, [pc, #52]	; (10003e9c <sys_clock_isr+0x50>)
	overflow_cyc = 0;
10003e68:	2300      	movs	r3, #0
10003e6a:	600b      	str	r3, [r1, #0]
		dcycles = cycle_count - announced_cycles;
10003e6c:	e9d2 4100 	ldrd	r4, r1, [r2]
		dticks = dcycles / CYC_PER_TICK;
10003e70:	f242 7310 	movw	r3, #10000	; 0x2710
		dcycles = cycle_count - announced_cycles;
10003e74:	1b00      	subs	r0, r0, r4
		dticks = dcycles / CYC_PER_TICK;
10003e76:	fbb0 f0f3 	udiv	r0, r0, r3
		announced_cycles += dticks * CYC_PER_TICK;
10003e7a:	4343      	muls	r3, r0
10003e7c:	191b      	adds	r3, r3, r4
10003e7e:	f141 0100 	adc.w	r1, r1, #0
10003e82:	e9c2 3100 	strd	r3, r1, [r2]
		sys_clock_announce(dticks);
10003e86:	f003 fefb 	bl	10007c80 <sys_clock_announce>
}
10003e8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_arm_int_exit();
10003e8e:	f7ff baf1 	b.w	10003474 <z_arm_exc_exit>
10003e92:	bf00      	nop
10003e94:	08002ee0 	.word	0x08002ee0
10003e98:	08003548 	.word	0x08003548
10003e9c:	08002ed8 	.word	0x08002ed8

10003ea0 <sys_clock_set_timeout>:
{
10003ea0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
10003ea4:	4f36      	ldr	r7, [pc, #216]	; (10003f80 <sys_clock_set_timeout+0xe0>)
	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
10003ea6:	2900      	cmp	r1, #0
10003ea8:	d05d      	beq.n	10003f66 <sys_clock_set_timeout+0xc6>
10003eaa:	1c42      	adds	r2, r0, #1
10003eac:	d10a      	bne.n	10003ec4 <sys_clock_set_timeout+0x24>
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
10003eae:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
10003eb2:	6913      	ldr	r3, [r2, #16]
10003eb4:	f023 0301 	bic.w	r3, r3, #1
10003eb8:	6113      	str	r3, [r2, #16]
		last_load = TIMER_STOPPED;
10003eba:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
10003ebe:	603b      	str	r3, [r7, #0]
}
10003ec0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t last_load_ = last_load;
10003ec4:	683e      	ldr	r6, [r7, #0]
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
10003ec6:	2801      	cmp	r0, #1
10003ec8:	dd53      	ble.n	10003f72 <sys_clock_set_timeout+0xd2>
10003eca:	f240 688c 	movw	r8, #1676	; 0x68c
10003ece:	4540      	cmp	r0, r8
10003ed0:	dc01      	bgt.n	10003ed6 <sys_clock_set_timeout+0x36>
10003ed2:	f100 38ff 	add.w	r8, r0, #4294967295
	__asm__ volatile(
10003ed6:	f04f 0320 	mov.w	r3, #32
10003eda:	f3ef 8511 	mrs	r5, BASEPRI
10003ede:	f383 8812 	msr	BASEPRI_MAX, r3
10003ee2:	f3bf 8f6f 	isb	sy
	uint32_t pending = elapsed();
10003ee6:	f7ff ff79 	bl	10003ddc <elapsed>
	cycle_count += pending;
10003eea:	4926      	ldr	r1, [pc, #152]	; (10003f84 <sys_clock_set_timeout+0xe4>)
	val1 = SysTick->VAL;
10003eec:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
10003ef0:	699a      	ldr	r2, [r3, #24]
	cycle_count += pending;
10003ef2:	e9d1 4300 	ldrd	r4, r3, [r1]
10003ef6:	1900      	adds	r0, r0, r4
10003ef8:	f143 0300 	adc.w	r3, r3, #0
10003efc:	e9c1 0300 	strd	r0, r3, [r1]
	overflow_cyc = 0U;
10003f00:	4b21      	ldr	r3, [pc, #132]	; (10003f88 <sys_clock_set_timeout+0xe8>)
10003f02:	2400      	movs	r4, #0
10003f04:	601c      	str	r4, [r3, #0]
	uint32_t unannounced = cycle_count - announced_cycles;
10003f06:	4b21      	ldr	r3, [pc, #132]	; (10003f8c <sys_clock_set_timeout+0xec>)
10003f08:	681b      	ldr	r3, [r3, #0]
	if ((int32_t)unannounced < 0) {
10003f0a:	1ac4      	subs	r4, r0, r3
10003f0c:	d434      	bmi.n	10003f78 <sys_clock_set_timeout+0xd8>
		delay = ticks * CYC_PER_TICK;
10003f0e:	f242 7c10 	movw	ip, #10000	; 0x2710
		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
10003f12:	fb0c 4408 	mla	r4, ip, r8, r4
10003f16:	f504 541c 	add.w	r4, r4, #9984	; 0x2700
		delay -= unannounced;
10003f1a:	1a18      	subs	r0, r3, r0
		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
10003f1c:	340f      	adds	r4, #15
10003f1e:	fbb4 f4fc 	udiv	r4, r4, ip
		delay -= unannounced;
10003f22:	fb0c 0004 	mla	r0, ip, r4, r0
		delay = MAX(delay, MIN_DELAY);
10003f26:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
10003f2a:	d925      	bls.n	10003f78 <sys_clock_set_timeout+0xd8>
		if (delay > MAX_CYCLES) {
10003f2c:	4b18      	ldr	r3, [pc, #96]	; (10003f90 <sys_clock_set_timeout+0xf0>)
10003f2e:	4298      	cmp	r0, r3
10003f30:	bf28      	it	cs
10003f32:	4618      	movcs	r0, r3
	val2 = SysTick->VAL;
10003f34:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
		last_load = MIN_DELAY;
10003f38:	6038      	str	r0, [r7, #0]
	SysTick->LOAD = last_load - 1;
10003f3a:	3801      	subs	r0, #1
	val2 = SysTick->VAL;
10003f3c:	699c      	ldr	r4, [r3, #24]
	SysTick->LOAD = last_load - 1;
10003f3e:	6158      	str	r0, [r3, #20]
	SysTick->VAL = 0; /* resets timer to last_load */
10003f40:	2000      	movs	r0, #0
10003f42:	6198      	str	r0, [r3, #24]
	if (val1 < val2) {
10003f44:	42a2      	cmp	r2, r4
10003f46:	eba2 0304 	sub.w	r3, r2, r4
		cycle_count += (val1 - val2);
10003f4a:	e9d1 0200 	ldrd	r0, r2, [r1]
		cycle_count += (val1 + (last_load_ - val2));
10003f4e:	bf38      	it	cc
10003f50:	199b      	addcc	r3, r3, r6
		cycle_count += (val1 - val2);
10003f52:	181b      	adds	r3, r3, r0
10003f54:	f142 0200 	adc.w	r2, r2, #0
10003f58:	e9c1 3200 	strd	r3, r2, [r1]
	__asm__ volatile(
10003f5c:	f385 8811 	msr	BASEPRI, r5
10003f60:	f3bf 8f6f 	isb	sy
10003f64:	e7ac      	b.n	10003ec0 <sys_clock_set_timeout+0x20>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
10003f66:	1c43      	adds	r3, r0, #1
	uint32_t last_load_ = last_load;
10003f68:	683e      	ldr	r6, [r7, #0]
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
10003f6a:	d1ac      	bne.n	10003ec6 <sys_clock_set_timeout+0x26>
10003f6c:	f240 608c 	movw	r0, #1676	; 0x68c
10003f70:	e7af      	b.n	10003ed2 <sys_clock_set_timeout+0x32>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
10003f72:	f04f 0800 	mov.w	r8, #0
10003f76:	e7ae      	b.n	10003ed6 <sys_clock_set_timeout+0x36>
10003f78:	f44f 6080 	mov.w	r0, #1024	; 0x400
10003f7c:	e7da      	b.n	10003f34 <sys_clock_set_timeout+0x94>
10003f7e:	bf00      	nop
10003f80:	0800354c 	.word	0x0800354c
10003f84:	08002ee0 	.word	0x08002ee0
10003f88:	08003548 	.word	0x08003548
10003f8c:	08002ed8 	.word	0x08002ed8
10003f90:	00ffbcc0 	.word	0x00ffbcc0

10003f94 <sys_clock_elapsed>:
{
10003f94:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
10003f96:	f04f 0320 	mov.w	r3, #32
10003f9a:	f3ef 8511 	mrs	r5, BASEPRI
10003f9e:	f383 8812 	msr	BASEPRI_MAX, r3
10003fa2:	f3bf 8f6f 	isb	sy
	uint32_t unannounced = cycle_count - announced_cycles;
10003fa6:	4b08      	ldr	r3, [pc, #32]	; (10003fc8 <sys_clock_elapsed+0x34>)
10003fa8:	681c      	ldr	r4, [r3, #0]
10003faa:	4b08      	ldr	r3, [pc, #32]	; (10003fcc <sys_clock_elapsed+0x38>)
10003fac:	681b      	ldr	r3, [r3, #0]
10003fae:	1ae4      	subs	r4, r4, r3
	uint32_t cyc = elapsed() + unannounced;
10003fb0:	f7ff ff14 	bl	10003ddc <elapsed>
	__asm__ volatile(
10003fb4:	f385 8811 	msr	BASEPRI, r5
10003fb8:	f3bf 8f6f 	isb	sy
}
10003fbc:	f242 7310 	movw	r3, #10000	; 0x2710
	uint32_t cyc = elapsed() + unannounced;
10003fc0:	4420      	add	r0, r4
}
10003fc2:	fbb0 f0f3 	udiv	r0, r0, r3
10003fc6:	bd38      	pop	{r3, r4, r5, pc}
10003fc8:	08002ee0 	.word	0x08002ee0
10003fcc:	08002ed8 	.word	0x08002ed8

10003fd0 <sys_clock_cycle_get_32>:
{
10003fd0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
10003fd2:	f04f 0320 	mov.w	r3, #32
10003fd6:	f3ef 8511 	mrs	r5, BASEPRI
10003fda:	f383 8812 	msr	BASEPRI_MAX, r3
10003fde:	f3bf 8f6f 	isb	sy
	uint32_t ret = cycle_count;
10003fe2:	4b05      	ldr	r3, [pc, #20]	; (10003ff8 <sys_clock_cycle_get_32+0x28>)
10003fe4:	681c      	ldr	r4, [r3, #0]
	ret += elapsed();
10003fe6:	f7ff fef9 	bl	10003ddc <elapsed>
	__asm__ volatile(
10003fea:	f385 8811 	msr	BASEPRI, r5
10003fee:	f3bf 8f6f 	isb	sy
}
10003ff2:	4420      	add	r0, r4
10003ff4:	bd38      	pop	{r3, r4, r5, pc}
10003ff6:	bf00      	nop
10003ff8:	08002ee0 	.word	0x08002ee0

10003ffc <Cy_PDL_Init>:
* This function must be called prior calling any function in PDL.
*
*******************************************************************************/
void Cy_PDL_Init(const cy_stc_device_t * device)
{
    cy_device = device;
10003ffc:	4b01      	ldr	r3, [pc, #4]	; (10004004 <Cy_PDL_Init+0x8>)
10003ffe:	6018      	str	r0, [r3, #0]
}
10004000:	4770      	bx	lr
10004002:	bf00      	nop
10004004:	08003550 	.word	0x08003550

10004008 <SystemCoreClockUpdate>:
* Updates global variables used by the \ref Cy_SysLib_Delay(), \ref
* Cy_SysLib_DelayUs(), and \ref Cy_SysLib_DelayCycles().
*
*******************************************************************************/
void SystemCoreClockUpdate (void)
{
10004008:	b510      	push	{r4, lr}
    uint32 locHf0Clock = Cy_SysClk_ClkHfGetFrequency(0UL);
1000400a:	2000      	movs	r0, #0
1000400c:	f004 faad 	bl	1000856a <Cy_SysClk_ClkHfGetFrequency>

    if (0UL != locHf0Clock)
10004010:	4604      	mov	r4, r0
10004012:	b300      	cbz	r0, 10004056 <SystemCoreClockUpdate+0x4e>
    {
        cy_Hfclk0FreqHz = locHf0Clock;
10004014:	4b10      	ldr	r3, [pc, #64]	; (10004058 <SystemCoreClockUpdate+0x50>)
10004016:	6018      	str	r0, [r3, #0]
        cy_PeriClkFreqHz = locHf0Clock / (1UL + (uint32_t)Cy_SysClk_ClkPeriGetDivider());
10004018:	f000 ff3e 	bl	10004e98 <Cy_SysClk_ClkPeriGetDivider>
1000401c:	4b0f      	ldr	r3, [pc, #60]	; (1000405c <SystemCoreClockUpdate+0x54>)
1000401e:	3001      	adds	r0, #1
10004020:	fbb4 f0f0 	udiv	r0, r4, r0
10004024:	6018      	str	r0, [r3, #0]
        SystemCoreClock = locHf0Clock / (1UL + (uint32_t)Cy_SysClk_ClkFastGetDivider());
10004026:	f000 ff4f 	bl	10004ec8 <Cy_SysClk_ClkFastGetDivider>
1000402a:	4b0d      	ldr	r3, [pc, #52]	; (10004060 <SystemCoreClockUpdate+0x58>)

        /* Sets clock frequency for Delay API */
        cy_delayFreqMhz = (uint8_t)CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1M_THRESHOLD);
1000402c:	4a0d      	ldr	r2, [pc, #52]	; (10004064 <SystemCoreClockUpdate+0x5c>)
        SystemCoreClock = locHf0Clock / (1UL + (uint32_t)Cy_SysClk_ClkFastGetDivider());
1000402e:	3001      	adds	r0, #1
10004030:	fbb4 f4f0 	udiv	r4, r4, r0
10004034:	601c      	str	r4, [r3, #0]
        cy_delayFreqMhz = (uint8_t)CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1M_THRESHOLD);
10004036:	3c01      	subs	r4, #1
10004038:	4b0b      	ldr	r3, [pc, #44]	; (10004068 <SystemCoreClockUpdate+0x60>)
1000403a:	fbb4 f3f3 	udiv	r3, r4, r3
1000403e:	3301      	adds	r3, #1
10004040:	7013      	strb	r3, [r2, #0]
        cy_delayFreqKhz = CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1K_THRESHOLD);
10004042:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
10004046:	fbb4 f4f3 	udiv	r4, r4, r3
1000404a:	4b08      	ldr	r3, [pc, #32]	; (1000406c <SystemCoreClockUpdate+0x64>)
1000404c:	3401      	adds	r4, #1
1000404e:	601c      	str	r4, [r3, #0]
        cy_delay32kMs   = CY_DELAY_MS_OVERFLOW_THRESHOLD * cy_delayFreqKhz;
10004050:	4b07      	ldr	r3, [pc, #28]	; (10004070 <SystemCoreClockUpdate+0x68>)
10004052:	03e4      	lsls	r4, r4, #15
10004054:	601c      	str	r4, [r3, #0]
    }
}
10004056:	bd10      	pop	{r4, pc}
10004058:	080028a4 	.word	0x080028a4
1000405c:	080028a0 	.word	0x080028a0
10004060:	080028a8 	.word	0x080028a8
10004064:	08002980 	.word	0x08002980
10004068:	000f4240 	.word	0x000f4240
1000406c:	0800289c 	.word	0x0800289c
10004070:	08002898 	.word	0x08002898

10004074 <SystemInit>:
{
10004074:	b508      	push	{r3, lr}
    Cy_PDL_Init(CY_DEVICE_CFG);
10004076:	480a      	ldr	r0, [pc, #40]	; (100040a0 <SystemInit+0x2c>)
10004078:	f7ff ffc0 	bl	10003ffc <Cy_PDL_Init>
    Cy_SystemInit();
1000407c:	f004 f843 	bl	10008106 <Cy_SystemInit>
    SystemCoreClockUpdate();
10004080:	f7ff ffc2 	bl	10004008 <SystemCoreClockUpdate>
        (void) Cy_IPC_Sema_Init(CY_IPC_CHAN_SEMA, 0ul, NULL);
10004084:	2200      	movs	r2, #0
10004086:	4611      	mov	r1, r2
10004088:	2003      	movs	r0, #3
1000408a:	f000 fc15 	bl	100048b8 <Cy_IPC_Sema_Init>
    Cy_IPC_Pipe_Config(systemIpcPipeEpArray);
1000408e:	4805      	ldr	r0, [pc, #20]	; (100040a4 <SystemInit+0x30>)
10004090:	f000 fab0 	bl	100045f4 <Cy_IPC_Pipe_Config>
}
10004094:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Cy_IPC_Pipe_Init(&systemIpcPipeConfigCm4);
10004098:	4803      	ldr	r0, [pc, #12]	; (100040a8 <SystemInit+0x34>)
1000409a:	f000 bafb 	b.w	10004694 <Cy_IPC_Pipe_Init>
1000409e:	bf00      	nop
100040a0:	1000932c 	.word	0x1000932c
100040a4:	08003574 	.word	0x08003574
100040a8:	100093ec 	.word	0x100093ec

100040ac <Cy_SCB_UART_Init>:
* \note
* Ensure that the SCB block is disabled before calling this function.
*
*******************************************************************************/
cy_en_scb_uart_status_t Cy_SCB_UART_Init(CySCB_Type *base, cy_stc_scb_uart_config_t const *config, cy_stc_scb_uart_context_t *context)
{
100040ac:	b538      	push	{r3, r4, r5, lr}
    if ((NULL == base) || (NULL == config))
100040ae:	4604      	mov	r4, r0
100040b0:	2800      	cmp	r0, #0
100040b2:	f000 812b 	beq.w	1000430c <Cy_SCB_UART_Init+0x260>
100040b6:	2900      	cmp	r1, #0
100040b8:	f000 8128 	beq.w	1000430c <Cy_SCB_UART_Init+0x260>
    {
        return CY_SCB_UART_BAD_PARAM;
    }

    CY_ASSERT_L3(CY_SCB_UART_IS_MODE_VALID     (config->uartMode));
100040bc:	780b      	ldrb	r3, [r1, #0]
100040be:	2b02      	cmp	r3, #2
100040c0:	d900      	bls.n	100040c4 <Cy_SCB_UART_Init+0x18>

/** Halt the processor in the debug state
 */
static inline void CY_HALT(void)
{
    __asm("    bkpt    1");
100040c2:	be01      	bkpt	0x0001
    CY_ASSERT_L3(CY_SCB_UART_IS_STOP_BITS_VALID(config->stopBits));
100040c4:	7b4b      	ldrb	r3, [r1, #13]
100040c6:	3b02      	subs	r3, #2
100040c8:	2b06      	cmp	r3, #6
100040ca:	d900      	bls.n	100040ce <Cy_SCB_UART_Init+0x22>
100040cc:	be01      	bkpt	0x0001
    CY_ASSERT_L3(CY_SCB_UART_IS_PARITY_VALID   (config->parity));
100040ce:	7b8b      	ldrb	r3, [r1, #14]
100040d0:	b11b      	cbz	r3, 100040da <Cy_SCB_UART_Init+0x2e>
100040d2:	3b02      	subs	r3, #2
100040d4:	2b01      	cmp	r3, #1
100040d6:	d900      	bls.n	100040da <Cy_SCB_UART_Init+0x2e>
100040d8:	be01      	bkpt	0x0001
    CY_ASSERT_L3(CY_SCB_UART_IS_POLARITY_VALID (config->ctsPolarity));
100040da:	f891 3021 	ldrb.w	r3, [r1, #33]	; 0x21
100040de:	2b01      	cmp	r3, #1
100040e0:	d900      	bls.n	100040e4 <Cy_SCB_UART_Init+0x38>
100040e2:	be01      	bkpt	0x0001
    CY_ASSERT_L3(CY_SCB_UART_IS_POLARITY_VALID (config->rtsPolarity));
100040e4:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
100040e8:	2b01      	cmp	r3, #1
100040ea:	d900      	bls.n	100040ee <Cy_SCB_UART_Init+0x42>
100040ec:	be01      	bkpt	0x0001

    CY_ASSERT_L2(CY_SCB_UART_IS_OVERSAMPLE_VALID  (config->oversample, config->uartMode, config->irdaEnableLowPowerReceiver));
100040ee:	780b      	ldrb	r3, [r1, #0]
100040f0:	2b01      	cmp	r3, #1
100040f2:	f200 8100 	bhi.w	100042f6 <Cy_SCB_UART_Init+0x24a>
100040f6:	684b      	ldr	r3, [r1, #4]
100040f8:	3b08      	subs	r3, #8
100040fa:	2b08      	cmp	r3, #8
100040fc:	d900      	bls.n	10004100 <Cy_SCB_UART_Init+0x54>
100040fe:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_UART_IS_DATA_WIDTH_VALID  (config->dataWidth));
10004100:	688b      	ldr	r3, [r1, #8]
10004102:	3b05      	subs	r3, #5
10004104:	2b04      	cmp	r3, #4
10004106:	d900      	bls.n	1000410a <Cy_SCB_UART_Init+0x5e>
10004108:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_UART_IS_ADDRESS_VALID     (config->receiverAddress));
1000410a:	694b      	ldr	r3, [r1, #20]
1000410c:	2bff      	cmp	r3, #255	; 0xff
1000410e:	d900      	bls.n	10004112 <Cy_SCB_UART_Init+0x66>
10004110:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_UART_IS_ADDRESS_MASK_VALID(config->receiverAddressMask));
10004112:	698b      	ldr	r3, [r1, #24]
10004114:	2bff      	cmp	r3, #255	; 0xff
10004116:	d900      	bls.n	1000411a <Cy_SCB_UART_Init+0x6e>
10004118:	be01      	bkpt	0x0001

    CY_ASSERT_L2(CY_SCB_UART_IS_MUTLI_PROC_VALID  (config->enableMutliProcessorMode, config->uartMode, config->dataWidth, config->parity));
1000411a:	7c8b      	ldrb	r3, [r1, #18]
1000411c:	b13b      	cbz	r3, 1000412e <Cy_SCB_UART_Init+0x82>
1000411e:	780b      	ldrb	r3, [r1, #0]
10004120:	b923      	cbnz	r3, 1000412c <Cy_SCB_UART_Init+0x80>
10004122:	688b      	ldr	r3, [r1, #8]
10004124:	2b09      	cmp	r3, #9
10004126:	d101      	bne.n	1000412c <Cy_SCB_UART_Init+0x80>
10004128:	7b8b      	ldrb	r3, [r1, #14]
1000412a:	b103      	cbz	r3, 1000412e <Cy_SCB_UART_Init+0x82>
1000412c:	be01      	bkpt	0x0001

    CY_ASSERT_L2(CY_SCB_IS_INTR_VALID(config->rxFifoIntEnableMask, CY_SCB_UART_RX_INTR_MASK));
1000412e:	6b4b      	ldr	r3, [r1, #52]	; 0x34
10004130:	f423 6336 	bic.w	r3, r3, #2912	; 0xb60
10004134:	f023 030d 	bic.w	r3, r3, #13
10004138:	b103      	cbz	r3, 1000413c <Cy_SCB_UART_Init+0x90>
1000413a:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_IS_INTR_VALID(config->txFifoIntEnableMask, CY_SCB_UART_TX_INTR_MASK));
1000413c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
1000413e:	f423 63ee 	bic.w	r3, r3, #1904	; 0x770
10004142:	f023 0303 	bic.w	r3, r3, #3
10004146:	b103      	cbz	r3, 1000414a <Cy_SCB_UART_Init+0x9e>
10004148:	be01      	bkpt	0x0001

    uint32_t ovs;

    if ((CY_SCB_UART_IRDA == config->uartMode) && (!config->irdaEnableLowPowerReceiver))
1000414a:	780b      	ldrb	r3, [r1, #0]
1000414c:	2b02      	cmp	r3, #2
1000414e:	d101      	bne.n	10004154 <Cy_SCB_UART_Init+0xa8>
10004150:	7f8b      	ldrb	r3, [r1, #30]
10004152:	b10b      	cbz	r3, 10004158 <Cy_SCB_UART_Init+0xac>
        /* For Normal IrDA mode oversampling is always zero */
        ovs = 0UL;
    }
    else
    {
        ovs = (config->oversample - 1UL);
10004154:	684b      	ldr	r3, [r1, #4]
10004156:	3b01      	subs	r3, #1
    SCB_CTRL(base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, config->acceptAddrInFifo)                      |
                 _VAL2FLD(SCB_CTRL_MEM_WIDTH, ((config->dataWidth <= CY_SCB_BYTE_WIDTH)? 0UL:1UL))  |
                 _VAL2FLD(SCB_CTRL_OVS, ovs)                                                        |
                 _VAL2FLD(SCB_CTRL_MODE, CY_SCB_CTRL_MODE_UART);
#elif(CY_IP_MXSCB_VERSION==1)
    SCB_CTRL(base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, config->acceptAddrInFifo)               |
10004158:	7f08      	ldrb	r0, [r1, #28]
                 _BOOL2FLD(SCB_CTRL_BYTE_MODE, (config->dataWidth <= CY_SCB_BYTE_WIDTH)) |
                 _VAL2FLD(SCB_CTRL_OVS, ovs)                                             |
1000415a:	f003 030f 	and.w	r3, r3, #15
                 _BOOL2FLD(SCB_CTRL_BYTE_MODE, (config->dataWidth <= CY_SCB_BYTE_WIDTH)) |
1000415e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
10004162:	6888      	ldr	r0, [r1, #8]
10004164:	2808      	cmp	r0, #8
10004166:	bf8c      	ite	hi
10004168:	2000      	movhi	r0, #0
1000416a:	2001      	movls	r0, #1
1000416c:	ea43 23c0 	orr.w	r3, r3, r0, lsl #11
                 _VAL2FLD(SCB_CTRL_OVS, ovs)                                             |
10004170:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    SCB_CTRL(base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, config->acceptAddrInFifo)               |
10004174:	6023      	str	r3, [r4, #0]
                 _VAL2FLD(SCB_CTRL_MODE, CY_SCB_CTRL_MODE_UART);
#endif /* CY_IP_MXSCB_VERSION */
    /* Configure SCB_CTRL.BYTE_MODE then verify levels */
    CY_ASSERT_L2(CY_SCB_IS_TRIGGER_LEVEL_VALID(base, config->rxFifoTriggerLevel));
10004176:	4620      	mov	r0, r4
10004178:	6b0d      	ldr	r5, [r1, #48]	; 0x30
1000417a:	f003 ffc5 	bl	10008108 <Cy_SCB_GetFifoSize>
1000417e:	4285      	cmp	r5, r0
10004180:	d300      	bcc.n	10004184 <Cy_SCB_UART_Init+0xd8>
10004182:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_IS_TRIGGER_LEVEL_VALID(base, config->txFifoTriggerLevel));
10004184:	4620      	mov	r0, r4
10004186:	6b8d      	ldr	r5, [r1, #56]	; 0x38
10004188:	f003 ffbe 	bl	10008108 <Cy_SCB_GetFifoSize>
1000418c:	4285      	cmp	r5, r0
1000418e:	d300      	bcc.n	10004192 <Cy_SCB_UART_Init+0xe6>
10004190:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_SCB_IS_TRIGGER_LEVEL_VALID(base, config->rtsRxFifoLevel));
10004192:	4620      	mov	r0, r4
10004194:	6a4d      	ldr	r5, [r1, #36]	; 0x24
10004196:	f003 ffb7 	bl	10008108 <Cy_SCB_GetFifoSize>
1000419a:	4285      	cmp	r5, r0
1000419c:	d300      	bcc.n	100041a0 <Cy_SCB_UART_Init+0xf4>
1000419e:	be01      	bkpt	0x0001

    SCB_UART_CTRL(base) = _VAL2FLD(SCB_UART_CTRL_MODE, (uint32_t) config->uartMode);
100041a0:	780b      	ldrb	r3, [r1, #0]
100041a2:	061b      	lsls	r3, r3, #24
100041a4:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
100041a8:	6423      	str	r3, [r4, #64]	; 0x40

    /* Configure the RX direction */
    SCB_UART_RX_CTRL(base) = _BOOL2FLD(SCB_UART_RX_CTRL_POLARITY, config->irdaInvertRx)                  |
100041aa:	7f4b      	ldrb	r3, [r1, #29]
                         _BOOL2FLD(SCB_UART_RX_CTRL_MP_MODE, config->enableMutliProcessorMode)       |
100041ac:	7c88      	ldrb	r0, [r1, #18]
    SCB_UART_RX_CTRL(base) = _BOOL2FLD(SCB_UART_RX_CTRL_POLARITY, config->irdaInvertRx)                  |
100041ae:	019b      	lsls	r3, r3, #6
100041b0:	ea43 2380 	orr.w	r3, r3, r0, lsl #10
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_PARITY_ERROR, config->dropOnParityError) |
100041b4:	7c08      	ldrb	r0, [r1, #16]
                         _BOOL2FLD(SCB_UART_RX_CTRL_MP_MODE, config->enableMutliProcessorMode)       |
100041b6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_FRAME_ERROR, config->dropOnFrameError)   |
100041ba:	7c48      	ldrb	r0, [r1, #17]
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_PARITY_ERROR, config->dropOnParityError) |
100041bc:	ea43 2340 	orr.w	r3, r3, r0, lsl #9
                         _VAL2FLD(SCB_UART_RX_CTRL_BREAK_WIDTH, (config->breakWidth - 1UL))          |
100041c0:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
100041c2:	3801      	subs	r0, #1
100041c4:	0400      	lsls	r0, r0, #16
100041c6:	f400 2070 	and.w	r0, r0, #983040	; 0xf0000
                         _BOOL2FLD(SCB_UART_RX_CTRL_DROP_ON_FRAME_ERROR, config->dropOnFrameError)   |
100041ca:	4303      	orrs	r3, r0
                         _VAL2FLD(SCB_UART_RX_CTRL_STOP_BITS,   ((uint32_t) config->stopBits) - 1UL) |
100041cc:	7b48      	ldrb	r0, [r1, #13]
100041ce:	3801      	subs	r0, #1
100041d0:	f000 0007 	and.w	r0, r0, #7
                         _VAL2FLD(SCB_UART_RX_CTRL_BREAK_WIDTH, (config->breakWidth - 1UL))          |
100041d4:	4303      	orrs	r3, r0
                         _VAL2FLD(CY_SCB_UART_RX_CTRL_SET_PARITY, (uint32_t) config->parity);
100041d6:	7b88      	ldrb	r0, [r1, #14]
100041d8:	0100      	lsls	r0, r0, #4
100041da:	f000 0030 	and.w	r0, r0, #48	; 0x30
                         _VAL2FLD(SCB_UART_RX_CTRL_STOP_BITS,   ((uint32_t) config->stopBits) - 1UL) |
100041de:	4303      	orrs	r3, r0
    SCB_UART_RX_CTRL(base) = _BOOL2FLD(SCB_UART_RX_CTRL_POLARITY, config->irdaInvertRx)                  |
100041e0:	64a3      	str	r3, [r4, #72]	; 0x48
#if(CY_IP_MXSCB_VERSION>=3)
    SCB_UART_RX_CTRL(base)|=_BOOL2FLD(SCB_UART_RX_CTRL_BREAK_LEVEL, config->breaklevel);
#endif /* CY_IP_MXSCB_VERSION */

    SCB_RX_CTRL(base) = _BOOL2FLD(SCB_RX_CTRL_MSB_FIRST, config->enableMsbFirst)          |
100041e2:	7b0d      	ldrb	r5, [r1, #12]
                    _BOOL2FLD(SCB_RX_CTRL_MEDIAN, ((config->enableInputFilter) || \
100041e4:	7bcb      	ldrb	r3, [r1, #15]
    SCB_RX_CTRL(base) = _BOOL2FLD(SCB_RX_CTRL_MSB_FIRST, config->enableMsbFirst)          |
100041e6:	022d      	lsls	r5, r5, #8
                    _BOOL2FLD(SCB_RX_CTRL_MEDIAN, ((config->enableInputFilter) || \
100041e8:	2b00      	cmp	r3, #0
100041ea:	f040 808c 	bne.w	10004306 <Cy_SCB_UART_Init+0x25a>
100041ee:	7808      	ldrb	r0, [r1, #0]
100041f0:	1e83      	subs	r3, r0, #2
100041f2:	4258      	negs	r0, r3
100041f4:	4158      	adcs	r0, r3
100041f6:	0240      	lsls	r0, r0, #9
                                             (config->uartMode == CY_SCB_UART_IRDA))) |
                    _VAL2FLD(SCB_RX_CTRL_DATA_WIDTH, (config->dataWidth - 1UL));
100041f8:	688b      	ldr	r3, [r1, #8]
100041fa:	3b01      	subs	r3, #1
100041fc:	f003 030f 	and.w	r3, r3, #15
                                             (config->uartMode == CY_SCB_UART_IRDA))) |
10004200:	432b      	orrs	r3, r5
10004202:	4303      	orrs	r3, r0
    SCB_RX_CTRL(base) = _BOOL2FLD(SCB_RX_CTRL_MSB_FIRST, config->enableMsbFirst)          |
10004204:	f8c4 3300 	str.w	r3, [r4, #768]	; 0x300

    SCB_RX_MATCH(base) = _VAL2FLD(SCB_RX_MATCH_ADDR, config->receiverAddress) |
                     _VAL2FLD(SCB_RX_MATCH_MASK, config->receiverAddressMask);
10004208:	698b      	ldr	r3, [r1, #24]
    SCB_RX_MATCH(base) = _VAL2FLD(SCB_RX_MATCH_ADDR, config->receiverAddress) |
1000420a:	7d08      	ldrb	r0, [r1, #20]
                     _VAL2FLD(SCB_RX_MATCH_MASK, config->receiverAddressMask);
1000420c:	041b      	lsls	r3, r3, #16
1000420e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    SCB_RX_MATCH(base) = _VAL2FLD(SCB_RX_MATCH_ADDR, config->receiverAddress) |
10004212:	4303      	orrs	r3, r0
10004214:	f8c4 3310 	str.w	r3, [r4, #784]	; 0x310

    /* Configure SCB_CTRL.RX_CTRL then verify break width */
    CY_ASSERT_L2(CY_SCB_UART_IS_RX_BREAK_WIDTH_VALID(base, config->breakWidth));
10004218:	f8d4 3300 	ldr.w	r3, [r4, #768]	; 0x300
1000421c:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
1000421e:	f003 030f 	and.w	r3, r3, #15
10004222:	3303      	adds	r3, #3
10004224:	4298      	cmp	r0, r3
10004226:	d301      	bcc.n	1000422c <Cy_SCB_UART_Init+0x180>
10004228:	2810      	cmp	r0, #16
1000422a:	d900      	bls.n	1000422e <Cy_SCB_UART_Init+0x182>
1000422c:	be01      	bkpt	0x0001

    /* Configure the TX direction */
    SCB_UART_TX_CTRL(base) = _BOOL2FLD(SCB_UART_TX_CTRL_RETRY_ON_NACK, ((config->smartCardRetryOnNack) && \
1000422e:	7fc8      	ldrb	r0, [r1, #31]
10004230:	b138      	cbz	r0, 10004242 <Cy_SCB_UART_Init+0x196>
10004232:	7808      	ldrb	r0, [r1, #0]
10004234:	f100 3cff 	add.w	ip, r0, #4294967295
10004238:	f1dc 0000 	rsbs	r0, ip, #0
1000423c:	eb40 000c 	adc.w	r0, r0, ip
10004240:	0200      	lsls	r0, r0, #8
                                                              (config->uartMode == CY_SCB_UART_SMARTCARD))) |
                         _VAL2FLD(SCB_UART_TX_CTRL_STOP_BITS, ((uint32_t) config->stopBits) - 1UL)          |
10004242:	7b4b      	ldrb	r3, [r1, #13]
                         _VAL2FLD(CY_SCB_UART_TX_CTRL_SET_PARITY, (uint32_t) config->parity);
10004244:	7b8d      	ldrb	r5, [r1, #14]
                         _VAL2FLD(SCB_UART_TX_CTRL_STOP_BITS, ((uint32_t) config->stopBits) - 1UL)          |
10004246:	3b01      	subs	r3, #1
                         _VAL2FLD(CY_SCB_UART_TX_CTRL_SET_PARITY, (uint32_t) config->parity);
10004248:	012d      	lsls	r5, r5, #4
1000424a:	f005 0530 	and.w	r5, r5, #48	; 0x30
                         _VAL2FLD(SCB_UART_TX_CTRL_STOP_BITS, ((uint32_t) config->stopBits) - 1UL)          |
1000424e:	f003 0307 	and.w	r3, r3, #7
10004252:	432b      	orrs	r3, r5
10004254:	4303      	orrs	r3, r0
    SCB_UART_TX_CTRL(base) = _BOOL2FLD(SCB_UART_TX_CTRL_RETRY_ON_NACK, ((config->smartCardRetryOnNack) && \
10004256:	6463      	str	r3, [r4, #68]	; 0x44

    SCB_TX_CTRL(base)  = _BOOL2FLD(SCB_TX_CTRL_MSB_FIRST,  config->enableMsbFirst)    |
                     _VAL2FLD(SCB_TX_CTRL_DATA_WIDTH,  (config->dataWidth - 1UL)) |
10004258:	688b      	ldr	r3, [r1, #8]
    SCB_TX_CTRL(base)  = _BOOL2FLD(SCB_TX_CTRL_MSB_FIRST,  config->enableMsbFirst)    |
1000425a:	7b08      	ldrb	r0, [r1, #12]
                     _VAL2FLD(SCB_TX_CTRL_DATA_WIDTH,  (config->dataWidth - 1UL)) |
1000425c:	3b01      	subs	r3, #1
1000425e:	f003 030f 	and.w	r3, r3, #15
    SCB_TX_CTRL(base)  = _BOOL2FLD(SCB_TX_CTRL_MSB_FIRST,  config->enableMsbFirst)    |
10004262:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                     _BOOL2FLD(SCB_TX_CTRL_OPEN_DRAIN, (config->uartMode == CY_SCB_UART_SMARTCARD));
10004266:	7808      	ldrb	r0, [r1, #0]
10004268:	1e45      	subs	r5, r0, #1
1000426a:	4268      	negs	r0, r5
1000426c:	4168      	adcs	r0, r5
                     _VAL2FLD(SCB_TX_CTRL_DATA_WIDTH,  (config->dataWidth - 1UL)) |
1000426e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
    SCB_TX_CTRL(base)  = _BOOL2FLD(SCB_TX_CTRL_MSB_FIRST,  config->enableMsbFirst)    |
10004272:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200

    SCB_RX_FIFO_CTRL(base) = _VAL2FLD(SCB_RX_FIFO_CTRL_TRIGGER_LEVEL, config->rxFifoTriggerLevel);
10004276:	f891 3030 	ldrb.w	r3, [r1, #48]	; 0x30
1000427a:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304

    /* Configure the flow control */
    SCB_UART_FLOW_CTRL(base) = _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_ENABLED, config->enableCts) |
1000427e:	f891 0020 	ldrb.w	r0, [r1, #32]
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->ctsPolarity)) |
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_RTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->rtsPolarity)) |
                           _VAL2FLD(SCB_UART_FLOW_CTRL_TRIGGER_LEVEL, config->rtsRxFifoLevel);
10004282:	f891 3024 	ldrb.w	r3, [r1, #36]	; 0x24
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_RTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->rtsPolarity)) |
10004286:	ea43 6340 	orr.w	r3, r3, r0, lsl #25
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->ctsPolarity)) |
1000428a:	f891 0021 	ldrb.w	r0, [r1, #33]	; 0x21
1000428e:	f100 3cff 	add.w	ip, r0, #4294967295
10004292:	f1dc 0000 	rsbs	r0, ip, #0
10004296:	eb40 000c 	adc.w	r0, r0, ip
                           _BOOL2FLD(SCB_UART_FLOW_CTRL_RTS_POLARITY, (CY_SCB_UART_ACTIVE_HIGH == config->rtsPolarity)) |
1000429a:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
1000429e:	f891 0028 	ldrb.w	r0, [r1, #40]	; 0x28
100042a2:	1e45      	subs	r5, r0, #1
100042a4:	4268      	negs	r0, r5
100042a6:	4168      	adcs	r0, r5
100042a8:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
    SCB_UART_FLOW_CTRL(base) = _BOOL2FLD(SCB_UART_FLOW_CTRL_CTS_ENABLED, config->enableCts) |
100042ac:	6523      	str	r3, [r4, #80]	; 0x50

    SCB_TX_FIFO_CTRL(base) = _VAL2FLD(SCB_TX_FIFO_CTRL_TRIGGER_LEVEL, config->txFifoTriggerLevel);
100042ae:	f891 3038 	ldrb.w	r3, [r1, #56]	; 0x38
100042b2:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204

    /* Set up interrupt sources */
    SCB_INTR_RX_MASK(base) = (config->rxFifoIntEnableMask & CY_SCB_UART_RX_INTR_MASK);
100042b6:	6b4b      	ldr	r3, [r1, #52]	; 0x34
100042b8:	f423 6392 	bic.w	r3, r3, #1168	; 0x490
100042bc:	f023 0302 	bic.w	r3, r3, #2
100042c0:	051b      	lsls	r3, r3, #20
100042c2:	0d1b      	lsrs	r3, r3, #20
100042c4:	f8c4 3fc8 	str.w	r3, [r4, #4040]	; 0xfc8
    SCB_INTR_TX_MASK(base) = (config->txFifoIntEnableMask & CY_SCB_UART_TX_INTR_MASK);
100042c8:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
100042ca:	f023 038c 	bic.w	r3, r3, #140	; 0x8c
100042ce:	055b      	lsls	r3, r3, #21
100042d0:	0d5b      	lsrs	r3, r3, #21
100042d2:	f8c4 3f88 	str.w	r3, [r4, #3976]	; 0xf88

    /* Initialize context */
    if (NULL != context)
100042d6:	b162      	cbz	r2, 100042f2 <Cy_SCB_UART_Init+0x246>
    {
        context->rxStatus  = 0UL;
100042d8:	2300      	movs	r3, #0
        context->txStatus  = 0UL;

        context->rxRingBuf = NULL;
        context->rxRingBufSize = 0UL;
100042da:	e9c2 3302 	strd	r3, r3, [r2, #8]
        context->rxStatus  = 0UL;
100042de:	6053      	str	r3, [r2, #4]

        context->rxBufIdx  = 0UL;
        context->txLeftToTransmit = 0UL;

        context->cbEvents = NULL;
100042e0:	6353      	str	r3, [r2, #52]	; 0x34
        context->txStatus  = 0UL;
100042e2:	6013      	str	r3, [r2, #0]
        context->rxBufIdx  = 0UL;
100042e4:	6213      	str	r3, [r2, #32]
        context->txLeftToTransmit = 0UL;
100042e6:	62d3      	str	r3, [r2, #44]	; 0x2c
        context->irdaEnableLowPowerReceiver = config->irdaEnableLowPowerReceiver;
100042e8:	7f8b      	ldrb	r3, [r1, #30]
100042ea:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

    #if !defined(NDEBUG)
        /* Put an initialization key into the initKey variable to verify
        * context initialization in the transfer API.
        */
        context->initKey = CY_SCB_UART_INIT_KEY;
100042ee:	4b08      	ldr	r3, [pc, #32]	; (10004310 <Cy_SCB_UART_Init+0x264>)
100042f0:	6393      	str	r3, [r2, #56]	; 0x38
    #endif /* !(NDEBUG) */
    }

    return CY_SCB_UART_SUCCESS;
100042f2:	2000      	movs	r0, #0
}
100042f4:	bd38      	pop	{r3, r4, r5, pc}
    CY_ASSERT_L2(CY_SCB_UART_IS_OVERSAMPLE_VALID  (config->oversample, config->uartMode, config->irdaEnableLowPowerReceiver));
100042f6:	7f8b      	ldrb	r3, [r1, #30]
100042f8:	2b00      	cmp	r3, #0
100042fa:	f43f af01 	beq.w	10004100 <Cy_SCB_UART_Init+0x54>
100042fe:	684b      	ldr	r3, [r1, #4]
10004300:	3b01      	subs	r3, #1
10004302:	2b06      	cmp	r3, #6
10004304:	e6fa      	b.n	100040fc <Cy_SCB_UART_Init+0x50>
                    _BOOL2FLD(SCB_RX_CTRL_MEDIAN, ((config->enableInputFilter) || \
10004306:	f44f 7000 	mov.w	r0, #512	; 0x200
1000430a:	e775      	b.n	100041f8 <Cy_SCB_UART_Init+0x14c>
        return CY_SCB_UART_BAD_PARAM;
1000430c:	4801      	ldr	r0, [pc, #4]	; (10004314 <Cy_SCB_UART_Init+0x268>)
1000430e:	e7f1      	b.n	100042f4 <Cy_SCB_UART_Init+0x248>
10004310:	00abcdef 	.word	0x00abcdef
10004314:	00aa6001 	.word	0x00aa6001

10004318 <Cy_IPC_Drv_GetIpcBaseAddress>:
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_SendMsgWord
*
*******************************************************************************/
__STATIC_INLINE IPC_STRUCT_Type* Cy_IPC_Drv_GetIpcBaseAddress (uint32_t ipcIndex)
{
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10004318:	4b06      	ldr	r3, [pc, #24]	; (10004334 <Cy_IPC_Drv_GetIpcBaseAddress+0x1c>)
1000431a:	681a      	ldr	r2, [r3, #0]
1000431c:	f892 2033 	ldrb.w	r2, [r2, #51]	; 0x33
10004320:	4282      	cmp	r2, r0
10004322:	d800      	bhi.n	10004326 <Cy_IPC_Drv_GetIpcBaseAddress+0xe>
10004324:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
10004326:	681b      	ldr	r3, [r3, #0]
10004328:	f8b3 20ba 	ldrh.w	r2, [r3, #186]	; 0xba
1000432c:	6a1b      	ldr	r3, [r3, #32]
}
1000432e:	fb00 3002 	mla	r0, r0, r2, r3
10004332:	4770      	bx	lr
10004334:	08003550 	.word	0x08003550

10004338 <Cy_Flash_ProcessOpcode>:
*******************************************************************************/
static cy_en_flashdrv_status_t Cy_Flash_ProcessOpcode(uint32_t opcode)
{
    cy_en_flashdrv_status_t result;

    switch (opcode)
10004338:	4b20      	ldr	r3, [pc, #128]	; (100043bc <Cy_Flash_ProcessOpcode+0x84>)
1000433a:	4298      	cmp	r0, r3
1000433c:	d030      	beq.n	100043a0 <Cy_Flash_ProcessOpcode+0x68>
1000433e:	d824      	bhi.n	1000438a <Cy_Flash_ProcessOpcode+0x52>
10004340:	2880      	cmp	r0, #128	; 0x80
10004342:	d030      	beq.n	100043a6 <Cy_Flash_ProcessOpcode+0x6e>
10004344:	d814      	bhi.n	10004370 <Cy_Flash_ProcessOpcode+0x38>
10004346:	2810      	cmp	r0, #16
10004348:	d02f      	beq.n	100043aa <Cy_Flash_ProcessOpcode+0x72>
1000434a:	2840      	cmp	r0, #64	; 0x40
1000434c:	d02f      	beq.n	100043ae <Cy_Flash_ProcessOpcode+0x76>
            result = CY_FLASH_DRV_INVALID_INPUT_PARAMETERS;
            break;
        }
        default:
        {
            result = CY_FLASH_DRV_ERR_UNC;
1000434e:	4b1c      	ldr	r3, [pc, #112]	; (100043c0 <Cy_Flash_ProcessOpcode+0x88>)
10004350:	2800      	cmp	r0, #0
10004352:	bf18      	it	ne
10004354:	4618      	movne	r0, r3
10004356:	4770      	bx	lr
    switch (opcode)
10004358:	f100 5080 	add.w	r0, r0, #268435456	; 0x10000000
1000435c:	3801      	subs	r0, #1
1000435e:	2804      	cmp	r0, #4
10004360:	d818      	bhi.n	10004394 <Cy_Flash_ProcessOpcode+0x5c>
10004362:	e8df f000 	tbb	[pc, r0]
10004366:	1726      	.short	0x1726
10004368:	1903      	.short	0x1903
1000436a:	1b          	.byte	0x1b
1000436b:	00          	.byte	0x00
            result = CY_FLASH_DRV_INVALID_FM_PL;
1000436c:	4815      	ldr	r0, [pc, #84]	; (100043c4 <Cy_Flash_ProcessOpcode+0x8c>)
1000436e:	4770      	bx	lr
    switch (opcode)
10004370:	4b15      	ldr	r3, [pc, #84]	; (100043c8 <Cy_Flash_ProcessOpcode+0x90>)
10004372:	4298      	cmp	r0, r3
10004374:	d00f      	beq.n	10004396 <Cy_Flash_ProcessOpcode+0x5e>
10004376:	f1b0 4f20 	cmp.w	r0, #2684354560	; 0xa0000000
1000437a:	d01d      	beq.n	100043b8 <Cy_Flash_ProcessOpcode+0x80>
            result = CY_FLASH_DRV_ERR_UNC;
1000437c:	4a10      	ldr	r2, [pc, #64]	; (100043c0 <Cy_Flash_ProcessOpcode+0x88>)
1000437e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
10004382:	bf0c      	ite	eq
10004384:	4618      	moveq	r0, r3
10004386:	4610      	movne	r0, r2
10004388:	4770      	bx	lr
    switch (opcode)
1000438a:	f100 5380 	add.w	r3, r0, #268435456	; 0x10000000
1000438e:	3b01      	subs	r3, #1
10004390:	2b04      	cmp	r3, #4
10004392:	d9e1      	bls.n	10004358 <Cy_Flash_ProcessOpcode+0x20>
            result = CY_FLASH_DRV_ERR_UNC;
10004394:	480a      	ldr	r0, [pc, #40]	; (100043c0 <Cy_Flash_ProcessOpcode+0x88>)
            break;
        }
    }

    return (result);
}
10004396:	4770      	bx	lr
            result = CY_FLASH_DRV_INVALID_FLASH_ADDR;
10004398:	480c      	ldr	r0, [pc, #48]	; (100043cc <Cy_Flash_ProcessOpcode+0x94>)
            break;
1000439a:	4770      	bx	lr
            result = CY_FLASH_DRV_ROW_PROTECTED;
1000439c:	480c      	ldr	r0, [pc, #48]	; (100043d0 <Cy_Flash_ProcessOpcode+0x98>)
            break;
1000439e:	4770      	bx	lr
            result = CY_FLASH_DRV_PROGRESS_NO_ERROR;
100043a0:	f44f 00a0 	mov.w	r0, #5242880	; 0x500000
100043a4:	4770      	bx	lr
            result = CY_FLASH_DRV_IPC_BUSY;
100043a6:	480b      	ldr	r0, [pc, #44]	; (100043d4 <Cy_Flash_ProcessOpcode+0x9c>)
100043a8:	4770      	bx	lr
            result = CY_FLASH_DRV_OPERATION_STARTED;
100043aa:	480b      	ldr	r0, [pc, #44]	; (100043d8 <Cy_Flash_ProcessOpcode+0xa0>)
100043ac:	4770      	bx	lr
            result = CY_FLASH_DRV_OPCODE_BUSY;
100043ae:	480b      	ldr	r0, [pc, #44]	; (100043dc <Cy_Flash_ProcessOpcode+0xa4>)
100043b0:	4770      	bx	lr
    switch (opcode)
100043b2:	f44f 00a4 	mov.w	r0, #5373952	; 0x520000
100043b6:	4770      	bx	lr
            result = CY_FLASH_DRV_SUCCESS;
100043b8:	2000      	movs	r0, #0
100043ba:	4770      	bx	lr
100043bc:	a0000009 	.word	0xa0000009
100043c0:	005200ff 	.word	0x005200ff
100043c4:	00520001 	.word	0x00520001
100043c8:	00520006 	.word	0x00520006
100043cc:	00520002 	.word	0x00520002
100043d0:	00520003 	.word	0x00520003
100043d4:	00520005 	.word	0x00520005
100043d8:	00500001 	.word	0x00500001
100043dc:	00500002 	.word	0x00500002

100043e0 <Cy_Flash_OperationStatus>:
* \return Returns the status of the Flash operation
* (see \ref cy_en_flashdrv_status_t).
*
*******************************************************************************/
static cy_en_flashdrv_status_t Cy_Flash_OperationStatus(void)
{
100043e0:	b508      	push	{r3, lr}
    cy_en_flashdrv_status_t result = CY_FLASH_DRV_OPCODE_BUSY;

    /* Checks if the IPC structure is not locked */
    if (Cy_IPC_Drv_IsLockAcquired(Cy_IPC_Drv_GetIpcBaseAddress(CY_IPC_CHAN_SYSCALL)) == false)
100043e2:	2001      	movs	r0, #1
100043e4:	f7ff ff98 	bl	10004318 <Cy_IPC_Drv_GetIpcBaseAddress>
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_LockAcquire
*
*******************************************************************************/
__STATIC_INLINE bool Cy_IPC_Drv_IsLockAcquired (IPC_STRUCT_Type const * base)
{
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
100043e8:	4b0a      	ldr	r3, [pc, #40]	; (10004414 <Cy_Flash_OperationStatus+0x34>)
100043ea:	6819      	ldr	r1, [r3, #0]
100043ec:	f8d1 30bc 	ldr.w	r3, [r1, #188]	; 0xbc
100043f0:	58c3      	ldr	r3, [r0, r3]
100043f2:	2b00      	cmp	r3, #0
100043f4:	db0b      	blt.n	1000440e <Cy_Flash_OperationStatus+0x2e>
    {
        /* The result of SROM API calling is returned to the driver context */
        result = Cy_Flash_ProcessOpcode(flashContext.opcode);
100043f6:	4b08      	ldr	r3, [pc, #32]	; (10004418 <Cy_Flash_OperationStatus+0x38>)
100043f8:	6818      	ldr	r0, [r3, #0]
100043fa:	f7ff ff9d 	bl	10004338 <Cy_Flash_ProcessOpcode>
            CY_PRA_REG32_SET(CY_PRA_INDX_FLASHC_FLASH_CMD, FLASHC_FLASH_CMD_INV_Msk);
            while (CY_PRA_REG32_GET(CY_PRA_INDX_FLASHC_FLASH_CMD) != 0U)
            {
            }
        #else
            FLASHC_FLASH_CMD = FLASHC_FLASH_CMD_INV_Msk;
100043fe:	684b      	ldr	r3, [r1, #4]
10004400:	2201      	movs	r2, #1
10004402:	609a      	str	r2, [r3, #8]
            while (FLASHC_FLASH_CMD != 0U)
10004404:	684a      	ldr	r2, [r1, #4]
10004406:	6893      	ldr	r3, [r2, #8]
10004408:	2b00      	cmp	r3, #0
1000440a:	d1fc      	bne.n	10004406 <Cy_Flash_OperationStatus+0x26>
            }
        #endif /* CY_CPU_CORTEX_M4 && defined (CY_DEVICE_SECURE) */
    }

    return (result);
}
1000440c:	bd08      	pop	{r3, pc}
    cy_en_flashdrv_status_t result = CY_FLASH_DRV_OPCODE_BUSY;
1000440e:	4803      	ldr	r0, [pc, #12]	; (1000441c <Cy_Flash_OperationStatus+0x3c>)
    return (result);
10004410:	e7fc      	b.n	1000440c <Cy_Flash_OperationStatus+0x2c>
10004412:	bf00      	nop
10004414:	08003550 	.word	0x08003550
10004418:	080036d4 	.word	0x080036d4
1000441c:	00500002 	.word	0x00500002

10004420 <Cy_GPIO_SetHSIOM>:

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10004420:	2907      	cmp	r1, #7
{
10004422:	b5f0      	push	{r4, r5, r6, r7, lr}
    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10004424:	d900      	bls.n	10004428 <Cy_GPIO_SetHSIOM+0x8>
10004426:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_HSIOM_VALID(value));
10004428:	2a1f      	cmp	r2, #31
1000442a:	d900      	bls.n	1000442e <Cy_GPIO_SetHSIOM+0xe>
1000442c:	be01      	bkpt	0x0001

    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
1000442e:	4b12      	ldr	r3, [pc, #72]	; (10004478 <Cy_GPIO_SetHSIOM+0x58>)
10004430:	681c      	ldr	r4, [r3, #0]
10004432:	69a3      	ldr	r3, [r4, #24]
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
10004434:	6966      	ldr	r6, [r4, #20]
    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
10004436:	1ac3      	subs	r3, r0, r3
10004438:	09db      	lsrs	r3, r3, #7

    #if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
        pinType = CY_PRA_GET_PIN_PROT_TYPE(base, pinNum);
    #endif

    if(pinNum < CY_GPIO_PRT_HALF)
1000443a:	2903      	cmp	r1, #3
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
1000443c:	ea4f 1703 	mov.w	r7, r3, lsl #4
            tempReg = 0UL;
        }
    #else
        tempReg = HSIOM_PRT_PORT_SEL0(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
    #endif
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
10004440:	f002 051f 	and.w	r5, r2, #31
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
10004444:	eb06 1303 	add.w	r3, r6, r3, lsl #4
    if(pinNum < CY_GPIO_PRT_HALF)
10004448:	f04f 001f 	mov.w	r0, #31
1000444c:	d809      	bhi.n	10004462 <Cy_GPIO_SetHSIOM+0x42>
        tempReg = HSIOM_PRT_PORT_SEL0(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
1000444e:	59bb      	ldr	r3, [r7, r6]
10004450:	00cc      	lsls	r4, r1, #3
10004452:	40a0      	lsls	r0, r4
10004454:	ea23 0300 	bic.w	r3, r3, r0
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
10004458:	fa05 f104 	lsl.w	r1, r5, r4
1000445c:	430b      	orrs	r3, r1
        else
        {
            /* Secure PIN can't be modified using register policy */
        }
    #else
        HSIOM_PRT_PORT_SEL0(portAddrHSIOM) = hsiomReg;
1000445e:	51bb      	str	r3, [r7, r6]
        }
    #else
        HSIOM_PRT_PORT_SEL1(portAddrHSIOM) = hsiomReg;
    #endif
    }
}
10004460:	bdf0      	pop	{r4, r5, r6, r7, pc}
        pinNum -= CY_GPIO_PRT_HALF;
10004462:	3904      	subs	r1, #4
        tempReg = HSIOM_PRT_PORT_SEL1(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
10004464:	685a      	ldr	r2, [r3, #4]
10004466:	00c9      	lsls	r1, r1, #3
10004468:	4088      	lsls	r0, r1
1000446a:	ea22 0200 	bic.w	r2, r2, r0
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
1000446e:	fa05 f101 	lsl.w	r1, r5, r1
10004472:	430a      	orrs	r2, r1
        HSIOM_PRT_PORT_SEL1(portAddrHSIOM) = hsiomReg;
10004474:	605a      	str	r2, [r3, #4]
}
10004476:	e7f3      	b.n	10004460 <Cy_GPIO_SetHSIOM+0x40>
10004478:	08003550 	.word	0x08003550

1000447c <Cy_GPIO_Pin_FastInit>:
{
1000447c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
1000447e:	2907      	cmp	r1, #7
{
10004480:	4615      	mov	r5, r2
10004482:	4607      	mov	r7, r0
10004484:	f89d 2018 	ldrb.w	r2, [sp, #24]
10004488:	460c      	mov	r4, r1
1000448a:	461e      	mov	r6, r3
    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
1000448c:	d900      	bls.n	10004490 <Cy_GPIO_Pin_FastInit+0x14>
1000448e:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_DM_VALID(driveMode));
10004490:	2d0f      	cmp	r5, #15
10004492:	d803      	bhi.n	1000449c <Cy_GPIO_Pin_FastInit+0x20>
10004494:	f025 0308 	bic.w	r3, r5, #8
10004498:	2b01      	cmp	r3, #1
1000449a:	d100      	bne.n	1000449e <Cy_GPIO_Pin_FastInit+0x22>
1000449c:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(outVal));
1000449e:	2e01      	cmp	r6, #1
100044a0:	d900      	bls.n	100044a4 <Cy_GPIO_Pin_FastInit+0x28>
100044a2:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_HSIOM_VALID(hsiom));
100044a4:	2a1f      	cmp	r2, #31
100044a6:	d900      	bls.n	100044aa <Cy_GPIO_Pin_FastInit+0x2e>
100044a8:	be01      	bkpt	0x0001
    Cy_GPIO_SetHSIOM(base, pinNum, hsiom);
100044aa:	4621      	mov	r1, r4
100044ac:	4638      	mov	r0, r7
100044ae:	f7ff ffb7 	bl	10004420 <Cy_GPIO_SetHSIOM>
    tempReg = (GPIO_PRT_OUT(base) & ~(CY_GPIO_OUT_MASK << pinNum));
100044b2:	683b      	ldr	r3, [r7, #0]
100044b4:	2201      	movs	r2, #1
100044b6:	40a2      	lsls	r2, r4
    GPIO_PRT_OUT(base) = tempReg | ((outVal & CY_GPIO_OUT_MASK) << pinNum);
100044b8:	f006 0601 	and.w	r6, r6, #1
    tempReg = (GPIO_PRT_OUT(base) & ~(CY_GPIO_OUT_MASK << pinNum));
100044bc:	ea23 0302 	bic.w	r3, r3, r2
    GPIO_PRT_OUT(base) = tempReg | ((outVal & CY_GPIO_OUT_MASK) << pinNum);
100044c0:	40a6      	lsls	r6, r4
100044c2:	4333      	orrs	r3, r6
100044c4:	603b      	str	r3, [r7, #0]
    tempReg = (GPIO_PRT_CFG(base) & ~(CY_GPIO_CFG_DM_MASK << (pinNum << CY_GPIO_DRIVE_MODE_OFFSET)));
100044c6:	4b08      	ldr	r3, [pc, #32]	; (100044e8 <Cy_GPIO_Pin_FastInit+0x6c>)
100044c8:	681b      	ldr	r3, [r3, #0]
100044ca:	f893 1081 	ldrb.w	r1, [r3, #129]	; 0x81
100044ce:	00a4      	lsls	r4, r4, #2
100044d0:	587b      	ldr	r3, [r7, r1]
100044d2:	220f      	movs	r2, #15
100044d4:	40a2      	lsls	r2, r4
    GPIO_PRT_CFG(base) = tempReg | ((driveMode & CY_GPIO_CFG_DM_MASK) << (pinNum << CY_GPIO_DRIVE_MODE_OFFSET));
100044d6:	f005 050f 	and.w	r5, r5, #15
    tempReg = (GPIO_PRT_CFG(base) & ~(CY_GPIO_CFG_DM_MASK << (pinNum << CY_GPIO_DRIVE_MODE_OFFSET)));
100044da:	ea23 0302 	bic.w	r3, r3, r2
    GPIO_PRT_CFG(base) = tempReg | ((driveMode & CY_GPIO_CFG_DM_MASK) << (pinNum << CY_GPIO_DRIVE_MODE_OFFSET));
100044de:	40a5      	lsls	r5, r4
100044e0:	432b      	orrs	r3, r5
100044e2:	507b      	str	r3, [r7, r1]
}
100044e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
100044e6:	bf00      	nop
100044e8:	08003550 	.word	0x08003550

100044ec <Cy_GPIO_GetHSIOM>:
    HSIOM_PRT_V1_Type* portAddrHSIOM;
#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
100044ec:	2907      	cmp	r1, #7
100044ee:	4b0f      	ldr	r3, [pc, #60]	; (1000452c <Cy_GPIO_GetHSIOM+0x40>)
100044f0:	d90a      	bls.n	10004508 <Cy_GPIO_GetHSIOM+0x1c>
100044f2:	be01      	bkpt	0x0001

    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
100044f4:	681b      	ldr	r3, [r3, #0]
100044f6:	699a      	ldr	r2, [r3, #24]
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
100044f8:	695b      	ldr	r3, [r3, #20]
    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
100044fa:	1a80      	subs	r0, r0, r2
100044fc:	09c0      	lsrs	r0, r0, #7
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
100044fe:	eb03 1000 	add.w	r0, r3, r0, lsl #4
        {
            /* secure pin */
            tempReg = 0UL;
        }
    #else
        tempReg = HSIOM_PRT_PORT_SEL1(portAddrHSIOM);
10004502:	6840      	ldr	r0, [r0, #4]
        pinNum -= CY_GPIO_PRT_HALF;
10004504:	3904      	subs	r1, #4
10004506:	e00b      	b.n	10004520 <Cy_GPIO_GetHSIOM+0x34>
    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
10004508:	681b      	ldr	r3, [r3, #0]
1000450a:	699a      	ldr	r2, [r3, #24]
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
1000450c:	695b      	ldr	r3, [r3, #20]
    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
1000450e:	1a80      	subs	r0, r0, r2
10004510:	09c0      	lsrs	r0, r0, #7
    if(pinNum < CY_GPIO_PRT_HALF)
10004512:	2903      	cmp	r1, #3
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
10004514:	ea4f 1200 	mov.w	r2, r0, lsl #4
10004518:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    if(pinNum < CY_GPIO_PRT_HALF)
1000451c:	d8f1      	bhi.n	10004502 <Cy_GPIO_GetHSIOM+0x16>
        tempReg = HSIOM_PRT_PORT_SEL0(portAddrHSIOM);
1000451e:	58d0      	ldr	r0, [r2, r3]
    #endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2) */

        returnValue = (tempReg >> (pinNum << CY_GPIO_HSIOM_OFFSET)) & CY_GPIO_HSIOM_MASK;
10004520:	00c9      	lsls	r1, r1, #3
10004522:	40c8      	lsrs	r0, r1
10004524:	f000 001f 	and.w	r0, r0, #31
    }

    return (en_hsiom_sel_t)returnValue;
}
10004528:	4770      	bx	lr
1000452a:	bf00      	nop
1000452c:	08003550 	.word	0x08003550

10004530 <Cy_GPIO_SetInterruptEdge>:

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10004530:	2908      	cmp	r1, #8
{
10004532:	b530      	push	{r4, r5, lr}
    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10004534:	d900      	bls.n	10004538 <Cy_GPIO_SetInterruptEdge+0x8>
10004536:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_INT_EDGE_VALID(value));
10004538:	2a03      	cmp	r2, #3
1000453a:	d900      	bls.n	1000453e <Cy_GPIO_SetInterruptEdge+0xe>
1000453c:	be01      	bkpt	0x0001
    }
#else
    tempReg = GPIO_PRT_INTR_CFG(base) & ~(CY_GPIO_INTR_EDGE_MASK << pinLoc);
#endif /* defined(CY_DEVICE_PSOC6ABLE2) */
#else
    tempReg = GPIO_PRT_INTR_CFG(base) & ~(CY_GPIO_INTR_EDGE_MASK << pinLoc);
1000453e:	4b08      	ldr	r3, [pc, #32]	; (10004560 <Cy_GPIO_SetInterruptEdge+0x30>)
10004540:	681b      	ldr	r3, [r3, #0]
10004542:	f893 5080 	ldrb.w	r5, [r3, #128]	; 0x80
    pinLoc = pinNum << CY_GPIO_INTR_CFG_OFFSET;
10004546:	0049      	lsls	r1, r1, #1
    tempReg = GPIO_PRT_INTR_CFG(base) & ~(CY_GPIO_INTR_EDGE_MASK << pinLoc);
10004548:	5943      	ldr	r3, [r0, r5]
1000454a:	2403      	movs	r4, #3
1000454c:	408c      	lsls	r4, r1
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    intrCfg = tempReg | ((value & CY_GPIO_INTR_EDGE_MASK) << pinLoc);
1000454e:	f002 0203 	and.w	r2, r2, #3
    tempReg = GPIO_PRT_INTR_CFG(base) & ~(CY_GPIO_INTR_EDGE_MASK << pinLoc);
10004552:	ea23 0304 	bic.w	r3, r3, r4
    intrCfg = tempReg | ((value & CY_GPIO_INTR_EDGE_MASK) << pinLoc);
10004556:	408a      	lsls	r2, r1
10004558:	4313      	orrs	r3, r2
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_INTR_CFG(base) = intrCfg;
1000455a:	5143      	str	r3, [r0, r5]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
1000455c:	bd30      	pop	{r4, r5, pc}
1000455e:	bf00      	nop
10004560:	08003550 	.word	0x08003550

10004564 <Cy_GPIO_GetInterruptEdge>:
    uint32_t tempReg;
#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2) */

    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10004564:	2908      	cmp	r1, #8
10004566:	d900      	bls.n	1000456a <Cy_GPIO_GetInterruptEdge+0x6>
10004568:	be01      	bkpt	0x0001
    {
        /* secure pin */
        tempReg = 0UL;
    }
#else
    tempReg = GPIO_PRT_INTR_CFG(base);
1000456a:	4b05      	ldr	r3, [pc, #20]	; (10004580 <Cy_GPIO_GetInterruptEdge+0x1c>)
1000456c:	681b      	ldr	r3, [r3, #0]
1000456e:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
10004572:	58c0      	ldr	r0, [r0, r3]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2) */

    return (tempReg >> (pinNum << CY_GPIO_INTR_CFG_OFFSET)) & CY_GPIO_INTR_EDGE_MASK;
10004574:	0049      	lsls	r1, r1, #1
10004576:	40c8      	lsrs	r0, r1
}
10004578:	f000 0003 	and.w	r0, r0, #3
1000457c:	4770      	bx	lr
1000457e:	bf00      	nop
10004580:	08003550 	.word	0x08003550

10004584 <Cy_IPC_Drv_LockRelease>:
10004584:	4b08      	ldr	r3, [pc, #32]	; (100045a8 <Cy_IPC_Drv_LockRelease+0x24>)
10004586:	681b      	ldr	r3, [r3, #0]
10004588:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
1000458c:	58c3      	ldr	r3, [r0, r3]
cy_en_ipcdrv_status_t Cy_IPC_Drv_LockRelease (IPC_STRUCT_Type* base, uint32_t releaseEventIntr)
{
    cy_en_ipcdrv_status_t retStatus;

    /* Check to make sure the IPC is Acquired */
    if( Cy_IPC_Drv_IsLockAcquired(base) )
1000458e:	2b00      	cmp	r3, #0
10004590:	da07      	bge.n	100045a2 <Cy_IPC_Drv_LockRelease+0x1e>
    CY_ASSERT_L1(0UL == (notifyEventIntr  & ~(uint32_t)(IPC_INTR_STRUCT_INTR_RELEASE_Msk)));
10004592:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
10004596:	d300      	bcc.n	1000459a <Cy_IPC_Drv_LockRelease+0x16>
10004598:	be01      	bkpt	0x0001
    REG_IPC_STRUCT_RELEASE(base) = _VAL2FLD(IPC_INTR_STRUCT_INTR_RELEASE, notifyEventIntr);
1000459a:	b289      	uxth	r1, r1
1000459c:	6041      	str	r1, [r0, #4]
    {
        /* The IPC was acquired, release the IPC channel */
        Cy_IPC_Drv_ReleaseNotify(base, releaseEventIntr);

        retStatus = CY_IPC_DRV_SUCCESS;
1000459e:	2000      	movs	r0, #0
}
100045a0:	4770      	bx	lr
    }
    else   /* The IPC channel was already released (not acquired) */
    {
        retStatus = CY_IPC_DRV_ERROR;
100045a2:	4802      	ldr	r0, [pc, #8]	; (100045ac <Cy_IPC_Drv_LockRelease+0x28>)
    }

    return (retStatus);
}
100045a4:	4770      	bx	lr
100045a6:	bf00      	nop
100045a8:	08003550 	.word	0x08003550
100045ac:	008a0001 	.word	0x008a0001

100045b0 <Cy_IPC_Drv_SendMsgWord>:
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_LockAcquire
*
*******************************************************************************/
__STATIC_INLINE cy_en_ipcdrv_status_t Cy_IPC_Drv_LockAcquire (IPC_STRUCT_Type const * base)
{
    return ( 0UL != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_ACQUIRE(base))) ? CY_IPC_DRV_SUCCESS : CY_IPC_DRV_ERROR;
100045b0:	6803      	ldr	r3, [r0, #0]
100045b2:	2b00      	cmp	r3, #0
100045b4:	da08      	bge.n	100045c8 <Cy_IPC_Drv_SendMsgWord+0x18>
    CY_ASSERT_L1(0UL == (notifyEventIntr  & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
100045b6:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
    REG_IPC_STRUCT_DATA(base) = dataValue;
100045ba:	60c2      	str	r2, [r0, #12]
    CY_ASSERT_L1(0UL == (notifyEventIntr  & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
100045bc:	d300      	bcc.n	100045c0 <Cy_IPC_Drv_SendMsgWord+0x10>
100045be:	be01      	bkpt	0x0001
    REG_IPC_STRUCT_NOTIFY(base) = _VAL2FLD(IPC_STRUCT_NOTIFY_INTR_NOTIFY, notifyEventIntr);
100045c0:	b289      	uxth	r1, r1
100045c2:	6081      	str	r1, [r0, #8]
        /* If the channel was acquired, send the message. */
        Cy_IPC_Drv_WriteDataValue(base, message);

        Cy_IPC_Drv_AcquireNotify(base, notifyEventIntr);

        retStatus = CY_IPC_DRV_SUCCESS;
100045c4:	2000      	movs	r0, #0
}
100045c6:	4770      	bx	lr
    }
    else
    {
        /* Channel was already acquired, return Error */
        retStatus = CY_IPC_DRV_ERROR;
100045c8:	4800      	ldr	r0, [pc, #0]	; (100045cc <Cy_IPC_Drv_SendMsgWord+0x1c>)
    }
    return (retStatus);
}
100045ca:	4770      	bx	lr
100045cc:	008a0001 	.word	0x008a0001

100045d0 <Cy_IPC_Drv_ReadMsgWord>:
*******************************************************************************/
cy_en_ipcdrv_status_t  Cy_IPC_Drv_ReadMsgWord (IPC_STRUCT_Type const * base, uint32_t * message)
{
    cy_en_ipcdrv_status_t retStatus;

    CY_ASSERT_L1(NULL != message);
100045d0:	b901      	cbnz	r1, 100045d4 <Cy_IPC_Drv_ReadMsgWord+0x4>
100045d2:	be01      	bkpt	0x0001
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
100045d4:	4b05      	ldr	r3, [pc, #20]	; (100045ec <Cy_IPC_Drv_ReadMsgWord+0x1c>)
100045d6:	681b      	ldr	r3, [r3, #0]
100045d8:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
100045dc:	58c3      	ldr	r3, [r0, r3]

    if ( Cy_IPC_Drv_IsLockAcquired(base) )
100045de:	2b00      	cmp	r3, #0
    return REG_IPC_STRUCT_DATA(base);
100045e0:	bfbd      	ittte	lt
100045e2:	68c3      	ldrlt	r3, [r0, #12]
    {
        /* The channel is locked; message is valid. */
        *message = Cy_IPC_Drv_ReadDataValue(base);
100045e4:	600b      	strlt	r3, [r1, #0]

        retStatus = CY_IPC_DRV_SUCCESS;
100045e6:	2000      	movlt	r0, #0
    }
    else
    {
        /* The channel is not locked so channel is invalid. */
        retStatus = CY_IPC_DRV_ERROR;
100045e8:	4801      	ldrge	r0, [pc, #4]	; (100045f0 <Cy_IPC_Drv_ReadMsgWord+0x20>)
    }
    return(retStatus);
}
100045ea:	4770      	bx	lr
100045ec:	08003550 	.word	0x08003550
100045f0:	008a0001 	.word	0x008a0001

100045f4 <Cy_IPC_Pipe_Config>:
*
*******************************************************************************/
void Cy_IPC_Pipe_Config(cy_stc_ipc_pipe_ep_t * theEpArray)
{
    /* Keep copy of this endpoint */
    if (cy_ipc_pipe_epArray == NULL)
100045f4:	4b02      	ldr	r3, [pc, #8]	; (10004600 <Cy_IPC_Pipe_Config+0xc>)
100045f6:	681a      	ldr	r2, [r3, #0]
100045f8:	b902      	cbnz	r2, 100045fc <Cy_IPC_Pipe_Config+0x8>
    {
        cy_ipc_pipe_epArray = theEpArray;
100045fa:	6018      	str	r0, [r3, #0]
    }
}
100045fc:	4770      	bx	lr
100045fe:	bf00      	nop
10004600:	080036e8 	.word	0x080036e8

10004604 <Cy_IPC_Pipe_EndpointInit>:
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Pipe_EndpointInit
*
*******************************************************************************/
void Cy_IPC_Pipe_EndpointInit(uint32_t epAddr, cy_ipc_pipe_callback_array_ptr_t cbArray,
                              uint32_t cbCnt, uint32_t epConfig, cy_stc_sysint_t const *epInterrupt)
{
10004604:	b5f0      	push	{r4, r5, r6, r7, lr}
    cy_stc_ipc_pipe_ep_t * endpoint;

    CY_ASSERT_L1(NULL != cy_ipc_pipe_epArray);
10004606:	4c21      	ldr	r4, [pc, #132]	; (1000468c <Cy_IPC_Pipe_EndpointInit+0x88>)
{
10004608:	9f05      	ldr	r7, [sp, #20]
    CY_ASSERT_L1(NULL != cy_ipc_pipe_epArray);
1000460a:	6825      	ldr	r5, [r4, #0]
1000460c:	b905      	cbnz	r5, 10004610 <Cy_IPC_Pipe_EndpointInit+0xc>
1000460e:	be01      	bkpt	0x0001

    endpoint = &cy_ipc_pipe_epArray[epAddr];
10004610:	252c      	movs	r5, #44	; 0x2c
10004612:	4368      	muls	r0, r5
10004614:	6825      	ldr	r5, [r4, #0]

    /* Extract the channel, interrupt and interrupt mask */
    endpoint->ipcChan         = _FLD2VAL(CY_IPC_PIPE_CFG_CHAN,  epConfig);
10004616:	b2de      	uxtb	r6, r3
    endpoint = &cy_ipc_pipe_epArray[epAddr];
10004618:	182c      	adds	r4, r5, r0
    endpoint->ipcChan         = _FLD2VAL(CY_IPC_PIPE_CFG_CHAN,  epConfig);
1000461a:	502e      	str	r6, [r5, r0]
    endpoint->intrChan        = _FLD2VAL(CY_IPC_PIPE_CFG_INTR,  epConfig);
1000461c:	f3c3 2007 	ubfx	r0, r3, #8, #8
    endpoint->pipeIntMask     = _FLD2VAL(CY_IPC_PIPE_CFG_IMASK, epConfig);
10004620:	0c1b      	lsrs	r3, r3, #16
10004622:	60a3      	str	r3, [r4, #8]
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10004624:	4b1a      	ldr	r3, [pc, #104]	; (10004690 <Cy_IPC_Pipe_EndpointInit+0x8c>)
    endpoint->intrChan        = _FLD2VAL(CY_IPC_PIPE_CFG_INTR,  epConfig);
10004626:	6060      	str	r0, [r4, #4]
10004628:	6818      	ldr	r0, [r3, #0]
1000462a:	f890 0033 	ldrb.w	r0, [r0, #51]	; 0x33
1000462e:	4286      	cmp	r6, r0
10004630:	d300      	bcc.n	10004634 <Cy_IPC_Pipe_EndpointInit+0x30>
10004632:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
10004634:	6818      	ldr	r0, [r3, #0]
10004636:	f8b0 c0ba 	ldrh.w	ip, [r0, #186]	; 0xba
1000463a:	6a05      	ldr	r5, [r0, #32]
1000463c:	fb06 550c 	mla	r5, r6, ip, r5

    /* Assign IPC channel to this endpoint */
    endpoint->ipcPtr   = Cy_IPC_Drv_GetIpcBaseAddress (endpoint->ipcChan);
10004640:	6125      	str	r5, [r4, #16]
    CY_ASSERT_L1(CY_IPC_INTERRUPTS > ipcIntrIndex);
10004642:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34

    /* Assign interrupt structure to endpoint and Initialize the interrupt mask for this endpoint */
    endpoint->ipcIntrPtr = Cy_IPC_Drv_GetIntrBaseAddr(endpoint->intrChan);
10004646:	6865      	ldr	r5, [r4, #4]
10004648:	4285      	cmp	r5, r0
1000464a:	d300      	bcc.n	1000464e <Cy_IPC_Pipe_EndpointInit+0x4a>
1000464c:	be01      	bkpt	0x0001
    return ( (IPC_INTR_STRUCT_Type*) CY_IPC_INTR_STRUCT_PTR(ipcIntrIndex));
1000464e:	681b      	ldr	r3, [r3, #0]

    /* Only allow notify and release interrupts from endpoints in this pipe. */
    Cy_IPC_Drv_SetInterruptMask(endpoint->ipcIntrPtr, endpoint->pipeIntMask, endpoint->pipeIntMask);
10004650:	68a6      	ldr	r6, [r4, #8]
10004652:	6a1b      	ldr	r3, [r3, #32]
10004654:	f105 0080 	add.w	r0, r5, #128	; 0x80
10004658:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    CY_ASSERT_L1(0UL == (ipcAcquireMask & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
1000465c:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
    endpoint->ipcIntrPtr = Cy_IPC_Drv_GetIntrBaseAddr(endpoint->intrChan);
10004660:	6160      	str	r0, [r4, #20]
10004662:	d301      	bcc.n	10004668 <Cy_IPC_Pipe_EndpointInit+0x64>
10004664:	be01      	bkpt	0x0001
10004666:	be01      	bkpt	0x0001
    REG_IPC_INTR_STRUCT_INTR_MASK(base) = _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_NOTIFY,  ipcAcquireMask) |
10004668:	eb03 1345 	add.w	r3, r3, r5, lsl #5
                      _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_RELEASE, ipcReleaseMask);
1000466c:	b2b0      	uxth	r0, r6
    REG_IPC_INTR_STRUCT_INTR_MASK(base) = _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_NOTIFY,  ipcAcquireMask) |
1000466e:	f241 0508 	movw	r5, #4104	; 0x1008
10004672:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
10004676:	5158      	str	r0, [r3, r5]

    /* Save the Client count and the callback array pointer */
    endpoint->clientCount   = cbCnt;
    endpoint->callbackArray = cbArray;
    endpoint->busy = CY_IPC_PIPE_ENDPOINT_NOTBUSY;
10004678:	2300      	movs	r3, #0
    endpoint->callbackArray = cbArray;
1000467a:	e9c4 2107 	strd	r2, r1, [r4, #28]
    endpoint->busy = CY_IPC_PIPE_ENDPOINT_NOTBUSY;
1000467e:	61a3      	str	r3, [r4, #24]

    if (NULL != epInterrupt)
10004680:	b117      	cbz	r7, 10004688 <Cy_IPC_Pipe_EndpointInit+0x84>
    {
        endpoint->pipeIntrSrc     = epInterrupt->intrSrc;
10004682:	f9b7 3000 	ldrsh.w	r3, [r7]
10004686:	81a3      	strh	r3, [r4, #12]
    }
}
10004688:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000468a:	bf00      	nop
1000468c:	080036e8 	.word	0x080036e8
10004690:	08003550 	.word	0x08003550

10004694 <Cy_IPC_Pipe_Init>:
{
10004694:	b5f0      	push	{r4, r5, r6, r7, lr}
    CY_ASSERT_L1(NULL != config);
10004696:	4604      	mov	r4, r0
{
10004698:	b085      	sub	sp, #20
    CY_ASSERT_L1(NULL != config);
1000469a:	b900      	cbnz	r0, 1000469e <Cy_IPC_Pipe_Init+0xa>
1000469c:	be01      	bkpt	0x0001
    CY_ASSERT_L2((uint32_t)(1UL << __NVIC_PRIO_BITS) > config->ep1ConfigData.ipcNotifierPriority);
1000469e:	69a3      	ldr	r3, [r4, #24]
100046a0:	2b07      	cmp	r3, #7
100046a2:	d900      	bls.n	100046a6 <Cy_IPC_Pipe_Init+0x12>
100046a4:	be01      	bkpt	0x0001
    CY_ASSERT_L1(NULL != config->endpointsCallbacksArray);
100046a6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
100046a8:	b903      	cbnz	r3, 100046ac <Cy_IPC_Pipe_Init+0x18>
100046aa:	be01      	bkpt	0x0001
    CY_ASSERT_L1(NULL != config->userPipeIsrHandler);
100046ac:	6b23      	ldr	r3, [r4, #48]	; 0x30
100046ae:	b903      	cbnz	r3, 100046b2 <Cy_IPC_Pipe_Init+0x1e>
100046b0:	be01      	bkpt	0x0001
    ipc_intr_cypipeConfig.intrSrc          = (IRQn_Type)((int32_t)cy_device->cpussIpc0Irq + (int32_t)epConfigDataA.ipcNotifierNumber);
100046b2:	4b16      	ldr	r3, [pc, #88]	; (1000470c <Cy_IPC_Pipe_Init+0x78>)
    epConfigDataA = config->ep1ConfigData;
100046b4:	69a2      	ldr	r2, [r4, #24]
    ipc_intr_cypipeConfig.intrSrc          = (IRQn_Type)((int32_t)cy_device->cpussIpc0Irq + (int32_t)epConfigDataA.ipcNotifierNumber);
100046b6:	6819      	ldr	r1, [r3, #0]
100046b8:	6963      	ldr	r3, [r4, #20]
100046ba:	8f09      	ldrh	r1, [r1, #56]	; 0x38
    ipc_intr_cypipeConfig.intrPriority     = epConfigDataA.ipcNotifierPriority;
100046bc:	9203      	str	r2, [sp, #12]
    Cy_IPC_Pipe_EndpointInit(epConfigDataA.epAddress,
100046be:	ad02      	add	r5, sp, #8
    epConfigDataB = config->ep0ConfigData;
100046c0:	e9d4 6703 	ldrd	r6, r7, [r4, #12]
    ipc_intr_cypipeConfig.intrSrc          = (IRQn_Type)((int32_t)cy_device->cpussIpc0Irq + (int32_t)epConfigDataA.ipcNotifierNumber);
100046c4:	440b      	add	r3, r1
    Cy_IPC_Pipe_EndpointInit(epConfigDataA.epAddress,
100046c6:	9500      	str	r5, [sp, #0]
100046c8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
100046ca:	6a20      	ldr	r0, [r4, #32]
    ipc_intr_cypipeConfig.intrSrc          = (IRQn_Type)((int32_t)cy_device->cpussIpc0Irq + (int32_t)epConfigDataA.ipcNotifierNumber);
100046cc:	f8ad 3008 	strh.w	r3, [sp, #8]
    Cy_IPC_Pipe_EndpointInit(epConfigDataA.epAddress,
100046d0:	e9d4 3209 	ldrd	r3, r2, [r4, #36]	; 0x24
100046d4:	f7ff ff96 	bl	10004604 <Cy_IPC_Pipe_EndpointInit>
    Cy_IPC_Pipe_EndpointInit(epConfigDataB.epAddress, NULL, 0UL, epConfigDataB.epConfig, NULL);
100046d8:	2200      	movs	r2, #0
100046da:	463b      	mov	r3, r7
100046dc:	4611      	mov	r1, r2
100046de:	9200      	str	r2, [sp, #0]
100046e0:	4630      	mov	r0, r6
100046e2:	f7ff ff8f 	bl	10004604 <Cy_IPC_Pipe_EndpointInit>
    (void)Cy_SysInt_Init(&ipc_intr_cypipeConfig, config->userPipeIsrHandler);
100046e6:	6b21      	ldr	r1, [r4, #48]	; 0x30
100046e8:	4628      	mov	r0, r5
100046ea:	f003 fbe5 	bl	10007eb8 <Cy_SysInt_Init>
    NVIC_EnableIRQ(ipc_intr_cypipeConfig.intrSrc);
100046ee:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
  if ((int32_t)(IRQn) >= 0)
100046f2:	2b00      	cmp	r3, #0
100046f4:	db08      	blt.n	10004708 <Cy_IPC_Pipe_Init+0x74>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
100046f6:	2201      	movs	r2, #1
100046f8:	0959      	lsrs	r1, r3, #5
100046fa:	f003 031f 	and.w	r3, r3, #31
100046fe:	fa02 f303 	lsl.w	r3, r2, r3
10004702:	4a03      	ldr	r2, [pc, #12]	; (10004710 <Cy_IPC_Pipe_Init+0x7c>)
10004704:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
10004708:	b005      	add	sp, #20
1000470a:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000470c:	08003550 	.word	0x08003550
10004710:	e000e100 	.word	0xe000e100

10004714 <Cy_IPC_Pipe_SendMessage>:
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Pipe_SendMessage
*
*******************************************************************************/
cy_en_ipc_pipe_status_t Cy_IPC_Pipe_SendMessage(uint32_t toAddr, uint32_t fromAddr,
                                                void * msgPtr, cy_ipc_pipe_relcallback_ptr_t callBackPtr)
{
10004714:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t notifyMask;

    cy_stc_ipc_pipe_ep_t * fromEp;
    cy_stc_ipc_pipe_ep_t * toEp;

    CY_ASSERT_L1(NULL != msgPtr);
10004716:	b902      	cbnz	r2, 1000471a <Cy_IPC_Pipe_SendMessage+0x6>
10004718:	be01      	bkpt	0x0001
    CY_ASSERT_L1(NULL != cy_ipc_pipe_epArray);
1000471a:	4c16      	ldr	r4, [pc, #88]	; (10004774 <Cy_IPC_Pipe_SendMessage+0x60>)
1000471c:	6825      	ldr	r5, [r4, #0]
1000471e:	b905      	cbnz	r5, 10004722 <Cy_IPC_Pipe_SendMessage+0xe>
10004720:	be01      	bkpt	0x0001

    toEp   = &(cy_ipc_pipe_epArray[toAddr]);
10004722:	6825      	ldr	r5, [r4, #0]
10004724:	262c      	movs	r6, #44	; 0x2c
10004726:	fb06 5400 	mla	r4, r6, r0, r5
    fromEp = &cy_ipc_pipe_epArray[fromAddr];
1000472a:	fb06 5101 	mla	r1, r6, r1, r5

    /* Create the notify mask for the "toAddr" channel's interrupt channel */
    notifyMask  =  (uint32_t)(1UL << (toEp->intrChan));

    /* Check if IPC channel valid */
    if( toEp->ipcPtr != NULL)
1000472e:	6925      	ldr	r5, [r4, #16]
10004730:	b1dd      	cbz	r5, 1000476a <Cy_IPC_Pipe_SendMessage+0x56>
    {
        if(fromEp->busy == CY_IPC_PIPE_ENDPOINT_NOTBUSY)
10004732:	6988      	ldr	r0, [r1, #24]
10004734:	b9d8      	cbnz	r0, 1000476e <Cy_IPC_Pipe_SendMessage+0x5a>
    return ( 0UL != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_ACQUIRE(base))) ? CY_IPC_DRV_SUCCESS : CY_IPC_DRV_ERROR;
10004736:	682d      	ldr	r5, [r5, #0]
10004738:	2d00      	cmp	r5, #0
1000473a:	da18      	bge.n	1000476e <Cy_IPC_Pipe_SendMessage+0x5a>
    releaseMask =  (uint32_t)(1UL << (fromEp->intrChan));
1000473c:	684f      	ldr	r7, [r1, #4]
    notifyMask  =  (uint32_t)(1UL << (toEp->intrChan));
1000473e:	6865      	ldr	r5, [r4, #4]
10004740:	2601      	movs	r6, #1
    releaseMask =  (uint32_t)(1UL << (fromEp->intrChan));
10004742:	fa06 fc07 	lsl.w	ip, r6, r7
        {
            /* Attempt to acquire the channel */
            if( CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_LockAcquire(toEp->ipcPtr) )
            {
                /* Mask out the release mask area */
                * (uint32_t *) msgPtr &= ~(CY_IPC_PIPE_MSG_RELEASE_Msk);
10004746:	8817      	ldrh	r7, [r2, #0]

                * (uint32_t *) msgPtr |= releaseMask;
10004748:	ea47 470c 	orr.w	r7, r7, ip, lsl #16
1000474c:	6017      	str	r7, [r2, #0]

                /* If the channel was acquired, write the message.   */
                Cy_IPC_Drv_WriteDataValue(toEp->ipcPtr, (uint32_t) msgPtr);
1000474e:	6927      	ldr	r7, [r4, #16]
    notifyMask  =  (uint32_t)(1UL << (toEp->intrChan));
10004750:	fa06 f505 	lsl.w	r5, r6, r5
    REG_IPC_STRUCT_DATA(base) = dataValue;
10004754:	60fa      	str	r2, [r7, #12]
    CY_ASSERT_L1(0UL == (notifyEventIntr  & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
10004756:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000

                /* Set the busy flag.  The ISR clears this after the release */
                fromEp->busy = CY_IPC_PIPE_ENDPOINT_BUSY;
1000475a:	618e      	str	r6, [r1, #24]

                /* Setup release callback function */
                fromEp->releaseCallbackPtr = callBackPtr;
1000475c:	624b      	str	r3, [r1, #36]	; 0x24

                /* Cause notify event/interrupt */
                Cy_IPC_Drv_AcquireNotify(toEp->ipcPtr, notifyMask);
1000475e:	6923      	ldr	r3, [r4, #16]
10004760:	d300      	bcc.n	10004764 <Cy_IPC_Pipe_SendMessage+0x50>
10004762:	be01      	bkpt	0x0001
    REG_IPC_STRUCT_NOTIFY(base) = _VAL2FLD(IPC_STRUCT_NOTIFY_INTR_NOTIFY, notifyEventIntr);
10004764:	b2ad      	uxth	r5, r5
10004766:	609d      	str	r5, [r3, #8]
    {
        /* Null pipe handle. */
        returnStatus = CY_IPC_PIPE_ERROR_BAD_HANDLE;
    }
    return (returnStatus);
}
10004768:	bdf0      	pop	{r4, r5, r6, r7, pc}
        returnStatus = CY_IPC_PIPE_ERROR_BAD_HANDLE;
1000476a:	4803      	ldr	r0, [pc, #12]	; (10004778 <Cy_IPC_Pipe_SendMessage+0x64>)
1000476c:	e7fc      	b.n	10004768 <Cy_IPC_Pipe_SendMessage+0x54>
            returnStatus = CY_IPC_PIPE_ERROR_SEND_BUSY;
1000476e:	4803      	ldr	r0, [pc, #12]	; (1000477c <Cy_IPC_Pipe_SendMessage+0x68>)
    return (returnStatus);
10004770:	e7fa      	b.n	10004768 <Cy_IPC_Pipe_SendMessage+0x54>
10004772:	bf00      	nop
10004774:	080036e8 	.word	0x080036e8
10004778:	008a0204 	.word	0x008a0204
1000477c:	008a0207 	.word	0x008a0207

10004780 <Cy_IPC_Pipe_ExecCallback>:
* \note This function is obsolete and will be removed in the next releases.
*       Please use Cy_IPC_Pipe_ExecuteCallback() instead.
*
*******************************************************************************/
void Cy_IPC_Pipe_ExecCallback(cy_stc_ipc_pipe_ep_t * endpoint)
{
10004780:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint32_t *msgPtr = NULL;
10004782:	2300      	movs	r3, #0
10004784:	9301      	str	r3, [sp, #4]
    uint32_t releaseMask = (uint32_t)0;

    cy_ipc_pipe_callback_ptr_t callbackPtr;

    /* Parameters checking begin */
    CY_ASSERT_L1(NULL != endpoint);
10004786:	4604      	mov	r4, r0
10004788:	b900      	cbnz	r0, 1000478c <Cy_IPC_Pipe_ExecCallback+0xc>
1000478a:	be01      	bkpt	0x0001
    CY_ASSERT_L1(NULL != endpoint->ipcPtr);
1000478c:	6923      	ldr	r3, [r4, #16]
1000478e:	b903      	cbnz	r3, 10004792 <Cy_IPC_Pipe_ExecCallback+0x12>
10004790:	be01      	bkpt	0x0001
    CY_ASSERT_L1(NULL != endpoint->ipcIntrPtr);
10004792:	6963      	ldr	r3, [r4, #20]
10004794:	b903      	cbnz	r3, 10004798 <Cy_IPC_Pipe_ExecCallback+0x18>
10004796:	be01      	bkpt	0x0001
    CY_ASSERT_L1(NULL != endpoint->callbackArray);
10004798:	6a23      	ldr	r3, [r4, #32]
1000479a:	b903      	cbnz	r3, 1000479e <Cy_IPC_Pipe_ExecCallback+0x1e>
1000479c:	be01      	bkpt	0x0001
    /* Parameters checking end */

    shadowIntr = Cy_IPC_Drv_GetInterruptStatusMasked(endpoint->ipcIntrPtr);
1000479e:	6963      	ldr	r3, [r4, #20]
    return REG_IPC_INTR_STRUCT_INTR_MASKED(base);
100047a0:	68dd      	ldr	r5, [r3, #12]

    /* Check to make sure the interrupt was a notify interrupt */
    if (0UL != Cy_IPC_Drv_ExtractAcquireMask(shadowIntr))
100047a2:	0c2a      	lsrs	r2, r5, #16
100047a4:	d01d      	beq.n	100047e2 <Cy_IPC_Pipe_ExecCallback+0x62>
    REG_IPC_INTR_STRUCT_INTR(base) =  _VAL2FLD(IPC_INTR_STRUCT_INTR_NOTIFY,  ipcAcquireMask) |
100047a6:	0c2a      	lsrs	r2, r5, #16
100047a8:	0412      	lsls	r2, r2, #16
100047aa:	601a      	str	r2, [r3, #0]
    (void)REG_IPC_INTR_STRUCT_INTR(base);  /* Read the register to flush the cache */
100047ac:	681b      	ldr	r3, [r3, #0]
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
100047ae:	4b19      	ldr	r3, [pc, #100]	; (10004814 <Cy_IPC_Pipe_ExecCallback+0x94>)
    {
        /* Clear the notify interrupt.  */
        Cy_IPC_Drv_ClearInterrupt(endpoint->ipcIntrPtr, CY_IPC_NO_NOTIFICATION, Cy_IPC_Drv_ExtractAcquireMask(shadowIntr));

        if ( Cy_IPC_Drv_IsLockAcquired (endpoint->ipcPtr) )
100047b0:	6920      	ldr	r0, [r4, #16]
100047b2:	681b      	ldr	r3, [r3, #0]
100047b4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
100047b8:	58c3      	ldr	r3, [r0, r3]
100047ba:	2b00      	cmp	r3, #0
100047bc:	da11      	bge.n	100047e2 <Cy_IPC_Pipe_ExecCallback+0x62>
    return Cy_IPC_Drv_ReadMsgWord(base, (uint32_t *)msgPtr);
100047be:	a901      	add	r1, sp, #4
100047c0:	f7ff ff06 	bl	100045d0 <Cy_IPC_Drv_ReadMsgWord>
        {
            /* Extract Client ID  */
            if( CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_ReadMsgPtr (endpoint->ipcPtr, (void **)&msgPtr))
100047c4:	b9f0      	cbnz	r0, 10004804 <Cy_IPC_Pipe_ExecCallback+0x84>
            {
                /* Get release mask */
                releaseMask = _FLD2VAL(CY_IPC_PIPE_MSG_RELEASE, *msgPtr);
100047c6:	9801      	ldr	r0, [sp, #4]
                clientID    = _FLD2VAL(CY_IPC_PIPE_MSG_CLIENT,  *msgPtr);

                /* Make sure client ID is within valid range */
                if (endpoint->clientCount > clientID)
100047c8:	69e2      	ldr	r2, [r4, #28]
                releaseMask = _FLD2VAL(CY_IPC_PIPE_MSG_RELEASE, *msgPtr);
100047ca:	6806      	ldr	r6, [r0, #0]
                clientID    = _FLD2VAL(CY_IPC_PIPE_MSG_CLIENT,  *msgPtr);
100047cc:	b2f3      	uxtb	r3, r6
                if (endpoint->clientCount > clientID)
100047ce:	429a      	cmp	r2, r3
100047d0:	d903      	bls.n	100047da <Cy_IPC_Pipe_ExecCallback+0x5a>
                {
                    callbackPtr = endpoint->callbackArray[clientID];  /* Get the callback function */
100047d2:	6a22      	ldr	r2, [r4, #32]
100047d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]

                    if (callbackPtr != NULL)
100047d8:	b993      	cbnz	r3, 10004800 <Cy_IPC_Pipe_ExecCallback+0x80>
                releaseMask = _FLD2VAL(CY_IPC_PIPE_MSG_RELEASE, *msgPtr);
100047da:	0c31      	lsrs	r1, r6, #16
                    }
                }
            }

            /* Must always release the IPC channel */
            (void)Cy_IPC_Drv_LockRelease (endpoint->ipcPtr, releaseMask);
100047dc:	6920      	ldr	r0, [r4, #16]
100047de:	f7ff fed1 	bl	10004584 <Cy_IPC_Drv_LockRelease>
    return _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intMask);
100047e2:	b2ad      	uxth	r5, r5
        }
    }

    /* Check to make sure the interrupt was a release interrupt */
    if (0UL != Cy_IPC_Drv_ExtractReleaseMask(shadowIntr))  /* Check for a Release interrupt */
100047e4:	b145      	cbz	r5, 100047f8 <Cy_IPC_Pipe_ExecCallback+0x78>
    {
        /* Clear the release interrupt  */
        Cy_IPC_Drv_ClearInterrupt(endpoint->ipcIntrPtr, Cy_IPC_Drv_ExtractReleaseMask(shadowIntr), CY_IPC_NO_NOTIFICATION);
100047e6:	6963      	ldr	r3, [r4, #20]
    REG_IPC_INTR_STRUCT_INTR(base) =  _VAL2FLD(IPC_INTR_STRUCT_INTR_NOTIFY,  ipcAcquireMask) |
100047e8:	601d      	str	r5, [r3, #0]
    (void)REG_IPC_INTR_STRUCT_INTR(base);  /* Read the register to flush the cache */
100047ea:	681b      	ldr	r3, [r3, #0]

        if (endpoint->releaseCallbackPtr != NULL)
100047ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
100047ee:	2500      	movs	r5, #0
100047f0:	b153      	cbz	r3, 10004808 <Cy_IPC_Pipe_ExecCallback+0x88>
        {
            endpoint->releaseCallbackPtr();
100047f2:	4798      	blx	r3

            /* Clear the pointer after it was called */
            endpoint->releaseCallbackPtr = NULL;
100047f4:	6265      	str	r5, [r4, #36]	; 0x24
                endpoint->defaultReleaseCallbackPtr();
            }
        }

        /* Clear the busy flag when release is detected */
        endpoint->busy = CY_IPC_PIPE_ENDPOINT_NOTBUSY;
100047f6:	61a5      	str	r5, [r4, #24]
    }

    (void)Cy_IPC_Drv_GetInterruptStatus(endpoint->ipcIntrPtr);
100047f8:	6963      	ldr	r3, [r4, #20]
    return REG_IPC_INTR_STRUCT_INTR(base);
100047fa:	681b      	ldr	r3, [r3, #0]
}
100047fc:	b002      	add	sp, #8
100047fe:	bd70      	pop	{r4, r5, r6, pc}
                        callbackPtr(msgPtr);   /* Call the function pointer for "clientID" */
10004800:	4798      	blx	r3
10004802:	e7ea      	b.n	100047da <Cy_IPC_Pipe_ExecCallback+0x5a>
    uint32_t releaseMask = (uint32_t)0;
10004804:	2100      	movs	r1, #0
10004806:	e7e9      	b.n	100047dc <Cy_IPC_Pipe_ExecCallback+0x5c>
            if (endpoint->defaultReleaseCallbackPtr != NULL)
10004808:	6aa3      	ldr	r3, [r4, #40]	; 0x28
1000480a:	2b00      	cmp	r3, #0
1000480c:	d0f3      	beq.n	100047f6 <Cy_IPC_Pipe_ExecCallback+0x76>
                endpoint->defaultReleaseCallbackPtr();
1000480e:	4798      	blx	r3
10004810:	e7f1      	b.n	100047f6 <Cy_IPC_Pipe_ExecCallback+0x76>
10004812:	bf00      	nop
10004814:	08003550 	.word	0x08003550

10004818 <Cy_IPC_Pipe_ExecuteCallback>:
    CY_ASSERT_L1(NULL != cy_ipc_pipe_epArray);
10004818:	4b04      	ldr	r3, [pc, #16]	; (1000482c <Cy_IPC_Pipe_ExecuteCallback+0x14>)
1000481a:	681a      	ldr	r2, [r3, #0]
1000481c:	b902      	cbnz	r2, 10004820 <Cy_IPC_Pipe_ExecuteCallback+0x8>
1000481e:	be01      	bkpt	0x0001
    endpoint = &cy_ipc_pipe_epArray[epAddr];
10004820:	681b      	ldr	r3, [r3, #0]
    Cy_IPC_Pipe_ExecCallback(endpoint);
10004822:	222c      	movs	r2, #44	; 0x2c
10004824:	fb02 3000 	mla	r0, r2, r0, r3
10004828:	f7ff bfaa 	b.w	10004780 <Cy_IPC_Pipe_ExecCallback>
1000482c:	080036e8 	.word	0x080036e8

10004830 <Cy_IPC_Drv_GetIpcBaseAddress>:
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10004830:	4b06      	ldr	r3, [pc, #24]	; (1000484c <Cy_IPC_Drv_GetIpcBaseAddress+0x1c>)
10004832:	681a      	ldr	r2, [r3, #0]
10004834:	f892 2033 	ldrb.w	r2, [r2, #51]	; 0x33
10004838:	4282      	cmp	r2, r0
1000483a:	d800      	bhi.n	1000483e <Cy_IPC_Drv_GetIpcBaseAddress+0xe>
1000483c:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
1000483e:	681b      	ldr	r3, [r3, #0]
10004840:	f8b3 20ba 	ldrh.w	r2, [r3, #186]	; 0xba
10004844:	6a1b      	ldr	r3, [r3, #32]
}
10004846:	fb00 3002 	mla	r0, r0, r2, r3
1000484a:	4770      	bx	lr
1000484c:	08003550 	.word	0x08003550

10004850 <Cy_IPC_Sema_InitExt>:
*                             or count not multiple of 32
*    \retval CY_IPC_SEMA_ERROR_LOCKED:  Could not acquire semaphores IPC channel
*
*******************************************************************************/
cy_en_ipcsema_status_t Cy_IPC_Sema_InitExt(uint32_t ipcChannel, cy_stc_ipc_sema_t *ipcSema)
{
10004850:	b570      	push	{r4, r5, r6, lr}
    cy_en_ipcsema_status_t retStatus = CY_IPC_SEMA_BAD_PARAM;

    if (ipcChannel >= CY_IPC_CHANNELS)
10004852:	4b15      	ldr	r3, [pc, #84]	; (100048a8 <Cy_IPC_Sema_InitExt+0x58>)
10004854:	681b      	ldr	r3, [r3, #0]
10004856:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
1000485a:	4283      	cmp	r3, r0
{
1000485c:	460c      	mov	r4, r1
    if (ipcChannel >= CY_IPC_CHANNELS)
1000485e:	d921      	bls.n	100048a4 <Cy_IPC_Sema_InitExt+0x54>
    {
        retStatus = CY_IPC_SEMA_BAD_PARAM;
    }
    else
    {
        if(NULL != ipcSema)
10004860:	b301      	cbz	r1, 100048a4 <Cy_IPC_Sema_InitExt+0x54>
        {
            /* Check if semaphore count is a multiple of 32 */
            if( 0UL == (ipcSema->maxSema & CY_IPC_SEMA_PER_WORD_MASK))
10004862:	680d      	ldr	r5, [r1, #0]
10004864:	f015 051f 	ands.w	r5, r5, #31
10004868:	d11c      	bne.n	100048a4 <Cy_IPC_Sema_InitExt+0x54>
            {
                cy_semaIpcStruct = Cy_IPC_Drv_GetIpcBaseAddress(ipcChannel);
1000486a:	f7ff ffe1 	bl	10004830 <Cy_IPC_Drv_GetIpcBaseAddress>
1000486e:	4e0f      	ldr	r6, [pc, #60]	; (100048ac <Cy_IPC_Sema_InitExt+0x5c>)

                /* Initialize all semaphores to released */
                (void)memset(ipcSema->arrayPtr, 0, (ipcSema->maxSema /8u));
10004870:	680a      	ldr	r2, [r1, #0]
                cy_semaIpcStruct = Cy_IPC_Drv_GetIpcBaseAddress(ipcChannel);
10004872:	6030      	str	r0, [r6, #0]
                (void)memset(ipcSema->arrayPtr, 0, (ipcSema->maxSema /8u));
10004874:	08d2      	lsrs	r2, r2, #3
10004876:	4629      	mov	r1, r5
10004878:	6860      	ldr	r0, [r4, #4]
1000487a:	f003 fb61 	bl	10007f40 <memset>

                /* Make sure semaphores start out released.  */
                /* Ignore the return value since it is OK if it was already released. */
                (void) Cy_IPC_Drv_LockRelease (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION);
1000487e:	4629      	mov	r1, r5
10004880:	6830      	ldr	r0, [r6, #0]
10004882:	f7ff fe7f 	bl	10004584 <Cy_IPC_Drv_LockRelease>
    return Cy_IPC_Drv_SendMsgWord(base, notifyEventIntr, (uint32_t)msgPtr);
10004886:	4629      	mov	r1, r5
10004888:	6830      	ldr	r0, [r6, #0]
1000488a:	4622      	mov	r2, r4
1000488c:	f7ff fe90 	bl	100045b0 <Cy_IPC_Drv_SendMsgWord>

                 /* Set the IPC Data with the pointer to the array. */
                if( CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_SendMsgPtr (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION, ipcSema))
10004890:	4601      	mov	r1, r0
10004892:	b108      	cbz	r0, 10004898 <Cy_IPC_Sema_InitExt+0x48>
                    }
                }
                else
                {
                    /* Could not acquire semaphore channel */
                    retStatus = CY_IPC_SEMA_ERROR_LOCKED;
10004894:	4806      	ldr	r0, [pc, #24]	; (100048b0 <Cy_IPC_Sema_InitExt+0x60>)
            retStatus = CY_IPC_SEMA_BAD_PARAM;
        }
    }

    return(retStatus);
}
10004896:	bd70      	pop	{r4, r5, r6, pc}
                    if(CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_LockRelease (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION))
10004898:	6830      	ldr	r0, [r6, #0]
1000489a:	f7ff fe73 	bl	10004584 <Cy_IPC_Drv_LockRelease>
1000489e:	2800      	cmp	r0, #0
100048a0:	d0f9      	beq.n	10004896 <Cy_IPC_Sema_InitExt+0x46>
100048a2:	e7f7      	b.n	10004894 <Cy_IPC_Sema_InitExt+0x44>
        retStatus = CY_IPC_SEMA_BAD_PARAM;
100048a4:	4803      	ldr	r0, [pc, #12]	; (100048b4 <Cy_IPC_Sema_InitExt+0x64>)
    return(retStatus);
100048a6:	e7f6      	b.n	10004896 <Cy_IPC_Sema_InitExt+0x46>
100048a8:	08003550 	.word	0x08003550
100048ac:	080036ec 	.word	0x080036ec
100048b0:	008a0101 	.word	0x008a0101
100048b4:	008a0103 	.word	0x008a0103

100048b8 <Cy_IPC_Sema_Init>:
{
100048b8:	b510      	push	{r4, lr}
100048ba:	460c      	mov	r4, r1
    if( (NULL == memPtr) && (0u == count))
100048bc:	b932      	cbnz	r2, 100048cc <Cy_IPC_Sema_Init+0x14>
100048be:	b969      	cbnz	r1, 100048dc <Cy_IPC_Sema_Init+0x24>
        cy_semaIpcStruct = Cy_IPC_Drv_GetIpcBaseAddress(ipcChannel);
100048c0:	f7ff ffb6 	bl	10004830 <Cy_IPC_Drv_GetIpcBaseAddress>
100048c4:	4b06      	ldr	r3, [pc, #24]	; (100048e0 <Cy_IPC_Sema_Init+0x28>)
100048c6:	6018      	str	r0, [r3, #0]
}
100048c8:	4620      	mov	r0, r4
100048ca:	bd10      	pop	{r4, pc}
    else if ((NULL != memPtr) && (0u != count))
100048cc:	b131      	cbz	r1, 100048dc <Cy_IPC_Sema_Init+0x24>
        cy_semaData.maxSema  = count;
100048ce:	4905      	ldr	r1, [pc, #20]	; (100048e4 <Cy_IPC_Sema_Init+0x2c>)
        cy_semaData.arrayPtr = memPtr;
100048d0:	e9c1 4200 	strd	r4, r2, [r1]
}
100048d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        retStatus = Cy_IPC_Sema_InitExt(ipcChannel, &cy_semaData);
100048d8:	f7ff bfba 	b.w	10004850 <Cy_IPC_Sema_InitExt>
        retStatus = CY_IPC_SEMA_BAD_PARAM;
100048dc:	4c02      	ldr	r4, [pc, #8]	; (100048e8 <Cy_IPC_Sema_Init+0x30>)
100048de:	e7f3      	b.n	100048c8 <Cy_IPC_Sema_Init+0x10>
100048e0:	080036ec 	.word	0x080036ec
100048e4:	08004644 	.word	0x08004644
100048e8:	008a0103 	.word	0x008a0103

100048ec <Cy_IPC_Sema_Clear>:
* \funcusage
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Sema_Clear
*
*******************************************************************************/
cy_en_ipcsema_status_t Cy_IPC_Sema_Clear(uint32_t semaNumber, bool preemptable)
{
100048ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    cy_stc_ipc_sema_t      *semaStruct;
    cy_en_ipcsema_status_t  retStatus = CY_IPC_SEMA_LOCKED;

    /* Get pointer to structure */
    semaStruct = (cy_stc_ipc_sema_t *)Cy_IPC_Drv_ReadDataValue(cy_semaIpcStruct);
100048f0:	f8df 8070 	ldr.w	r8, [pc, #112]	; 10004964 <Cy_IPC_Sema_Clear+0x78>
{
100048f4:	4604      	mov	r4, r0
    semaStruct = (cy_stc_ipc_sema_t *)Cy_IPC_Drv_ReadDataValue(cy_semaIpcStruct);
100048f6:	f8d8 0000 	ldr.w	r0, [r8]
    return REG_IPC_STRUCT_DATA(base);
100048fa:	68c7      	ldr	r7, [r0, #12]

    if (semaNumber < semaStruct->maxSema)
100048fc:	683b      	ldr	r3, [r7, #0]
100048fe:	42a3      	cmp	r3, r4
{
10004900:	460e      	mov	r6, r1
    if (semaNumber < semaStruct->maxSema)
10004902:	d92c      	bls.n	1000495e <Cy_IPC_Sema_Clear+0x72>
    {
        semaIndex = semaNumber / CY_IPC_SEMA_PER_WORD;
        semaMask = (uint32_t)(1UL << (semaNumber - (semaIndex * CY_IPC_SEMA_PER_WORD) ));

        if (!preemptable)
10004904:	b131      	cbz	r1, 10004914 <Cy_IPC_Sema_Clear+0x28>
    return ( 0UL != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_ACQUIRE(base))) ? CY_IPC_DRV_SUCCESS : CY_IPC_DRV_ERROR;
10004906:	6803      	ldr	r3, [r0, #0]
10004908:	2b00      	cmp	r3, #0
1000490a:	db0d      	blt.n	10004928 <Cy_IPC_Sema_Clear+0x3c>
    cy_en_ipcsema_status_t  retStatus = CY_IPC_SEMA_LOCKED;
1000490c:	4c16      	ldr	r4, [pc, #88]	; (10004968 <Cy_IPC_Sema_Clear+0x7c>)
    else
    {
        retStatus = CY_IPC_SEMA_OUT_OF_RANGE;
    }
    return(retStatus);
}
1000490e:	4620      	mov	r0, r4
10004910:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            interruptState = Cy_SysLib_EnterCriticalSection();
10004914:	f7fd fced 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>
10004918:	4605      	mov	r5, r0
        if(CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_LockAcquire (cy_semaIpcStruct))
1000491a:	f8d8 0000 	ldr.w	r0, [r8]
1000491e:	6803      	ldr	r3, [r0, #0]
10004920:	2b00      	cmp	r3, #0
10004922:	db02      	blt.n	1000492a <Cy_IPC_Sema_Clear+0x3e>
    cy_en_ipcsema_status_t  retStatus = CY_IPC_SEMA_LOCKED;
10004924:	4c10      	ldr	r4, [pc, #64]	; (10004968 <Cy_IPC_Sema_Clear+0x7c>)
10004926:	e016      	b.n	10004956 <Cy_IPC_Sema_Clear+0x6a>
    uint32_t interruptState = 0UL;
10004928:	2500      	movs	r5, #0
            if((semaStruct->arrayPtr[semaIndex] & semaMask) != 0UL)
1000492a:	6879      	ldr	r1, [r7, #4]
        semaMask = (uint32_t)(1UL << (semaNumber - (semaIndex * CY_IPC_SEMA_PER_WORD) ));
1000492c:	f004 031f 	and.w	r3, r4, #31
        semaIndex = semaNumber / CY_IPC_SEMA_PER_WORD;
10004930:	0964      	lsrs	r4, r4, #5
        semaMask = (uint32_t)(1UL << (semaNumber - (semaIndex * CY_IPC_SEMA_PER_WORD) ));
10004932:	2201      	movs	r2, #1
10004934:	409a      	lsls	r2, r3
            if((semaStruct->arrayPtr[semaIndex] & semaMask) != 0UL)
10004936:	f851 3024 	ldr.w	r3, [r1, r4, lsl #2]
1000493a:	4213      	tst	r3, r2
                semaStruct->arrayPtr[semaIndex] &= ~semaMask;
1000493c:	bf1c      	itt	ne
1000493e:	4393      	bicne	r3, r2
10004940:	f841 3024 	strne.w	r3, [r1, r4, lsl #2]
            (void) Cy_IPC_Drv_LockRelease (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION);
10004944:	f04f 0100 	mov.w	r1, #0
                retStatus = CY_IPC_SEMA_NOT_ACQUIRED;
10004948:	bf0c      	ite	eq
1000494a:	4c08      	ldreq	r4, [pc, #32]	; (1000496c <Cy_IPC_Sema_Clear+0x80>)
                retStatus = CY_IPC_SEMA_SUCCESS;
1000494c:	2400      	movne	r4, #0
            (void) Cy_IPC_Drv_LockRelease (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION);
1000494e:	f7ff fe19 	bl	10004584 <Cy_IPC_Drv_LockRelease>
        if (!preemptable)
10004952:	2e00      	cmp	r6, #0
10004954:	d1db      	bne.n	1000490e <Cy_IPC_Sema_Clear+0x22>
            Cy_SysLib_ExitCriticalSection(interruptState);
10004956:	4628      	mov	r0, r5
10004958:	f7fd fccf 	bl	100022fa <Cy_SysLib_ExitCriticalSection>
1000495c:	e7d7      	b.n	1000490e <Cy_IPC_Sema_Clear+0x22>
        retStatus = CY_IPC_SEMA_OUT_OF_RANGE;
1000495e:	4c04      	ldr	r4, [pc, #16]	; (10004970 <Cy_IPC_Sema_Clear+0x84>)
    return(retStatus);
10004960:	e7d5      	b.n	1000490e <Cy_IPC_Sema_Clear+0x22>
10004962:	bf00      	nop
10004964:	080036ec 	.word	0x080036ec
10004968:	00880103 	.word	0x00880103
1000496c:	00880102 	.word	0x00880102
10004970:	008a0104 	.word	0x008a0104

10004974 <Cy_IPC_Sema_Status>:
    uint32_t semaIndex;
    uint32_t semaMask;
    cy_stc_ipc_sema_t      *semaStruct;

    /* Get pointer to structure */
    semaStruct = (cy_stc_ipc_sema_t *)Cy_IPC_Drv_ReadDataValue(cy_semaIpcStruct);
10004974:	4b0a      	ldr	r3, [pc, #40]	; (100049a0 <Cy_IPC_Sema_Status+0x2c>)
10004976:	681b      	ldr	r3, [r3, #0]
    return REG_IPC_STRUCT_DATA(base);
10004978:	68db      	ldr	r3, [r3, #12]

    if (semaNumber < semaStruct->maxSema)
1000497a:	681a      	ldr	r2, [r3, #0]
1000497c:	4282      	cmp	r2, r0
1000497e:	d90d      	bls.n	1000499c <Cy_IPC_Sema_Status+0x28>
    {
        /* Get the index into the semaphore array and calculate the mask */
        semaIndex = semaNumber / CY_IPC_SEMA_PER_WORD;
        semaMask = (uint32_t)(1UL << (semaNumber - (semaIndex * CY_IPC_SEMA_PER_WORD) ));

        if((semaStruct->arrayPtr[semaIndex] & semaMask) != 0UL)
10004980:	685a      	ldr	r2, [r3, #4]
        semaIndex = semaNumber / CY_IPC_SEMA_PER_WORD;
10004982:	0941      	lsrs	r1, r0, #5
        semaMask = (uint32_t)(1UL << (semaNumber - (semaIndex * CY_IPC_SEMA_PER_WORD) ));
10004984:	2301      	movs	r3, #1
        if((semaStruct->arrayPtr[semaIndex] & semaMask) != 0UL)
10004986:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
        semaMask = (uint32_t)(1UL << (semaNumber - (semaIndex * CY_IPC_SEMA_PER_WORD) ));
1000498a:	f000 001f 	and.w	r0, r0, #31
1000498e:	4083      	lsls	r3, r0
        {
            retStatus =  CY_IPC_SEMA_STATUS_LOCKED;
10004990:	4213      	tst	r3, r2
10004992:	4b04      	ldr	r3, [pc, #16]	; (100049a4 <Cy_IPC_Sema_Status+0x30>)
10004994:	4804      	ldr	r0, [pc, #16]	; (100049a8 <Cy_IPC_Sema_Status+0x34>)
10004996:	bf18      	it	ne
10004998:	4618      	movne	r0, r3
1000499a:	4770      	bx	lr
            retStatus =  CY_IPC_SEMA_STATUS_UNLOCKED;
        }
    }
    else
    {
        retStatus = CY_IPC_SEMA_OUT_OF_RANGE;
1000499c:	4803      	ldr	r0, [pc, #12]	; (100049ac <Cy_IPC_Sema_Status+0x38>)
    }
    return(retStatus);
}
1000499e:	4770      	bx	lr
100049a0:	080036ec 	.word	0x080036ec
100049a4:	00880101 	.word	0x00880101
100049a8:	00880100 	.word	0x00880100
100049ac:	008a0104 	.word	0x008a0104

100049b0 <Cy_SysClk_PeriphSetDivider>:
    if (dividerType == CY_SYSCLK_DIV_8_BIT)
100049b0:	b998      	cbnz	r0, 100049da <Cy_SysClk_PeriphSetDivider+0x2a>
        if ((dividerNum < PERI_DIV_8_NR) &&
100049b2:	2907      	cmp	r1, #7
100049b4:	d823      	bhi.n	100049fe <Cy_SysClk_PeriphSetDivider+0x4e>
100049b6:	2aff      	cmp	r2, #255	; 0xff
100049b8:	d821      	bhi.n	100049fe <Cy_SysClk_PeriphSetDivider+0x4e>
            CY_REG32_CLR_SET(PERI_DIV_8_CTL[dividerNum], PERI_DIV_8_CTL_INT8_DIV, dividerValue);
100049ba:	4b12      	ldr	r3, [pc, #72]	; (10004a04 <Cy_SysClk_PeriphSetDivider+0x54>)
100049bc:	681b      	ldr	r3, [r3, #0]
100049be:	f8b3 0078 	ldrh.w	r0, [r3, #120]	; 0x78
100049c2:	689b      	ldr	r3, [r3, #8]
100049c4:	4418      	add	r0, r3
100049c6:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
            CY_REG32_CLR_SET(PERI_DIV_16_CTL[dividerNum], PERI_DIV_16_CTL_INT16_DIV, dividerValue);
100049ca:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
100049ce:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
100049d2:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
            retVal = CY_SYSCLK_SUCCESS;
100049d6:	2000      	movs	r0, #0
100049d8:	4770      	bx	lr
    else if (dividerType == CY_SYSCLK_DIV_16_BIT)
100049da:	2801      	cmp	r0, #1
100049dc:	d10f      	bne.n	100049fe <Cy_SysClk_PeriphSetDivider+0x4e>
        if ((dividerNum < PERI_DIV_16_NR) &&
100049de:	290f      	cmp	r1, #15
100049e0:	d80d      	bhi.n	100049fe <Cy_SysClk_PeriphSetDivider+0x4e>
100049e2:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
100049e6:	d20a      	bcs.n	100049fe <Cy_SysClk_PeriphSetDivider+0x4e>
            CY_REG32_CLR_SET(PERI_DIV_16_CTL[dividerNum], PERI_DIV_16_CTL_INT16_DIV, dividerValue);
100049e8:	4b06      	ldr	r3, [pc, #24]	; (10004a04 <Cy_SysClk_PeriphSetDivider+0x54>)
100049ea:	681b      	ldr	r3, [r3, #0]
100049ec:	f8b3 007a 	ldrh.w	r0, [r3, #122]	; 0x7a
100049f0:	689b      	ldr	r3, [r3, #8]
100049f2:	4418      	add	r0, r3
100049f4:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
100049f8:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
100049fc:	e7e5      	b.n	100049ca <Cy_SysClk_PeriphSetDivider+0x1a>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
100049fe:	4802      	ldr	r0, [pc, #8]	; (10004a08 <Cy_SysClk_PeriphSetDivider+0x58>)
}
10004a00:	4770      	bx	lr
10004a02:	bf00      	nop
10004a04:	08003550 	.word	0x08003550
10004a08:	004a0001 	.word	0x004a0001

10004a0c <Cy_SysClk_PeriphGetDivider>:
    CY_ASSERT_L1(dividerType <= CY_SYSCLK_DIV_16_BIT);
10004a0c:	2801      	cmp	r0, #1
10004a0e:	4b0f      	ldr	r3, [pc, #60]	; (10004a4c <Cy_SysClk_PeriphGetDivider+0x40>)
10004a10:	d90d      	bls.n	10004a2e <Cy_SysClk_PeriphGetDivider+0x22>
10004a12:	be01      	bkpt	0x0001
        CY_ASSERT_L1(dividerNum < PERI_DIV_16_NR);
10004a14:	290f      	cmp	r1, #15
10004a16:	d900      	bls.n	10004a1a <Cy_SysClk_PeriphGetDivider+0xe>
10004a18:	be01      	bkpt	0x0001
        retVal = _FLD2VAL(PERI_DIV_16_CTL_INT16_DIV, PERI_DIV_16_CTL[dividerNum]);
10004a1a:	681a      	ldr	r2, [r3, #0]
10004a1c:	f8b2 307a 	ldrh.w	r3, [r2, #122]	; 0x7a
10004a20:	6892      	ldr	r2, [r2, #8]
10004a22:	4413      	add	r3, r2
10004a24:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
10004a28:	f3c0 200f 	ubfx	r0, r0, #8, #16
}
10004a2c:	4770      	bx	lr
    if (dividerType == CY_SYSCLK_DIV_8_BIT)
10004a2e:	2800      	cmp	r0, #0
10004a30:	d1f0      	bne.n	10004a14 <Cy_SysClk_PeriphGetDivider+0x8>
        CY_ASSERT_L1(dividerNum < PERI_DIV_8_NR);
10004a32:	2907      	cmp	r1, #7
10004a34:	d900      	bls.n	10004a38 <Cy_SysClk_PeriphGetDivider+0x2c>
10004a36:	be01      	bkpt	0x0001
        retVal = _FLD2VAL(PERI_DIV_8_CTL_INT8_DIV, PERI_DIV_8_CTL[dividerNum]);
10004a38:	681a      	ldr	r2, [r3, #0]
10004a3a:	f8b2 3078 	ldrh.w	r3, [r2, #120]	; 0x78
10004a3e:	6892      	ldr	r2, [r2, #8]
10004a40:	4413      	add	r3, r2
10004a42:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
10004a46:	f3c0 2007 	ubfx	r0, r0, #8, #8
    return (retVal);
10004a4a:	4770      	bx	lr
10004a4c:	08003550 	.word	0x08003550

10004a50 <Cy_SysClk_PeriphSetFracDivider>:
    if (dividerType == CY_SYSCLK_DIV_16_5_BIT)
10004a50:	2802      	cmp	r0, #2
{
10004a52:	b530      	push	{r4, r5, lr}
    if (dividerType == CY_SYSCLK_DIV_16_5_BIT)
10004a54:	d125      	bne.n	10004aa2 <Cy_SysClk_PeriphSetFracDivider+0x52>
        if ((dividerNum < PERI_DIV_16_5_NR) &&
10004a56:	2903      	cmp	r1, #3
10004a58:	d840      	bhi.n	10004adc <Cy_SysClk_PeriphSetFracDivider+0x8c>
10004a5a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
10004a5e:	d23d      	bcs.n	10004adc <Cy_SysClk_PeriphSetFracDivider+0x8c>
            (dividerIntValue <= (PERI_DIV_16_5_CTL_INT16_DIV_Msk >> PERI_DIV_16_5_CTL_INT16_DIV_Pos)) &&
10004a60:	2b1f      	cmp	r3, #31
10004a62:	d83b      	bhi.n	10004adc <Cy_SysClk_PeriphSetFracDivider+0x8c>
            CY_REG32_CLR_SET(PERI_DIV_16_5_CTL[dividerNum], PERI_DIV_16_5_CTL_INT16_DIV, dividerIntValue);
10004a64:	4d1e      	ldr	r5, [pc, #120]	; (10004ae0 <Cy_SysClk_PeriphSetFracDivider+0x90>)
10004a66:	6828      	ldr	r0, [r5, #0]
10004a68:	f8b0 407c 	ldrh.w	r4, [r0, #124]	; 0x7c
10004a6c:	6880      	ldr	r0, [r0, #8]
10004a6e:	4404      	add	r4, r0
10004a70:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
10004a74:	f420 007f 	bic.w	r0, r0, #16711680	; 0xff0000
10004a78:	f420 407f 	bic.w	r0, r0, #65280	; 0xff00
10004a7c:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
10004a80:	f844 0021 	str.w	r0, [r4, r1, lsl #2]
            CY_REG32_CLR_SET(PERI_DIV_16_5_CTL[dividerNum], PERI_DIV_16_5_CTL_FRAC5_DIV, dividerFracValue);
10004a84:	682a      	ldr	r2, [r5, #0]
10004a86:	f8b2 007c 	ldrh.w	r0, [r2, #124]	; 0x7c
10004a8a:	6892      	ldr	r2, [r2, #8]
10004a8c:	4410      	add	r0, r2
10004a8e:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
10004a92:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
10004a96:	ea42 03c3 	orr.w	r3, r2, r3, lsl #3
10004a9a:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
            retVal = CY_SYSCLK_SUCCESS;
10004a9e:	2000      	movs	r0, #0
}
10004aa0:	bd30      	pop	{r4, r5, pc}
    else if (dividerType == CY_SYSCLK_DIV_24_5_BIT)
10004aa2:	2803      	cmp	r0, #3
10004aa4:	d11a      	bne.n	10004adc <Cy_SysClk_PeriphSetFracDivider+0x8c>
        if ((dividerNum < PERI_DIV_24_5_NR) &&
10004aa6:	b9c9      	cbnz	r1, 10004adc <Cy_SysClk_PeriphSetFracDivider+0x8c>
10004aa8:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
10004aac:	d216      	bcs.n	10004adc <Cy_SysClk_PeriphSetFracDivider+0x8c>
            (dividerIntValue <= (PERI_DIV_24_5_CTL_INT24_DIV_Msk >> PERI_DIV_24_5_CTL_INT24_DIV_Pos)) &&
10004aae:	2b1f      	cmp	r3, #31
10004ab0:	d814      	bhi.n	10004adc <Cy_SysClk_PeriphSetFracDivider+0x8c>
            CY_REG32_CLR_SET(PERI_DIV_24_5_CTL[dividerNum], PERI_DIV_24_5_CTL_INT24_DIV, dividerIntValue);
10004ab2:	480b      	ldr	r0, [pc, #44]	; (10004ae0 <Cy_SysClk_PeriphSetFracDivider+0x90>)
10004ab4:	6801      	ldr	r1, [r0, #0]
10004ab6:	f8b1 507e 	ldrh.w	r5, [r1, #126]	; 0x7e
10004aba:	688c      	ldr	r4, [r1, #8]
10004abc:	5929      	ldr	r1, [r5, r4]
10004abe:	b2c9      	uxtb	r1, r1
10004ac0:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
10004ac4:	512a      	str	r2, [r5, r4]
            CY_REG32_CLR_SET(PERI_DIV_24_5_CTL[dividerNum], PERI_DIV_24_5_CTL_FRAC5_DIV, dividerFracValue);
10004ac6:	6802      	ldr	r2, [r0, #0]
10004ac8:	f8b2 007e 	ldrh.w	r0, [r2, #126]	; 0x7e
10004acc:	6891      	ldr	r1, [r2, #8]
10004ace:	5842      	ldr	r2, [r0, r1]
10004ad0:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
10004ad4:	ea42 03c3 	orr.w	r3, r2, r3, lsl #3
10004ad8:	5043      	str	r3, [r0, r1]
            retVal = CY_SYSCLK_SUCCESS;
10004ada:	e7e0      	b.n	10004a9e <Cy_SysClk_PeriphSetFracDivider+0x4e>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10004adc:	4801      	ldr	r0, [pc, #4]	; (10004ae4 <Cy_SysClk_PeriphSetFracDivider+0x94>)
    return (retVal);
10004ade:	e7df      	b.n	10004aa0 <Cy_SysClk_PeriphSetFracDivider+0x50>
10004ae0:	08003550 	.word	0x08003550
10004ae4:	004a0001 	.word	0x004a0001

10004ae8 <Cy_SysClk_PeriphGetFracDivider>:
{
10004ae8:	b530      	push	{r4, r5, lr}
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_16_5_BIT) || (dividerType == CY_SYSCLK_DIV_24_5_BIT)) && \
10004aea:	1e84      	subs	r4, r0, #2
10004aec:	2c01      	cmp	r4, #1
10004aee:	4c17      	ldr	r4, [pc, #92]	; (10004b4c <Cy_SysClk_PeriphGetFracDivider+0x64>)
10004af0:	d90f      	bls.n	10004b12 <Cy_SysClk_PeriphGetFracDivider+0x2a>
10004af2:	be01      	bkpt	0x0001
        CY_ASSERT_L1(dividerNum < PERI_DIV_24_5_NR);
10004af4:	b101      	cbz	r1, 10004af8 <Cy_SysClk_PeriphGetFracDivider+0x10>
10004af6:	be01      	bkpt	0x0001
        *dividerIntValue  = _FLD2VAL(PERI_DIV_24_5_CTL_INT24_DIV, PERI_DIV_24_5_CTL[dividerNum]);
10004af8:	6825      	ldr	r5, [r4, #0]
10004afa:	f8b5 007e 	ldrh.w	r0, [r5, #126]	; 0x7e
10004afe:	68ad      	ldr	r5, [r5, #8]
10004b00:	4428      	add	r0, r5
10004b02:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
10004b06:	0a00      	lsrs	r0, r0, #8
10004b08:	6010      	str	r0, [r2, #0]
        *dividerFracValue = _FLD2VAL(PERI_DIV_24_5_CTL_FRAC5_DIV, PERI_DIV_24_5_CTL[dividerNum]);
10004b0a:	6820      	ldr	r0, [r4, #0]
10004b0c:	f8b0 207e 	ldrh.w	r2, [r0, #126]	; 0x7e
10004b10:	e014      	b.n	10004b3c <Cy_SysClk_PeriphGetFracDivider+0x54>
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_16_5_BIT) || (dividerType == CY_SYSCLK_DIV_24_5_BIT)) && \
10004b12:	b102      	cbz	r2, 10004b16 <Cy_SysClk_PeriphGetFracDivider+0x2e>
10004b14:	b903      	cbnz	r3, 10004b18 <Cy_SysClk_PeriphGetFracDivider+0x30>
10004b16:	be01      	bkpt	0x0001
    if (dividerType == CY_SYSCLK_DIV_16_5_BIT)
10004b18:	2802      	cmp	r0, #2
10004b1a:	d1eb      	bne.n	10004af4 <Cy_SysClk_PeriphGetFracDivider+0xc>
        CY_ASSERT_L1(dividerNum < PERI_DIV_16_5_NR);
10004b1c:	2903      	cmp	r1, #3
10004b1e:	d900      	bls.n	10004b22 <Cy_SysClk_PeriphGetFracDivider+0x3a>
10004b20:	be01      	bkpt	0x0001
        *dividerIntValue  = _FLD2VAL(PERI_DIV_16_5_CTL_INT16_DIV, PERI_DIV_16_5_CTL[dividerNum]);
10004b22:	6825      	ldr	r5, [r4, #0]
10004b24:	f8b5 007c 	ldrh.w	r0, [r5, #124]	; 0x7c
10004b28:	68ad      	ldr	r5, [r5, #8]
10004b2a:	4428      	add	r0, r5
10004b2c:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
10004b30:	f3c0 200f 	ubfx	r0, r0, #8, #16
10004b34:	6010      	str	r0, [r2, #0]
        *dividerFracValue = _FLD2VAL(PERI_DIV_16_5_CTL_FRAC5_DIV, PERI_DIV_16_5_CTL[dividerNum]);
10004b36:	6820      	ldr	r0, [r4, #0]
10004b38:	f8b0 207c 	ldrh.w	r2, [r0, #124]	; 0x7c
        *dividerFracValue = _FLD2VAL(PERI_DIV_24_5_CTL_FRAC5_DIV, PERI_DIV_24_5_CTL[dividerNum]);
10004b3c:	6880      	ldr	r0, [r0, #8]
10004b3e:	4402      	add	r2, r0
10004b40:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
10004b44:	f3c2 02c4 	ubfx	r2, r2, #3, #5
        *dividerFracValue = _FLD2VAL(PERI_DIV_16_5_CTL_FRAC5_DIV, PERI_DIV_16_5_CTL[dividerNum]);
10004b48:	601a      	str	r2, [r3, #0]
}
10004b4a:	bd30      	pop	{r4, r5, pc}
10004b4c:	08003550 	.word	0x08003550

10004b50 <Cy_SysClk_PeriphAssignDivider>:
{
10004b50:	b530      	push	{r4, r5, lr}
    if ((CY_PERI_CLOCK_NR > (uint32_t)ipBlock) && (CY_SYSCLK_DIV_24_5_BIT >= dividerType))
10004b52:	4b13      	ldr	r3, [pc, #76]	; (10004ba0 <Cy_SysClk_PeriphAssignDivider+0x50>)
10004b54:	681b      	ldr	r3, [r3, #0]
10004b56:	f893 4042 	ldrb.w	r4, [r3, #66]	; 0x42
10004b5a:	4284      	cmp	r4, r0
10004b5c:	d904      	bls.n	10004b68 <Cy_SysClk_PeriphAssignDivider+0x18>
10004b5e:	2903      	cmp	r1, #3
10004b60:	d802      	bhi.n	10004b68 <Cy_SysClk_PeriphAssignDivider+0x18>
        if (((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    ||
10004b62:	b919      	cbnz	r1, 10004b6c <Cy_SysClk_PeriphAssignDivider+0x1c>
10004b64:	2a07      	cmp	r2, #7
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
10004b66:	d90b      	bls.n	10004b80 <Cy_SysClk_PeriphAssignDivider+0x30>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10004b68:	480e      	ldr	r0, [pc, #56]	; (10004ba4 <Cy_SysClk_PeriphAssignDivider+0x54>)
    return (retVal);
10004b6a:	e018      	b.n	10004b9e <Cy_SysClk_PeriphAssignDivider+0x4e>
        if (((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    ||
10004b6c:	2901      	cmp	r1, #1
10004b6e:	d003      	beq.n	10004b78 <Cy_SysClk_PeriphAssignDivider+0x28>
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
10004b70:	2902      	cmp	r1, #2
10004b72:	d103      	bne.n	10004b7c <Cy_SysClk_PeriphAssignDivider+0x2c>
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
10004b74:	2a03      	cmp	r2, #3
10004b76:	e7f6      	b.n	10004b66 <Cy_SysClk_PeriphAssignDivider+0x16>
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
10004b78:	2a0f      	cmp	r2, #15
10004b7a:	e7f4      	b.n	10004b66 <Cy_SysClk_PeriphAssignDivider+0x16>
            ((dividerType == CY_SYSCLK_DIV_24_5_BIT) && (dividerNum < PERI_DIV_24_5_NR)))
10004b7c:	2a00      	cmp	r2, #0
10004b7e:	d1f3      	bne.n	10004b68 <Cy_SysClk_PeriphAssignDivider+0x18>
            PERI_CLOCK_CTL[ipBlock] = _VAL2FLD(CY_PERI_CLOCK_CTL_TYPE_SEL, dividerType) |
10004b80:	f893 5075 	ldrb.w	r5, [r3, #117]	; 0x75
10004b84:	689c      	ldr	r4, [r3, #8]
                                      _VAL2FLD(CY_PERI_CLOCK_CTL_DIV_SEL, dividerNum);
10004b86:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
            PERI_CLOCK_CTL[ipBlock] = _VAL2FLD(CY_PERI_CLOCK_CTL_TYPE_SEL, dividerType) |
10004b8a:	f001 0103 	and.w	r1, r1, #3
10004b8e:	f500 7040 	add.w	r0, r0, #768	; 0x300
10004b92:	40a9      	lsls	r1, r5
                                      _VAL2FLD(CY_PERI_CLOCK_CTL_DIV_SEL, dividerNum);
10004b94:	4013      	ands	r3, r2
            PERI_CLOCK_CTL[ipBlock] = _VAL2FLD(CY_PERI_CLOCK_CTL_TYPE_SEL, dividerType) |
10004b96:	4319      	orrs	r1, r3
10004b98:	f844 1020 	str.w	r1, [r4, r0, lsl #2]
            retVal = CY_SYSCLK_SUCCESS;
10004b9c:	2000      	movs	r0, #0
}
10004b9e:	bd30      	pop	{r4, r5, pc}
10004ba0:	08003550 	.word	0x08003550
10004ba4:	004a0001 	.word	0x004a0001

10004ba8 <Cy_SysClk_PeriphEnableDivider>:
    if (dividerType <= CY_SYSCLK_DIV_24_5_BIT)
10004ba8:	2803      	cmp	r0, #3
{
10004baa:	b5f0      	push	{r4, r5, r6, r7, lr}
10004bac:	460b      	mov	r3, r1
    if (dividerType <= CY_SYSCLK_DIV_24_5_BIT)
10004bae:	d802      	bhi.n	10004bb6 <Cy_SysClk_PeriphEnableDivider+0xe>
        if (((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    ||
10004bb0:	b918      	cbnz	r0, 10004bba <Cy_SysClk_PeriphEnableDivider+0x12>
10004bb2:	2907      	cmp	r1, #7
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
10004bb4:	d90b      	bls.n	10004bce <Cy_SysClk_PeriphEnableDivider+0x26>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10004bb6:	4816      	ldr	r0, [pc, #88]	; (10004c10 <Cy_SysClk_PeriphEnableDivider+0x68>)
    return (retVal);
10004bb8:	e028      	b.n	10004c0c <Cy_SysClk_PeriphEnableDivider+0x64>
        if (((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    ||
10004bba:	2801      	cmp	r0, #1
10004bbc:	d003      	beq.n	10004bc6 <Cy_SysClk_PeriphEnableDivider+0x1e>
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
10004bbe:	2802      	cmp	r0, #2
10004bc0:	d103      	bne.n	10004bca <Cy_SysClk_PeriphEnableDivider+0x22>
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
10004bc2:	2903      	cmp	r1, #3
10004bc4:	e7f6      	b.n	10004bb4 <Cy_SysClk_PeriphEnableDivider+0xc>
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
10004bc6:	290f      	cmp	r1, #15
10004bc8:	e7f4      	b.n	10004bb4 <Cy_SysClk_PeriphEnableDivider+0xc>
            ((dividerType == CY_SYSCLK_DIV_24_5_BIT) && (dividerNum < PERI_DIV_24_5_NR)))
10004bca:	2900      	cmp	r1, #0
10004bcc:	d1f3      	bne.n	10004bb6 <Cy_SysClk_PeriphEnableDivider+0xe>
                           CY_PERI_DIV_CMD_PA_TYPE_SEL_Msk                 |
10004bce:	4a11      	ldr	r2, [pc, #68]	; (10004c14 <Cy_SysClk_PeriphEnableDivider+0x6c>)
10004bd0:	6814      	ldr	r4, [r2, #0]
                           CY_PERI_DIV_CMD_PA_DIV_SEL_Msk                  |
10004bd2:	f894 6074 	ldrb.w	r6, [r4, #116]	; 0x74
                           CY_PERI_DIV_CMD_PA_TYPE_SEL_Msk                 |
10004bd6:	f894 1077 	ldrb.w	r1, [r4, #119]	; 0x77
                           CY_PERI_DIV_CMD_PA_DIV_SEL_Msk                  |
10004bda:	f894 7076 	ldrb.w	r7, [r4, #118]	; 0x76
                           _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
10004bde:	f894 c075 	ldrb.w	ip, [r4, #117]	; 0x75
            PERI_DIV_CMD = PERI_DIV_CMD_ENABLE_Msk                         |
10004be2:	68a2      	ldr	r2, [r4, #8]
                           CY_PERI_DIV_CMD_PA_TYPE_SEL_Msk                 |
10004be4:	2503      	movs	r5, #3
10004be6:	fa05 f101 	lsl.w	r1, r5, r1
                           CY_PERI_DIV_CMD_PA_DIV_SEL_Msk                  |
10004bea:	fa06 f707 	lsl.w	r7, r6, r7
                           _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
10004bee:	4005      	ands	r5, r0
                           CY_PERI_DIV_CMD_PA_TYPE_SEL_Msk                 |
10004bf0:	4339      	orrs	r1, r7
                           _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
10004bf2:	fa05 f50c 	lsl.w	r5, r5, ip
                           _VAL2FLD(CY_PERI_DIV_CMD_DIV_SEL,  dividerNum);
10004bf6:	401e      	ands	r6, r3
                           CY_PERI_DIV_CMD_PA_DIV_SEL_Msk                  |
10004bf8:	4329      	orrs	r1, r5
                           _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
10004bfa:	4331      	orrs	r1, r6
10004bfc:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
            PERI_DIV_CMD = PERI_DIV_CMD_ENABLE_Msk                         |
10004c00:	f8c2 1400 	str.w	r1, [r2, #1024]	; 0x400
            (void)PERI_DIV_CMD; /* dummy read to handle buffered writes */
10004c04:	68a3      	ldr	r3, [r4, #8]
10004c06:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
            retVal = CY_SYSCLK_SUCCESS;
10004c0a:	2000      	movs	r0, #0
}
10004c0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
10004c0e:	bf00      	nop
10004c10:	004a0001 	.word	0x004a0001
10004c14:	08003550 	.word	0x08003550

10004c18 <Cy_SysClk_PeriphDisableDivider>:
    if (dividerType <= CY_SYSCLK_DIV_24_5_BIT)
10004c18:	2803      	cmp	r0, #3
{
10004c1a:	b510      	push	{r4, lr}
    if (dividerType <= CY_SYSCLK_DIV_24_5_BIT)
10004c1c:	d802      	bhi.n	10004c24 <Cy_SysClk_PeriphDisableDivider+0xc>
        if (((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    ||
10004c1e:	b918      	cbnz	r0, 10004c28 <Cy_SysClk_PeriphDisableDivider+0x10>
10004c20:	2907      	cmp	r1, #7
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
10004c22:	d90b      	bls.n	10004c3c <Cy_SysClk_PeriphDisableDivider+0x24>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10004c24:	480e      	ldr	r0, [pc, #56]	; (10004c60 <Cy_SysClk_PeriphDisableDivider+0x48>)
    return (retVal);
10004c26:	e01a      	b.n	10004c5e <Cy_SysClk_PeriphDisableDivider+0x46>
        if (((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    ||
10004c28:	2801      	cmp	r0, #1
10004c2a:	d003      	beq.n	10004c34 <Cy_SysClk_PeriphDisableDivider+0x1c>
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
10004c2c:	2802      	cmp	r0, #2
10004c2e:	d103      	bne.n	10004c38 <Cy_SysClk_PeriphDisableDivider+0x20>
            ((dividerType == CY_SYSCLK_DIV_16_5_BIT) && (dividerNum < PERI_DIV_16_5_NR)) ||
10004c30:	2903      	cmp	r1, #3
10004c32:	e7f6      	b.n	10004c22 <Cy_SysClk_PeriphDisableDivider+0xa>
            ((dividerType == CY_SYSCLK_DIV_16_BIT)   && (dividerNum < PERI_DIV_16_NR))   ||
10004c34:	290f      	cmp	r1, #15
10004c36:	e7f4      	b.n	10004c22 <Cy_SysClk_PeriphDisableDivider+0xa>
            ((dividerType == CY_SYSCLK_DIV_24_5_BIT) && (dividerNum < PERI_DIV_24_5_NR)))
10004c38:	2900      	cmp	r1, #0
10004c3a:	d1f3      	bne.n	10004c24 <Cy_SysClk_PeriphDisableDivider+0xc>
             _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
10004c3c:	4b09      	ldr	r3, [pc, #36]	; (10004c64 <Cy_SysClk_PeriphDisableDivider+0x4c>)
10004c3e:	681b      	ldr	r3, [r3, #0]
10004c40:	f893 4075 	ldrb.w	r4, [r3, #117]	; 0x75
            PERI_DIV_CMD = PERI_DIV_CMD_DISABLE_Msk          |
10004c44:	689a      	ldr	r2, [r3, #8]
             _VAL2FLD(CY_PERI_DIV_CMD_DIV_SEL,  dividerNum);
10004c46:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
             _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
10004c4a:	f000 0003 	and.w	r0, r0, #3
10004c4e:	40a0      	lsls	r0, r4
             _VAL2FLD(CY_PERI_DIV_CMD_DIV_SEL,  dividerNum);
10004c50:	400b      	ands	r3, r1
             _VAL2FLD(CY_PERI_DIV_CMD_TYPE_SEL, dividerType) |
10004c52:	4318      	orrs	r0, r3
10004c54:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
            PERI_DIV_CMD = PERI_DIV_CMD_DISABLE_Msk          |
10004c58:	f8c2 0400 	str.w	r0, [r2, #1024]	; 0x400
10004c5c:	2000      	movs	r0, #0
}
10004c5e:	bd10      	pop	{r4, pc}
10004c60:	004a0001 	.word	0x004a0001
10004c64:	08003550 	.word	0x08003550

10004c68 <Cy_SysClk_PeriphGetDividerEnabled>:
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
10004c68:	b968      	cbnz	r0, 10004c86 <Cy_SysClk_PeriphGetDividerEnabled+0x1e>
10004c6a:	2907      	cmp	r1, #7
10004c6c:	d900      	bls.n	10004c70 <Cy_SysClk_PeriphGetDividerEnabled+0x8>
10004c6e:	be01      	bkpt	0x0001
            retVal = _FLD2BOOL(PERI_DIV_8_CTL_EN, PERI_DIV_8_CTL[dividerNum]);
10004c70:	4b15      	ldr	r3, [pc, #84]	; (10004cc8 <Cy_SysClk_PeriphGetDividerEnabled+0x60>)
10004c72:	681a      	ldr	r2, [r3, #0]
10004c74:	f8b2 3078 	ldrh.w	r3, [r2, #120]	; 0x78
            retVal = _FLD2BOOL(PERI_DIV_24_5_CTL_EN, PERI_DIV_24_5_CTL[dividerNum]);
10004c78:	6892      	ldr	r2, [r2, #8]
10004c7a:	4413      	add	r3, r2
10004c7c:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
10004c80:	f000 0001 	and.w	r0, r0, #1
}
10004c84:	4770      	bx	lr
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
10004c86:	2801      	cmp	r0, #1
10004c88:	d006      	beq.n	10004c98 <Cy_SysClk_PeriphGetDividerEnabled+0x30>
10004c8a:	2802      	cmp	r0, #2
10004c8c:	d00b      	beq.n	10004ca6 <Cy_SysClk_PeriphGetDividerEnabled+0x3e>
10004c8e:	2803      	cmp	r0, #3
10004c90:	d011      	beq.n	10004cb6 <Cy_SysClk_PeriphGetDividerEnabled+0x4e>
10004c92:	be01      	bkpt	0x0001
    bool retVal = false;
10004c94:	2000      	movs	r0, #0
10004c96:	4770      	bx	lr
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
10004c98:	290f      	cmp	r1, #15
10004c9a:	d813      	bhi.n	10004cc4 <Cy_SysClk_PeriphGetDividerEnabled+0x5c>
            retVal = _FLD2BOOL(PERI_DIV_16_CTL_EN, PERI_DIV_16_CTL[dividerNum]);
10004c9c:	4b0a      	ldr	r3, [pc, #40]	; (10004cc8 <Cy_SysClk_PeriphGetDividerEnabled+0x60>)
10004c9e:	681a      	ldr	r2, [r3, #0]
10004ca0:	f8b2 307a 	ldrh.w	r3, [r2, #122]	; 0x7a
10004ca4:	e7e8      	b.n	10004c78 <Cy_SysClk_PeriphGetDividerEnabled+0x10>
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
10004ca6:	2903      	cmp	r1, #3
10004ca8:	d900      	bls.n	10004cac <Cy_SysClk_PeriphGetDividerEnabled+0x44>
10004caa:	be01      	bkpt	0x0001
            retVal = _FLD2BOOL(PERI_DIV_16_5_CTL_EN, PERI_DIV_16_5_CTL[dividerNum]);
10004cac:	4b06      	ldr	r3, [pc, #24]	; (10004cc8 <Cy_SysClk_PeriphGetDividerEnabled+0x60>)
10004cae:	681a      	ldr	r2, [r3, #0]
10004cb0:	f8b2 307c 	ldrh.w	r3, [r2, #124]	; 0x7c
10004cb4:	e7e0      	b.n	10004c78 <Cy_SysClk_PeriphGetDividerEnabled+0x10>
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
10004cb6:	b101      	cbz	r1, 10004cba <Cy_SysClk_PeriphGetDividerEnabled+0x52>
10004cb8:	be01      	bkpt	0x0001
            retVal = _FLD2BOOL(PERI_DIV_24_5_CTL_EN, PERI_DIV_24_5_CTL[dividerNum]);
10004cba:	4b03      	ldr	r3, [pc, #12]	; (10004cc8 <Cy_SysClk_PeriphGetDividerEnabled+0x60>)
10004cbc:	681a      	ldr	r2, [r3, #0]
10004cbe:	f8b2 307e 	ldrh.w	r3, [r2, #126]	; 0x7e
10004cc2:	e7d9      	b.n	10004c78 <Cy_SysClk_PeriphGetDividerEnabled+0x10>
10004cc4:	be01      	bkpt	0x0001
    switch(dividerType)
10004cc6:	e7e9      	b.n	10004c9c <Cy_SysClk_PeriphGetDividerEnabled+0x34>
10004cc8:	08003550 	.word	0x08003550

10004ccc <Cy_SysClk_ClkSlowSetDivider>:
    CY_REG32_CLR_SET(CPUSS_CM0_CLOCK_CTL, CPUSS_CM0_CLOCK_CTL_SLOW_INT_DIV, divider);
10004ccc:	4b05      	ldr	r3, [pc, #20]	; (10004ce4 <Cy_SysClk_ClkSlowSetDivider+0x18>)
10004cce:	681b      	ldr	r3, [r3, #0]
10004cd0:	6819      	ldr	r1, [r3, #0]
10004cd2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
10004cd6:	588b      	ldr	r3, [r1, r2]
10004cd8:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
10004cdc:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
10004ce0:	508b      	str	r3, [r1, r2]
}
10004ce2:	4770      	bx	lr
10004ce4:	08003550 	.word	0x08003550

10004ce8 <Cy_SysClk_ClkSlowGetDivider>:
    return ((uint8_t)_FLD2VAL(CPUSS_CM0_CLOCK_CTL_SLOW_INT_DIV, CPUSS_CM0_CLOCK_CTL));
10004ce8:	4b04      	ldr	r3, [pc, #16]	; (10004cfc <Cy_SysClk_ClkSlowGetDivider+0x14>)
10004cea:	681b      	ldr	r3, [r3, #0]
10004cec:	681a      	ldr	r2, [r3, #0]
10004cee:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
10004cf2:	58d0      	ldr	r0, [r2, r3]
}
10004cf4:	f3c0 2007 	ubfx	r0, r0, #8, #8
10004cf8:	4770      	bx	lr
10004cfa:	bf00      	nop
10004cfc:	08003550 	.word	0x08003550

10004d00 <Cy_SysClk_ClkPumpSetSource>:
    CY_ASSERT_L3(source <= CY_SYSCLK_PUMP_IN_CLKPATH15);
10004d00:	280f      	cmp	r0, #15
10004d02:	d900      	bls.n	10004d06 <Cy_SysClk_ClkPumpSetSource+0x6>
10004d04:	be01      	bkpt	0x0001
    CY_REG32_CLR_SET(SRSS_CLK_SELECT, SRSS_CLK_SELECT_PUMP_SEL, source);
10004d06:	4a06      	ldr	r2, [pc, #24]	; (10004d20 <Cy_SysClk_ClkPumpSetSource+0x20>)
10004d08:	f8d2 3500 	ldr.w	r3, [r2, #1280]	; 0x500
10004d0c:	0200      	lsls	r0, r0, #8
10004d0e:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
10004d12:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
10004d16:	4318      	orrs	r0, r3
10004d18:	f8c2 0500 	str.w	r0, [r2, #1280]	; 0x500
}
10004d1c:	4770      	bx	lr
10004d1e:	bf00      	nop
10004d20:	40260000 	.word	0x40260000

10004d24 <Cy_SysClk_ClkPumpGetSource>:
    return ((cy_en_clkpump_in_sources_t)((uint32_t)_FLD2VAL(SRSS_CLK_SELECT_PUMP_SEL, SRSS_CLK_SELECT)));
10004d24:	4b02      	ldr	r3, [pc, #8]	; (10004d30 <Cy_SysClk_ClkPumpGetSource+0xc>)
10004d26:	f8d3 0500 	ldr.w	r0, [r3, #1280]	; 0x500
}
10004d2a:	f3c0 2003 	ubfx	r0, r0, #8, #4
10004d2e:	4770      	bx	lr
10004d30:	40260000 	.word	0x40260000

10004d34 <Cy_SysClk_ClkPumpSetDivider>:
    CY_ASSERT_L3(CY_SYSCLK_FLL_IS_DIVIDER_VALID(divider));
10004d34:	2804      	cmp	r0, #4
10004d36:	d900      	bls.n	10004d3a <Cy_SysClk_ClkPumpSetDivider+0x6>
10004d38:	be01      	bkpt	0x0001
    CY_REG32_CLR_SET(SRSS_CLK_SELECT, SRSS_CLK_SELECT_PUMP_DIV, divider);
10004d3a:	4a06      	ldr	r2, [pc, #24]	; (10004d54 <Cy_SysClk_ClkPumpSetDivider+0x20>)
10004d3c:	f8d2 3500 	ldr.w	r3, [r2, #1280]	; 0x500
10004d40:	0300      	lsls	r0, r0, #12
10004d42:	f400 40e0 	and.w	r0, r0, #28672	; 0x7000
10004d46:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
10004d4a:	4318      	orrs	r0, r3
10004d4c:	f8c2 0500 	str.w	r0, [r2, #1280]	; 0x500
}
10004d50:	4770      	bx	lr
10004d52:	bf00      	nop
10004d54:	40260000 	.word	0x40260000

10004d58 <Cy_SysClk_ClkPumpGetDivider>:
    return ((cy_en_clkpump_divide_t)((uint32_t)_FLD2VAL(SRSS_CLK_SELECT_PUMP_DIV, SRSS_CLK_SELECT)));
10004d58:	4b02      	ldr	r3, [pc, #8]	; (10004d64 <Cy_SysClk_ClkPumpGetDivider+0xc>)
10004d5a:	f8d3 0500 	ldr.w	r0, [r3, #1280]	; 0x500
}
10004d5e:	f3c0 3002 	ubfx	r0, r0, #12, #3
10004d62:	4770      	bx	lr
10004d64:	40260000 	.word	0x40260000

10004d68 <Cy_SysClk_ClkPumpEnable>:
    SRSS_CLK_SELECT |= SRSS_CLK_SELECT_PUMP_ENABLE_Msk;
10004d68:	4a03      	ldr	r2, [pc, #12]	; (10004d78 <Cy_SysClk_ClkPumpEnable+0x10>)
10004d6a:	f8d2 3500 	ldr.w	r3, [r2, #1280]	; 0x500
10004d6e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
10004d72:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
}
10004d76:	4770      	bx	lr
10004d78:	40260000 	.word	0x40260000

10004d7c <Cy_SysClk_ClkPumpIsEnabled>:
    return (_FLD2BOOL(SRSS_CLK_SELECT_PUMP_ENABLE, SRSS_CLK_SELECT));
10004d7c:	4b02      	ldr	r3, [pc, #8]	; (10004d88 <Cy_SysClk_ClkPumpIsEnabled+0xc>)
10004d7e:	f8d3 0500 	ldr.w	r0, [r3, #1280]	; 0x500
}
10004d82:	f3c0 30c0 	ubfx	r0, r0, #15, #1
10004d86:	4770      	bx	lr
10004d88:	40260000 	.word	0x40260000

10004d8c <Cy_SysClk_ClkPumpDisable>:
    SRSS_CLK_SELECT &= ~SRSS_CLK_SELECT_PUMP_ENABLE_Msk;
10004d8c:	4a03      	ldr	r2, [pc, #12]	; (10004d9c <Cy_SysClk_ClkPumpDisable+0x10>)
10004d8e:	f8d2 3500 	ldr.w	r3, [r2, #1280]	; 0x500
10004d92:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
10004d96:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
}
10004d9a:	4770      	bx	lr
10004d9c:	40260000 	.word	0x40260000

10004da0 <Cy_SysClk_ClkBakSetSource>:
    CY_ASSERT_L3(source <= CY_SYSCLK_BAK_IN_CLKLF);
10004da0:	2801      	cmp	r0, #1
10004da2:	d900      	bls.n	10004da6 <Cy_SysClk_ClkBakSetSource+0x6>
10004da4:	be01      	bkpt	0x0001
    CY_REG32_CLR_SET(BACKUP_CTL, BACKUP_CTL_CLK_SEL, source);
10004da6:	4a05      	ldr	r2, [pc, #20]	; (10004dbc <Cy_SysClk_ClkBakSetSource+0x1c>)
10004da8:	6813      	ldr	r3, [r2, #0]
10004daa:	0200      	lsls	r0, r0, #8
10004dac:	f400 7040 	and.w	r0, r0, #768	; 0x300
10004db0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
10004db4:	4318      	orrs	r0, r3
10004db6:	6010      	str	r0, [r2, #0]
}
10004db8:	4770      	bx	lr
10004dba:	bf00      	nop
10004dbc:	40270000 	.word	0x40270000

10004dc0 <Cy_SysClk_ClkBakGetSource>:
    return ((cy_en_clkbak_in_sources_t)((uint32_t)_FLD2VAL(BACKUP_CTL_CLK_SEL, BACKUP_CTL)));
10004dc0:	4b02      	ldr	r3, [pc, #8]	; (10004dcc <Cy_SysClk_ClkBakGetSource+0xc>)
10004dc2:	6818      	ldr	r0, [r3, #0]
}
10004dc4:	f3c0 2001 	ubfx	r0, r0, #8, #2
10004dc8:	4770      	bx	lr
10004dca:	bf00      	nop
10004dcc:	40270000 	.word	0x40270000

10004dd0 <Cy_SysClk_ClkTimerSetSource>:
    CY_ASSERT_L3(source <= CY_SYSCLK_CLKTIMER_IN_HF0_DIV8);
10004dd0:	f240 3301 	movw	r3, #769	; 0x301
10004dd4:	4298      	cmp	r0, r3
10004dd6:	d900      	bls.n	10004dda <Cy_SysClk_ClkTimerSetSource+0xa>
10004dd8:	be01      	bkpt	0x0001
    CY_REG32_CLR_SET(SRSS_CLK_TIMER_CTL, CY_SRSS_CLK_TIMER_CTL_TIMER, source);
10004dda:	4a07      	ldr	r2, [pc, #28]	; (10004df8 <Cy_SysClk_ClkTimerSetSource+0x28>)
10004ddc:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
10004de0:	f020 00fe 	bic.w	r0, r0, #254	; 0xfe
10004de4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
10004de8:	0580      	lsls	r0, r0, #22
10004dea:	f023 0301 	bic.w	r3, r3, #1
10004dee:	0d80      	lsrs	r0, r0, #22
10004df0:	4303      	orrs	r3, r0
10004df2:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
10004df6:	4770      	bx	lr
10004df8:	40260000 	.word	0x40260000

10004dfc <Cy_SysClk_ClkTimerSetDivider>:
    CY_REG32_CLR_SET(SRSS_CLK_TIMER_CTL, SRSS_CLK_TIMER_CTL_TIMER_DIV, divider);
10004dfc:	4a04      	ldr	r2, [pc, #16]	; (10004e10 <Cy_SysClk_ClkTimerSetDivider+0x14>)
10004dfe:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
10004e02:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
10004e06:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
10004e0a:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
10004e0e:	4770      	bx	lr
10004e10:	40260000 	.word	0x40260000

10004e14 <Cy_SysClk_ClkTimerEnable>:
    SRSS_CLK_TIMER_CTL |= SRSS_CLK_TIMER_CTL_ENABLE_Msk;
10004e14:	4a03      	ldr	r2, [pc, #12]	; (10004e24 <Cy_SysClk_ClkTimerEnable+0x10>)
10004e16:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
10004e1a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
10004e1e:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
10004e22:	4770      	bx	lr
10004e24:	40260000 	.word	0x40260000

10004e28 <Cy_SysClk_ClkTimerIsEnabled>:
    return (_FLD2BOOL(SRSS_CLK_TIMER_CTL_ENABLE, SRSS_CLK_TIMER_CTL));
10004e28:	4b02      	ldr	r3, [pc, #8]	; (10004e34 <Cy_SysClk_ClkTimerIsEnabled+0xc>)
10004e2a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
}
10004e2e:	0fc0      	lsrs	r0, r0, #31
10004e30:	4770      	bx	lr
10004e32:	bf00      	nop
10004e34:	40260000 	.word	0x40260000

10004e38 <Cy_SysClk_ClkTimerDisable>:
    SRSS_CLK_TIMER_CTL &= ~SRSS_CLK_TIMER_CTL_ENABLE_Msk;
10004e38:	4a03      	ldr	r2, [pc, #12]	; (10004e48 <Cy_SysClk_ClkTimerDisable+0x10>)
10004e3a:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
10004e3e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10004e42:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
10004e46:	4770      	bx	lr
10004e48:	40260000 	.word	0x40260000

10004e4c <Cy_SysClk_ClkLfSetSource>:
    CY_ASSERT_L3(source <= CY_SYSCLK_CLKLF_IN_PILO);
10004e4c:	2803      	cmp	r0, #3
10004e4e:	d900      	bls.n	10004e52 <Cy_SysClk_ClkLfSetSource+0x6>
10004e50:	be01      	bkpt	0x0001
    CY_REG32_CLR_SET(SRSS_CLK_SELECT, SRSS_CLK_SELECT_LFCLK_SEL, source);
10004e52:	4a05      	ldr	r2, [pc, #20]	; (10004e68 <Cy_SysClk_ClkLfSetSource+0x1c>)
10004e54:	f8d2 3500 	ldr.w	r3, [r2, #1280]	; 0x500
10004e58:	f000 0003 	and.w	r0, r0, #3
10004e5c:	f023 0303 	bic.w	r3, r3, #3
10004e60:	4303      	orrs	r3, r0
10004e62:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
}
10004e66:	4770      	bx	lr
10004e68:	40260000 	.word	0x40260000

10004e6c <Cy_SysClk_ClkLfGetSource>:
    return ((cy_en_clklf_in_sources_t)(((uint32_t)_FLD2VAL(SRSS_CLK_SELECT_LFCLK_SEL, SRSS_CLK_SELECT))));
10004e6c:	4b02      	ldr	r3, [pc, #8]	; (10004e78 <Cy_SysClk_ClkLfGetSource+0xc>)
10004e6e:	f8d3 0500 	ldr.w	r0, [r3, #1280]	; 0x500
}
10004e72:	f000 0003 	and.w	r0, r0, #3
10004e76:	4770      	bx	lr
10004e78:	40260000 	.word	0x40260000

10004e7c <Cy_SysClk_ClkPeriSetDivider>:
    CY_REG32_CLR_SET(CPUSS_CM0_CLOCK_CTL, CPUSS_CM0_CLOCK_CTL_PERI_INT_DIV, divider);
10004e7c:	4b05      	ldr	r3, [pc, #20]	; (10004e94 <Cy_SysClk_ClkPeriSetDivider+0x18>)
10004e7e:	681b      	ldr	r3, [r3, #0]
10004e80:	6819      	ldr	r1, [r3, #0]
10004e82:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
10004e86:	588b      	ldr	r3, [r1, r2]
10004e88:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
10004e8c:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
10004e90:	508b      	str	r3, [r1, r2]
}
10004e92:	4770      	bx	lr
10004e94:	08003550 	.word	0x08003550

10004e98 <Cy_SysClk_ClkPeriGetDivider>:
    return ((uint8_t)_FLD2VAL(CPUSS_CM0_CLOCK_CTL_PERI_INT_DIV, CPUSS_CM0_CLOCK_CTL));
10004e98:	4b03      	ldr	r3, [pc, #12]	; (10004ea8 <Cy_SysClk_ClkPeriGetDivider+0x10>)
10004e9a:	681b      	ldr	r3, [r3, #0]
10004e9c:	681a      	ldr	r2, [r3, #0]
10004e9e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
10004ea2:	58d0      	ldr	r0, [r2, r3]
}
10004ea4:	0e00      	lsrs	r0, r0, #24
10004ea6:	4770      	bx	lr
10004ea8:	08003550 	.word	0x08003550

10004eac <Cy_SysClk_ClkFastSetDivider>:
    CY_REG32_CLR_SET(CPUSS_CM4_CLOCK_CTL, CPUSS_CM4_CLOCK_CTL_FAST_INT_DIV, divider);
10004eac:	4b05      	ldr	r3, [pc, #20]	; (10004ec4 <Cy_SysClk_ClkFastSetDivider+0x18>)
10004eae:	681b      	ldr	r3, [r3, #0]
10004eb0:	6819      	ldr	r1, [r3, #0]
10004eb2:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
10004eb6:	588b      	ldr	r3, [r1, r2]
10004eb8:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
10004ebc:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
10004ec0:	508b      	str	r3, [r1, r2]
}
10004ec2:	4770      	bx	lr
10004ec4:	08003550 	.word	0x08003550

10004ec8 <Cy_SysClk_ClkFastGetDivider>:
    return ((uint8_t)_FLD2VAL(CPUSS_CM4_CLOCK_CTL_FAST_INT_DIV, CPUSS_CM4_CLOCK_CTL));
10004ec8:	4b04      	ldr	r3, [pc, #16]	; (10004edc <Cy_SysClk_ClkFastGetDivider+0x14>)
10004eca:	681b      	ldr	r3, [r3, #0]
10004ecc:	681a      	ldr	r2, [r3, #0]
10004ece:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
10004ed2:	58d0      	ldr	r0, [r2, r3]
}
10004ed4:	f3c0 2007 	ubfx	r0, r0, #8, #8
10004ed8:	4770      	bx	lr
10004eda:	bf00      	nop
10004edc:	08003550 	.word	0x08003550

10004ee0 <Cy_SysClk_ClkHfEnable>:
    if (clkHf < CY_SRSS_NUM_HFROOT)
10004ee0:	4b0a      	ldr	r3, [pc, #40]	; (10004f0c <Cy_SysClk_ClkHfEnable+0x2c>)
10004ee2:	681b      	ldr	r3, [r3, #0]
10004ee4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
10004ee8:	4283      	cmp	r3, r0
        SRSS_CLK_ROOT_SELECT[clkHf] |= SRSS_CLK_ROOT_SELECT_ENABLE_Msk;
10004eea:	bf81      	itttt	hi
10004eec:	0080      	lslhi	r0, r0, #2
10004eee:	f100 4080 	addhi.w	r0, r0, #1073741824	; 0x40000000
10004ef2:	f500 1018 	addhi.w	r0, r0, #2490368	; 0x260000
10004ef6:	f8d0 3380 	ldrhi.w	r3, [r0, #896]	; 0x380
10004efa:	bf83      	ittte	hi
10004efc:	f043 4300 	orrhi.w	r3, r3, #2147483648	; 0x80000000
10004f00:	f8c0 3380 	strhi.w	r3, [r0, #896]	; 0x380
        retVal = CY_SYSCLK_SUCCESS;
10004f04:	2000      	movhi	r0, #0
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10004f06:	4802      	ldrls	r0, [pc, #8]	; (10004f10 <Cy_SysClk_ClkHfEnable+0x30>)
}
10004f08:	4770      	bx	lr
10004f0a:	bf00      	nop
10004f0c:	08003550 	.word	0x08003550
10004f10:	004a0001 	.word	0x004a0001

10004f14 <Cy_SysClk_ClkHfIsEnabled>:
    if (clkHf < CY_SRSS_NUM_HFROOT)
10004f14:	4b06      	ldr	r3, [pc, #24]	; (10004f30 <Cy_SysClk_ClkHfIsEnabled+0x1c>)
10004f16:	681b      	ldr	r3, [r3, #0]
10004f18:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
10004f1c:	4283      	cmp	r3, r0
        retVal = _FLD2BOOL(SRSS_CLK_ROOT_SELECT_ENABLE, SRSS_CLK_ROOT_SELECT[clkHf]);
10004f1e:	bf81      	itttt	hi
10004f20:	30e0      	addhi	r0, #224	; 0xe0
10004f22:	4b04      	ldrhi	r3, [pc, #16]	; (10004f34 <Cy_SysClk_ClkHfIsEnabled+0x20>)
10004f24:	f853 0020 	ldrhi.w	r0, [r3, r0, lsl #2]
10004f28:	0fc0      	lsrhi	r0, r0, #31
    bool retVal = false;
10004f2a:	bf98      	it	ls
10004f2c:	2000      	movls	r0, #0
}
10004f2e:	4770      	bx	lr
10004f30:	08003550 	.word	0x08003550
10004f34:	40260000 	.word	0x40260000

10004f38 <Cy_SysClk_ClkHfDisable>:
    if ((0UL < clkHf) /* prevent CLK_HF0 disabling */
10004f38:	b190      	cbz	r0, 10004f60 <Cy_SysClk_ClkHfDisable+0x28>
           && (clkHf < CY_SRSS_NUM_HFROOT))
10004f3a:	4b0a      	ldr	r3, [pc, #40]	; (10004f64 <Cy_SysClk_ClkHfDisable+0x2c>)
10004f3c:	681b      	ldr	r3, [r3, #0]
10004f3e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
10004f42:	4283      	cmp	r3, r0
10004f44:	d90c      	bls.n	10004f60 <Cy_SysClk_ClkHfDisable+0x28>
        SRSS_CLK_ROOT_SELECT[clkHf] &= ~SRSS_CLK_ROOT_SELECT_ENABLE_Msk;
10004f46:	0080      	lsls	r0, r0, #2
10004f48:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
10004f4c:	f500 1018 	add.w	r0, r0, #2490368	; 0x260000
10004f50:	f8d0 3380 	ldr.w	r3, [r0, #896]	; 0x380
10004f54:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10004f58:	f8c0 3380 	str.w	r3, [r0, #896]	; 0x380
        retVal = CY_SYSCLK_SUCCESS;
10004f5c:	2000      	movs	r0, #0
10004f5e:	4770      	bx	lr
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10004f60:	4801      	ldr	r0, [pc, #4]	; (10004f68 <Cy_SysClk_ClkHfDisable+0x30>)
}
10004f62:	4770      	bx	lr
10004f64:	08003550 	.word	0x08003550
10004f68:	004a0001 	.word	0x004a0001

10004f6c <Cy_SysClk_ClkHfSetSource>:
    if ((clkHf < CY_SRSS_NUM_HFROOT) && (source <= CY_SYSCLK_CLKHF_IN_CLKPATH15))
10004f6c:	4b0b      	ldr	r3, [pc, #44]	; (10004f9c <Cy_SysClk_ClkHfSetSource+0x30>)
10004f6e:	681b      	ldr	r3, [r3, #0]
10004f70:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
10004f74:	4283      	cmp	r3, r0
10004f76:	d90f      	bls.n	10004f98 <Cy_SysClk_ClkHfSetSource+0x2c>
10004f78:	290f      	cmp	r1, #15
10004f7a:	d80d      	bhi.n	10004f98 <Cy_SysClk_ClkHfSetSource+0x2c>
        CY_REG32_CLR_SET(SRSS_CLK_ROOT_SELECT[clkHf], SRSS_CLK_ROOT_SELECT_ROOT_MUX, source);
10004f7c:	0080      	lsls	r0, r0, #2
10004f7e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
10004f82:	f500 1018 	add.w	r0, r0, #2490368	; 0x260000
10004f86:	f8d0 3380 	ldr.w	r3, [r0, #896]	; 0x380
10004f8a:	f023 030f 	bic.w	r3, r3, #15
10004f8e:	4319      	orrs	r1, r3
10004f90:	f8c0 1380 	str.w	r1, [r0, #896]	; 0x380
        retVal = CY_SYSCLK_SUCCESS;
10004f94:	2000      	movs	r0, #0
10004f96:	4770      	bx	lr
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10004f98:	4801      	ldr	r0, [pc, #4]	; (10004fa0 <Cy_SysClk_ClkHfSetSource+0x34>)
}
10004f9a:	4770      	bx	lr
10004f9c:	08003550 	.word	0x08003550
10004fa0:	004a0001 	.word	0x004a0001

10004fa4 <Cy_SysClk_ClkHfGetSource>:
    CY_ASSERT_L1(clkHf < CY_SRSS_NUM_HFROOT);
10004fa4:	4b06      	ldr	r3, [pc, #24]	; (10004fc0 <Cy_SysClk_ClkHfGetSource+0x1c>)
10004fa6:	681b      	ldr	r3, [r3, #0]
10004fa8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
10004fac:	4283      	cmp	r3, r0
10004fae:	d800      	bhi.n	10004fb2 <Cy_SysClk_ClkHfGetSource+0xe>
10004fb0:	be01      	bkpt	0x0001
    return ((cy_en_clkhf_in_sources_t)((uint32_t)(_FLD2VAL(SRSS_CLK_ROOT_SELECT_ROOT_MUX, SRSS_CLK_ROOT_SELECT[clkHf]))));
10004fb2:	4b04      	ldr	r3, [pc, #16]	; (10004fc4 <Cy_SysClk_ClkHfGetSource+0x20>)
10004fb4:	30e0      	adds	r0, #224	; 0xe0
10004fb6:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
10004fba:	f000 000f 	and.w	r0, r0, #15
10004fbe:	4770      	bx	lr
10004fc0:	08003550 	.word	0x08003550
10004fc4:	40260000 	.word	0x40260000

10004fc8 <Cy_SysClk_ClkHfSetDivider>:
    if ((clkHf < CY_SRSS_NUM_HFROOT) && (divider <= CY_SYSCLK_CLKHF_DIVIDE_BY_8))
10004fc8:	4b0c      	ldr	r3, [pc, #48]	; (10004ffc <Cy_SysClk_ClkHfSetDivider+0x34>)
10004fca:	681b      	ldr	r3, [r3, #0]
10004fcc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
10004fd0:	4283      	cmp	r3, r0
10004fd2:	d910      	bls.n	10004ff6 <Cy_SysClk_ClkHfSetDivider+0x2e>
10004fd4:	2903      	cmp	r1, #3
10004fd6:	d80e      	bhi.n	10004ff6 <Cy_SysClk_ClkHfSetDivider+0x2e>
        CY_REG32_CLR_SET(SRSS_CLK_ROOT_SELECT[clkHf], SRSS_CLK_ROOT_SELECT_ROOT_DIV, divider);
10004fd8:	0080      	lsls	r0, r0, #2
10004fda:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
10004fde:	f500 1018 	add.w	r0, r0, #2490368	; 0x260000
10004fe2:	f8d0 3380 	ldr.w	r3, [r0, #896]	; 0x380
10004fe6:	f023 0330 	bic.w	r3, r3, #48	; 0x30
10004fea:	ea43 1101 	orr.w	r1, r3, r1, lsl #4
10004fee:	f8c0 1380 	str.w	r1, [r0, #896]	; 0x380
        retVal = CY_SYSCLK_SUCCESS;
10004ff2:	2000      	movs	r0, #0
10004ff4:	4770      	bx	lr
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10004ff6:	4802      	ldr	r0, [pc, #8]	; (10005000 <Cy_SysClk_ClkHfSetDivider+0x38>)
}
10004ff8:	4770      	bx	lr
10004ffa:	bf00      	nop
10004ffc:	08003550 	.word	0x08003550
10005000:	004a0001 	.word	0x004a0001

10005004 <Cy_SysClk_ClkHfGetDivider>:
    CY_ASSERT_L1(clkHf < CY_SRSS_NUM_HFROOT);
10005004:	4b06      	ldr	r3, [pc, #24]	; (10005020 <Cy_SysClk_ClkHfGetDivider+0x1c>)
10005006:	681b      	ldr	r3, [r3, #0]
10005008:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
1000500c:	4283      	cmp	r3, r0
1000500e:	d800      	bhi.n	10005012 <Cy_SysClk_ClkHfGetDivider+0xe>
10005010:	be01      	bkpt	0x0001
    return ((cy_en_clkhf_dividers_t)(((uint32_t)_FLD2VAL(SRSS_CLK_ROOT_SELECT_ROOT_DIV, SRSS_CLK_ROOT_SELECT[clkHf]))));
10005012:	4b04      	ldr	r3, [pc, #16]	; (10005024 <Cy_SysClk_ClkHfGetDivider+0x20>)
10005014:	30e0      	adds	r0, #224	; 0xe0
10005016:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
1000501a:	f3c0 1001 	ubfx	r0, r0, #4, #2
1000501e:	4770      	bx	lr
10005020:	08003550 	.word	0x08003550
10005024:	40260000 	.word	0x40260000

10005028 <Cy_SysClk_WcoOkay>:
    return (_FLD2BOOL(BACKUP_STATUS_WCO_OK, BACKUP_STATUS));
10005028:	4b02      	ldr	r3, [pc, #8]	; (10005034 <Cy_SysClk_WcoOkay+0xc>)
1000502a:	6918      	ldr	r0, [r3, #16]
}
1000502c:	f3c0 0080 	ubfx	r0, r0, #2, #1
10005030:	4770      	bx	lr
10005032:	bf00      	nop
10005034:	40270000 	.word	0x40270000

10005038 <Cy_SysClk_WcoEnable>:
{
10005038:	b510      	push	{r4, lr}
    BACKUP_CTL |= BACKUP_CTL_WCO_EN_Msk;
1000503a:	4a0b      	ldr	r2, [pc, #44]	; (10005068 <Cy_SysClk_WcoEnable+0x30>)
1000503c:	6813      	ldr	r3, [r2, #0]
1000503e:	f043 0308 	orr.w	r3, r3, #8
{
10005042:	4604      	mov	r4, r0
    BACKUP_CTL |= BACKUP_CTL_WCO_EN_Msk;
10005044:	6013      	str	r3, [r2, #0]
    for (; (Cy_SysClk_WcoOkay() == false) && (0UL != timeoutus); timeoutus--)
10005046:	f7ff ffef 	bl	10005028 <Cy_SysClk_WcoOkay>
1000504a:	b938      	cbnz	r0, 1000505c <Cy_SysClk_WcoEnable+0x24>
1000504c:	b90c      	cbnz	r4, 10005052 <Cy_SysClk_WcoEnable+0x1a>
    retVal = CY_SYSCLK_TIMEOUT;
1000504e:	4807      	ldr	r0, [pc, #28]	; (1000506c <Cy_SysClk_WcoEnable+0x34>)
}
10005050:	bd10      	pop	{r4, pc}
        Cy_SysLib_DelayUs(1U);
10005052:	2001      	movs	r0, #1
10005054:	f000 fcc6 	bl	100059e4 <Cy_SysLib_DelayUs>
    for (; (Cy_SysClk_WcoOkay() == false) && (0UL != timeoutus); timeoutus--)
10005058:	3c01      	subs	r4, #1
1000505a:	e7f4      	b.n	10005046 <Cy_SysClk_WcoEnable+0xe>
        retVal = CY_SYSCLK_SUCCESS;
1000505c:	2c00      	cmp	r4, #0
1000505e:	4803      	ldr	r0, [pc, #12]	; (1000506c <Cy_SysClk_WcoEnable+0x34>)
10005060:	bf18      	it	ne
10005062:	2000      	movne	r0, #0
10005064:	e7f4      	b.n	10005050 <Cy_SysClk_WcoEnable+0x18>
10005066:	bf00      	nop
10005068:	40270000 	.word	0x40270000
1000506c:	004a0002 	.word	0x004a0002

10005070 <Cy_SysClk_WcoDisable>:
    BACKUP_CTL &= (uint32_t)~BACKUP_CTL_WCO_EN_Msk;
10005070:	4a02      	ldr	r2, [pc, #8]	; (1000507c <Cy_SysClk_WcoDisable+0xc>)
10005072:	6813      	ldr	r3, [r2, #0]
10005074:	f023 0308 	bic.w	r3, r3, #8
10005078:	6013      	str	r3, [r2, #0]
}
1000507a:	4770      	bx	lr
1000507c:	40270000 	.word	0x40270000

10005080 <Cy_SysClk_IloEnable>:
    SRSS_CLK_ILO_CONFIG |= SRSS_CLK_ILO_CONFIG_ENABLE_Msk;
10005080:	4a03      	ldr	r2, [pc, #12]	; (10005090 <Cy_SysClk_IloEnable+0x10>)
10005082:	f8d2 350c 	ldr.w	r3, [r2, #1292]	; 0x50c
10005086:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
1000508a:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
}
1000508e:	4770      	bx	lr
10005090:	40260000 	.word	0x40260000

10005094 <Cy_SysClk_IloIsEnabled>:
    return (_FLD2BOOL(SRSS_CLK_ILO_CONFIG_ENABLE, SRSS_CLK_ILO_CONFIG));
10005094:	4b02      	ldr	r3, [pc, #8]	; (100050a0 <Cy_SysClk_IloIsEnabled+0xc>)
10005096:	f8d3 050c 	ldr.w	r0, [r3, #1292]	; 0x50c
}
1000509a:	0fc0      	lsrs	r0, r0, #31
1000509c:	4770      	bx	lr
1000509e:	bf00      	nop
100050a0:	40260000 	.word	0x40260000

100050a4 <Cy_SysClk_IloDisable>:
    if (!_FLD2BOOL(SRSS_WDT_CTL_WDT_EN, SRSS_WDT_CTL)) /* if disabled */
100050a4:	4b06      	ldr	r3, [pc, #24]	; (100050c0 <Cy_SysClk_IloDisable+0x1c>)
100050a6:	f8d3 0180 	ldr.w	r0, [r3, #384]	; 0x180
100050aa:	f010 0001 	ands.w	r0, r0, #1
        SRSS_CLK_ILO_CONFIG &= ~SRSS_CLK_ILO_CONFIG_ENABLE_Msk;
100050ae:	bf09      	itett	eq
100050b0:	f8d3 250c 	ldreq.w	r2, [r3, #1292]	; 0x50c
    retVal = CY_SYSCLK_INVALID_STATE;
100050b4:	4803      	ldrne	r0, [pc, #12]	; (100050c4 <Cy_SysClk_IloDisable+0x20>)
        SRSS_CLK_ILO_CONFIG &= ~SRSS_CLK_ILO_CONFIG_ENABLE_Msk;
100050b6:	f022 4200 	biceq.w	r2, r2, #2147483648	; 0x80000000
100050ba:	f8c3 250c 	streq.w	r2, [r3, #1292]	; 0x50c
}
100050be:	4770      	bx	lr
100050c0:	40260000 	.word	0x40260000
100050c4:	004a0003 	.word	0x004a0003

100050c8 <Cy_SysClk_ExtClkSetFrequency>:
    if (freq <= CY_SYSCLK_EXTCLK_MAX_FREQ)
100050c8:	4b02      	ldr	r3, [pc, #8]	; (100050d4 <Cy_SysClk_ExtClkSetFrequency+0xc>)
100050ca:	4298      	cmp	r0, r3
        cySysClkExtFreq = freq;
100050cc:	bf9c      	itt	ls
100050ce:	4b02      	ldrls	r3, [pc, #8]	; (100050d8 <Cy_SysClk_ExtClkSetFrequency+0x10>)
100050d0:	6018      	strls	r0, [r3, #0]
}
100050d2:	4770      	bx	lr
100050d4:	05f5e100 	.word	0x05f5e100
100050d8:	080036f4 	.word	0x080036f4

100050dc <Cy_SysClk_ExtClkGetFrequency>:
}
100050dc:	4b01      	ldr	r3, [pc, #4]	; (100050e4 <Cy_SysClk_ExtClkGetFrequency+0x8>)
100050de:	6818      	ldr	r0, [r3, #0]
100050e0:	4770      	bx	lr
100050e2:	bf00      	nop
100050e4:	080036f4 	.word	0x080036f4

100050e8 <Cy_SysClk_EcoDisable>:
    SRSS_CLK_ECO_CONFIG &= ~SRSS_CLK_ECO_CONFIG_ECO_EN_Msk;
100050e8:	4a03      	ldr	r2, [pc, #12]	; (100050f8 <Cy_SysClk_EcoDisable+0x10>)
100050ea:	f8d2 352c 	ldr.w	r3, [r2, #1324]	; 0x52c
100050ee:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
100050f2:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
}
100050f6:	4770      	bx	lr
100050f8:	40260000 	.word	0x40260000

100050fc <Cy_SysClk_EcoGetStatus>:
    return ((SRSS_CLK_ECO_STATUS_Msk == (SRSS_CLK_ECO_STATUS_Msk & SRSS_CLK_ECO_STATUS)) ?
100050fc:	4a06      	ldr	r2, [pc, #24]	; (10005118 <Cy_SysClk_EcoGetStatus+0x1c>)
100050fe:	f8d2 3530 	ldr.w	r3, [r2, #1328]	; 0x530
10005102:	f003 0303 	and.w	r3, r3, #3
      CY_SYSCLK_ECOSTAT_STABLE : (SRSS_CLK_ECO_STATUS_ECO_OK_Msk & SRSS_CLK_ECO_STATUS));
10005106:	2b03      	cmp	r3, #3
10005108:	bf1a      	itte	ne
1000510a:	f8d2 0530 	ldrne.w	r0, [r2, #1328]	; 0x530
1000510e:	f000 0001 	andne.w	r0, r0, #1
10005112:	2002      	moveq	r0, #2
}
10005114:	4770      	bx	lr
10005116:	bf00      	nop
10005118:	40260000 	.word	0x40260000

1000511c <Cy_SysClk_EcoEnable>:
{
1000511c:	b538      	push	{r3, r4, r5, lr}
    if (0UL == (SRSS_CLK_ECO_CONFIG_ECO_EN_Msk & SRSS_CLK_ECO_CONFIG))
1000511e:	4b14      	ldr	r3, [pc, #80]	; (10005170 <Cy_SysClk_EcoEnable+0x54>)
10005120:	f8d3 252c 	ldr.w	r2, [r3, #1324]	; 0x52c
10005124:	2a00      	cmp	r2, #0
{
10005126:	4604      	mov	r4, r0
    if (0UL == (SRSS_CLK_ECO_CONFIG_ECO_EN_Msk & SRSS_CLK_ECO_CONFIG))
10005128:	db1e      	blt.n	10005168 <Cy_SysClk_EcoEnable+0x4c>
        SRSS_CLK_ECO_CONFIG |= SRSS_CLK_ECO_CONFIG_ECO_EN_Msk;
1000512a:	f8d3 252c 	ldr.w	r2, [r3, #1324]	; 0x52c
1000512e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
10005132:	f8c3 252c 	str.w	r2, [r3, #1324]	; 0x52c
        for (; (CY_SYSCLK_ECOSTAT_STABLE != Cy_SysClk_EcoGetStatus()) && (0UL != timeoutus); timeoutus--)
10005136:	4605      	mov	r5, r0
10005138:	f7ff ffe0 	bl	100050fc <Cy_SysClk_EcoGetStatus>
1000513c:	2802      	cmp	r0, #2
1000513e:	d007      	beq.n	10005150 <Cy_SysClk_EcoEnable+0x34>
10005140:	b90d      	cbnz	r5, 10005146 <Cy_SysClk_EcoEnable+0x2a>
        if (zeroTimeout || (0UL != timeoutus))
10005142:	b17c      	cbz	r4, 10005164 <Cy_SysClk_EcoEnable+0x48>
10005144:	e006      	b.n	10005154 <Cy_SysClk_EcoEnable+0x38>
            Cy_SysLib_DelayUs(1U);
10005146:	2001      	movs	r0, #1
10005148:	f000 fc4c 	bl	100059e4 <Cy_SysLib_DelayUs>
        for (; (CY_SYSCLK_ECOSTAT_STABLE != Cy_SysClk_EcoGetStatus()) && (0UL != timeoutus); timeoutus--)
1000514c:	3d01      	subs	r5, #1
1000514e:	e7f3      	b.n	10005138 <Cy_SysClk_EcoEnable+0x1c>
        if (zeroTimeout || (0UL != timeoutus))
10005150:	b144      	cbz	r4, 10005164 <Cy_SysClk_EcoEnable+0x48>
10005152:	b95d      	cbnz	r5, 1000516c <Cy_SysClk_EcoEnable+0x50>
            SRSS_CLK_ECO_CONFIG &= ~SRSS_CLK_ECO_CONFIG_ECO_EN_Msk;
10005154:	4a06      	ldr	r2, [pc, #24]	; (10005170 <Cy_SysClk_EcoEnable+0x54>)
            retVal = CY_SYSCLK_TIMEOUT;
10005156:	4c07      	ldr	r4, [pc, #28]	; (10005174 <Cy_SysClk_EcoEnable+0x58>)
            SRSS_CLK_ECO_CONFIG &= ~SRSS_CLK_ECO_CONFIG_ECO_EN_Msk;
10005158:	f8d2 352c 	ldr.w	r3, [r2, #1324]	; 0x52c
1000515c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10005160:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
}
10005164:	4620      	mov	r0, r4
10005166:	bd38      	pop	{r3, r4, r5, pc}
    retVal = CY_SYSCLK_INVALID_STATE;
10005168:	4c03      	ldr	r4, [pc, #12]	; (10005178 <Cy_SysClk_EcoEnable+0x5c>)
1000516a:	e7fb      	b.n	10005164 <Cy_SysClk_EcoEnable+0x48>
            retVal = CY_SYSCLK_SUCCESS;
1000516c:	2400      	movs	r4, #0
1000516e:	e7f9      	b.n	10005164 <Cy_SysClk_EcoEnable+0x48>
10005170:	40260000 	.word	0x40260000
10005174:	004a0002 	.word	0x004a0002
10005178:	004a0003 	.word	0x004a0003

1000517c <Cy_SysClk_EcoGetFrequency>:
{
1000517c:	b508      	push	{r3, lr}
    return ((CY_SYSCLK_ECOSTAT_STABLE == Cy_SysClk_EcoGetStatus()) ? ecoFrequency : 0UL);
1000517e:	f7ff ffbd 	bl	100050fc <Cy_SysClk_EcoGetStatus>
10005182:	2802      	cmp	r0, #2
10005184:	bf0a      	itet	eq
10005186:	4b02      	ldreq	r3, [pc, #8]	; (10005190 <Cy_SysClk_EcoGetFrequency+0x14>)
10005188:	2000      	movne	r0, #0
1000518a:	6818      	ldreq	r0, [r3, #0]
}
1000518c:	bd08      	pop	{r3, pc}
1000518e:	bf00      	nop
10005190:	080036f0 	.word	0x080036f0

10005194 <Cy_SysClk_ClkPathSetSource>:
    if ((clkPath < CY_SRSS_NUM_CLKPATH) &&
10005194:	4b10      	ldr	r3, [pc, #64]	; (100051d8 <Cy_SysClk_ClkPathSetSource+0x44>)
10005196:	681b      	ldr	r3, [r3, #0]
10005198:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
1000519c:	4283      	cmp	r3, r0
1000519e:	d918      	bls.n	100051d2 <Cy_SysClk_ClkPathSetSource+0x3e>
100051a0:	2904      	cmp	r1, #4
100051a2:	d911      	bls.n	100051c8 <Cy_SysClk_ClkPathSetSource+0x34>
        ((source <= CY_SYSCLK_CLKPATH_IN_DSIMUX) ||
100051a4:	f5a1 7380 	sub.w	r3, r1, #256	; 0x100
100051a8:	2b13      	cmp	r3, #19
100051aa:	d812      	bhi.n	100051d2 <Cy_SysClk_ClkPathSetSource+0x3e>
            SRSS_CLK_DSI_SELECT[clkPath] = _VAL2FLD(SRSS_CLK_DSI_SELECT_DSI_MUX, (uint32_t)source);
100051ac:	0080      	lsls	r0, r0, #2
100051ae:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
100051b2:	f500 1018 	add.w	r0, r0, #2490368	; 0x260000
100051b6:	f001 011f 	and.w	r1, r1, #31
            SRSS_CLK_PATH_SELECT[clkPath] = _VAL2FLD(SRSS_CLK_PATH_SELECT_PATH_MUX, (uint32_t)CY_SYSCLK_CLKPATH_IN_DSIMUX);
100051ba:	2304      	movs	r3, #4
            SRSS_CLK_DSI_SELECT[clkPath] = _VAL2FLD(SRSS_CLK_DSI_SELECT_DSI_MUX, (uint32_t)source);
100051bc:	f8c0 1300 	str.w	r1, [r0, #768]	; 0x300
            SRSS_CLK_PATH_SELECT[clkPath] = _VAL2FLD(SRSS_CLK_PATH_SELECT_PATH_MUX, (uint32_t)CY_SYSCLK_CLKPATH_IN_DSIMUX);
100051c0:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
        retVal = CY_SYSCLK_SUCCESS;
100051c4:	2000      	movs	r0, #0
100051c6:	4770      	bx	lr
            SRSS_CLK_PATH_SELECT[clkPath] = _VAL2FLD(SRSS_CLK_PATH_SELECT_PATH_MUX, (uint32_t)source);
100051c8:	4b04      	ldr	r3, [pc, #16]	; (100051dc <Cy_SysClk_ClkPathSetSource+0x48>)
100051ca:	30d0      	adds	r0, #208	; 0xd0
100051cc:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
100051d0:	e7f8      	b.n	100051c4 <Cy_SysClk_ClkPathSetSource+0x30>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
100051d2:	4803      	ldr	r0, [pc, #12]	; (100051e0 <Cy_SysClk_ClkPathSetSource+0x4c>)
}
100051d4:	4770      	bx	lr
100051d6:	bf00      	nop
100051d8:	08003550 	.word	0x08003550
100051dc:	40260000 	.word	0x40260000
100051e0:	004a0001 	.word	0x004a0001

100051e4 <Cy_SysClk_ClkPathGetSource>:
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
100051e4:	4b0c      	ldr	r3, [pc, #48]	; (10005218 <Cy_SysClk_ClkPathGetSource+0x34>)
100051e6:	681b      	ldr	r3, [r3, #0]
100051e8:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
100051ec:	4283      	cmp	r3, r0
100051ee:	d800      	bhi.n	100051f2 <Cy_SysClk_ClkPathGetSource+0xe>
100051f0:	be01      	bkpt	0x0001
    cy_en_clkpath_in_sources_t retVal =
100051f2:	0080      	lsls	r0, r0, #2
100051f4:	f100 4380 	add.w	r3, r0, #1073741824	; 0x40000000
100051f8:	f503 1318 	add.w	r3, r3, #2490368	; 0x260000
        (cy_en_clkpath_in_sources_t )((uint32_t)_FLD2VAL(SRSS_CLK_PATH_SELECT_PATH_MUX, SRSS_CLK_PATH_SELECT[clkPath]));
100051fc:	f8d3 0340 	ldr.w	r0, [r3, #832]	; 0x340
    cy_en_clkpath_in_sources_t retVal =
10005200:	f000 0007 	and.w	r0, r0, #7
    if (retVal == CY_SYSCLK_CLKPATH_IN_DSIMUX)
10005204:	2804      	cmp	r0, #4
                    ((uint32_t)(_FLD2VAL(SRSS_CLK_DSI_SELECT_DSI_MUX, SRSS_CLK_DSI_SELECT[clkPath])))));
10005206:	bf02      	ittt	eq
10005208:	f8d3 0300 	ldreq.w	r0, [r3, #768]	; 0x300
1000520c:	f000 001f 	andeq.w	r0, r0, #31
        retVal = (cy_en_clkpath_in_sources_t)((uint32_t)(((uint32_t)CY_SYSCLK_CLKPATH_IN_DSI) |
10005210:	f440 7080 	orreq.w	r0, r0, #256	; 0x100
}
10005214:	4770      	bx	lr
10005216:	bf00      	nop
10005218:	08003550 	.word	0x08003550

1000521c <Cy_SysClk_ClkPathMuxGetFrequency>:
{
1000521c:	b508      	push	{r3, lr}
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
1000521e:	4b1a      	ldr	r3, [pc, #104]	; (10005288 <Cy_SysClk_ClkPathMuxGetFrequency+0x6c>)
10005220:	681b      	ldr	r3, [r3, #0]
10005222:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
10005226:	4283      	cmp	r3, r0
10005228:	d800      	bhi.n	1000522c <Cy_SysClk_ClkPathMuxGetFrequency+0x10>
1000522a:	be01      	bkpt	0x0001
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
1000522c:	f7ff ffda 	bl	100051e4 <Cy_SysClk_ClkPathGetSource>
10005230:	f5b0 7f88 	cmp.w	r0, #272	; 0x110
10005234:	d01a      	beq.n	1000526c <Cy_SysClk_ClkPathMuxGetFrequency+0x50>
10005236:	d808      	bhi.n	1000524a <Cy_SysClk_ClkPathMuxGetFrequency+0x2e>
10005238:	2801      	cmp	r0, #1
1000523a:	d010      	beq.n	1000525e <Cy_SysClk_ClkPathMuxGetFrequency+0x42>
1000523c:	2802      	cmp	r0, #2
1000523e:	d011      	beq.n	10005264 <Cy_SysClk_ClkPathMuxGetFrequency+0x48>
10005240:	2800      	cmp	r0, #0
10005242:	4812      	ldr	r0, [pc, #72]	; (1000528c <Cy_SysClk_ClkPathMuxGetFrequency+0x70>)
10005244:	bf18      	it	ne
10005246:	2000      	movne	r0, #0
}
10005248:	bd08      	pop	{r3, pc}
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
1000524a:	f240 1311 	movw	r3, #273	; 0x111
1000524e:	4298      	cmp	r0, r3
10005250:	d011      	beq.n	10005276 <Cy_SysClk_ClkPathMuxGetFrequency+0x5a>
10005252:	f240 1313 	movw	r3, #275	; 0x113
10005256:	4298      	cmp	r0, r3
10005258:	d011      	beq.n	1000527e <Cy_SysClk_ClkPathMuxGetFrequency+0x62>
1000525a:	2000      	movs	r0, #0
1000525c:	e7f4      	b.n	10005248 <Cy_SysClk_ClkPathMuxGetFrequency+0x2c>
    return (cySysClkExtFreq);
1000525e:	4b0c      	ldr	r3, [pc, #48]	; (10005290 <Cy_SysClk_ClkPathMuxGetFrequency+0x74>)
10005260:	6818      	ldr	r0, [r3, #0]
            break;
10005262:	e7f1      	b.n	10005248 <Cy_SysClk_ClkPathMuxGetFrequency+0x2c>
}
10005264:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            freq = Cy_SysClk_EcoGetFrequency();
10005268:	f7ff bf88 	b.w	1000517c <Cy_SysClk_EcoGetFrequency>
            freq = (0UL != (SRSS_CLK_ILO_CONFIG & SRSS_CLK_ILO_CONFIG_ENABLE_Msk)) ? CY_SYSCLK_ILO_FREQ : 0UL;
1000526c:	4b09      	ldr	r3, [pc, #36]	; (10005294 <Cy_SysClk_ClkPathMuxGetFrequency+0x78>)
1000526e:	f8d3 050c 	ldr.w	r0, [r3, #1292]	; 0x50c
            freq = (0UL != (SRSS_CLK_PILO_CONFIG & SRSS_CLK_PILO_CONFIG_PILO_EN_Msk)) ? CY_SYSCLK_PILO_FREQ : 0UL;
10005272:	0fc0      	lsrs	r0, r0, #31
10005274:	e001      	b.n	1000527a <Cy_SysClk_ClkPathMuxGetFrequency+0x5e>
            freq = (Cy_SysClk_WcoOkay()) ? CY_SYSCLK_WCO_FREQ : 0UL;
10005276:	f7ff fed7 	bl	10005028 <Cy_SysClk_WcoOkay>
            freq = (0UL != (SRSS_CLK_PILO_CONFIG & SRSS_CLK_PILO_CONFIG_PILO_EN_Msk)) ? CY_SYSCLK_PILO_FREQ : 0UL;
1000527a:	03c0      	lsls	r0, r0, #15
1000527c:	e7e4      	b.n	10005248 <Cy_SysClk_ClkPathMuxGetFrequency+0x2c>
1000527e:	4b05      	ldr	r3, [pc, #20]	; (10005294 <Cy_SysClk_ClkPathMuxGetFrequency+0x78>)
10005280:	f8d3 053c 	ldr.w	r0, [r3, #1340]	; 0x53c
10005284:	e7f5      	b.n	10005272 <Cy_SysClk_ClkPathMuxGetFrequency+0x56>
10005286:	bf00      	nop
10005288:	08003550 	.word	0x08003550
1000528c:	007a1200 	.word	0x007a1200
10005290:	080036f4 	.word	0x080036f4
10005294:	40260000 	.word	0x40260000

10005298 <Cy_SysClk_FllIsEnabled>:
    return (_FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_ENABLE, SRSS_CLK_FLL_CONFIG));
10005298:	4b02      	ldr	r3, [pc, #8]	; (100052a4 <Cy_SysClk_FllIsEnabled+0xc>)
1000529a:	f8d3 0580 	ldr.w	r0, [r3, #1408]	; 0x580
}
1000529e:	0fc0      	lsrs	r0, r0, #31
100052a0:	4770      	bx	lr
100052a2:	bf00      	nop
100052a4:	40260000 	.word	0x40260000

100052a8 <Cy_SysClk_FllDisable>:
    CY_REG32_CLR_SET(SRSS_CLK_FLL_CONFIG3, SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_INPUT);
100052a8:	4b0b      	ldr	r3, [pc, #44]	; (100052d8 <Cy_SysClk_FllDisable+0x30>)
100052aa:	f8d3 2588 	ldr.w	r2, [r3, #1416]	; 0x588
100052ae:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
100052b2:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
100052b6:	f8c3 2588 	str.w	r2, [r3, #1416]	; 0x588
    SRSS_CLK_FLL_CONFIG  &= ~SRSS_CLK_FLL_CONFIG_FLL_ENABLE_Msk;
100052ba:	f8d3 2580 	ldr.w	r2, [r3, #1408]	; 0x580
100052be:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
100052c2:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
    SRSS_CLK_FLL_CONFIG4 &= ~SRSS_CLK_FLL_CONFIG4_CCO_ENABLE_Msk;
100052c6:	f8d3 258c 	ldr.w	r2, [r3, #1420]	; 0x58c
100052ca:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
100052ce:	f8c3 258c 	str.w	r2, [r3, #1420]	; 0x58c
}
100052d2:	2000      	movs	r0, #0
100052d4:	4770      	bx	lr
100052d6:	bf00      	nop
100052d8:	40260000 	.word	0x40260000

100052dc <Cy_SysClk_FllManualConfigure>:
#endif /* defined (CY_DEVICE_SECURE) */
#if ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE)))
    retVal = CY_SYSCLK_INVALID_STATE;

    /* Check for errors */
    CY_ASSERT_L1(config != NULL);
100052dc:	b900      	cbnz	r0, 100052e0 <Cy_SysClk_FllManualConfigure+0x4>
100052de:	be01      	bkpt	0x0001
    return (_FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_ENABLE, SRSS_CLK_FLL_CONFIG));
100052e0:	4b36      	ldr	r3, [pc, #216]	; (100053bc <Cy_SysClk_FllManualConfigure+0xe0>)
100052e2:	f8d3 3580 	ldr.w	r3, [r3, #1408]	; 0x580

    if (!Cy_SysClk_FllIsEnabled()) /* If disabled */
100052e6:	2b00      	cmp	r3, #0
100052e8:	db66      	blt.n	100053b8 <Cy_SysClk_FllManualConfigure+0xdc>
    {
        /* update CLK_FLL_CONFIG register with 2 parameters; FLL_ENABLE is already 0 */
        /* asserts just check for bitfield overflow */
        CY_ASSERT_L1(config->fllMult <= (SRSS_CLK_FLL_CONFIG_FLL_MULT_Msk >> SRSS_CLK_FLL_CONFIG_FLL_MULT_Pos));
100052ea:	6803      	ldr	r3, [r0, #0]
100052ec:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
100052f0:	d300      	bcc.n	100052f4 <Cy_SysClk_FllManualConfigure+0x18>
100052f2:	be01      	bkpt	0x0001

        SRSS_CLK_FLL_CONFIG = _VAL2FLD(SRSS_CLK_FLL_CONFIG_FLL_MULT, config->fllMult) |
100052f4:	6803      	ldr	r3, [r0, #0]
                             _BOOL2FLD(SRSS_CLK_FLL_CONFIG_FLL_OUTPUT_DIV, config->enableOutputDiv);
100052f6:	79c2      	ldrb	r2, [r0, #7]
        SRSS_CLK_FLL_CONFIG = _VAL2FLD(SRSS_CLK_FLL_CONFIG_FLL_MULT, config->fllMult) |
100052f8:	f3c3 0311 	ubfx	r3, r3, #0, #18
100052fc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
10005300:	4a2e      	ldr	r2, [pc, #184]	; (100053bc <Cy_SysClk_FllManualConfigure+0xe0>)
10005302:	f8c2 3580 	str.w	r3, [r2, #1408]	; 0x580

        /* update CLK_FLL_CONFIG2 register with 2 parameters */
        /* asserts just check for bitfield overflow */
        CY_ASSERT_L1(config->refDiv <= (SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV_Msk >> SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV_Pos));
10005306:	8883      	ldrh	r3, [r0, #4]
10005308:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
1000530c:	d300      	bcc.n	10005310 <Cy_SysClk_FllManualConfigure+0x34>
1000530e:	be01      	bkpt	0x0001
        CY_ASSERT_L1(config->lockTolerance <= (SRSS_CLK_FLL_CONFIG2_LOCK_TOL_Msk >> SRSS_CLK_FLL_CONFIG2_LOCK_TOL_Pos));
10005310:	8903      	ldrh	r3, [r0, #8]
10005312:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
10005316:	d300      	bcc.n	1000531a <Cy_SysClk_FllManualConfigure+0x3e>
10005318:	be01      	bkpt	0x0001

        SRSS_CLK_FLL_CONFIG2 = _VAL2FLD(SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV, config->refDiv) |
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG2_LOCK_TOL, config->lockTolerance);
1000531a:	8902      	ldrh	r2, [r0, #8]
1000531c:	4b28      	ldr	r3, [pc, #160]	; (100053c0 <Cy_SysClk_FllManualConfigure+0xe4>)
1000531e:	ea03 4302 	and.w	r3, r3, r2, lsl #16
        SRSS_CLK_FLL_CONFIG2 = _VAL2FLD(SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV, config->refDiv) |
10005322:	8882      	ldrh	r2, [r0, #4]
10005324:	f3c2 020c 	ubfx	r2, r2, #0, #13
10005328:	4313      	orrs	r3, r2
1000532a:	4a24      	ldr	r2, [pc, #144]	; (100053bc <Cy_SysClk_FllManualConfigure+0xe0>)
1000532c:	f8c2 3584 	str.w	r3, [r2, #1412]	; 0x584

        /* update CLK_FLL_CONFIG3 register with 4 parameters */
        /* asserts just check for bitfield overflow */
        CY_ASSERT_L1(config->igain <= (SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN_Msk >> SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN_Pos));
10005330:	7a83      	ldrb	r3, [r0, #10]
10005332:	2b0f      	cmp	r3, #15
10005334:	d900      	bls.n	10005338 <Cy_SysClk_FllManualConfigure+0x5c>
10005336:	be01      	bkpt	0x0001
        CY_ASSERT_L1(config->pgain <= (SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN_Msk >> SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN_Pos));
10005338:	7ac3      	ldrb	r3, [r0, #11]
1000533a:	2b0f      	cmp	r3, #15
1000533c:	d900      	bls.n	10005340 <Cy_SysClk_FllManualConfigure+0x64>
1000533e:	be01      	bkpt	0x0001
        CY_ASSERT_L1(config->settlingCount <= (SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT_Msk >> SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT_Pos));
10005340:	8983      	ldrh	r3, [r0, #12]
10005342:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
10005346:	d300      	bcc.n	1000534a <Cy_SysClk_FllManualConfigure+0x6e>
10005348:	be01      	bkpt	0x0001

        SRSS_CLK_FLL_CONFIG3 = _VAL2FLD(SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN, config->igain) |
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN, config->pgain) |
1000534a:	7ac3      	ldrb	r3, [r0, #11]
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT, config->settlingCount) |
1000534c:	8981      	ldrh	r1, [r0, #12]
1000534e:	4a1d      	ldr	r2, [pc, #116]	; (100053c4 <Cy_SysClk_FllManualConfigure+0xe8>)
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN, config->pgain) |
10005350:	011b      	lsls	r3, r3, #4
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT, config->settlingCount) |
10005352:	ea02 2201 	and.w	r2, r2, r1, lsl #8
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN, config->pgain) |
10005356:	b2db      	uxtb	r3, r3
10005358:	4313      	orrs	r3, r2
        SRSS_CLK_FLL_CONFIG3 = _VAL2FLD(SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN, config->igain) |
1000535a:	7a82      	ldrb	r2, [r0, #10]
1000535c:	f002 020f 	and.w	r2, r2, #15
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN, config->pgain) |
10005360:	4313      	orrs	r3, r2
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, config->outputMode);
10005362:	7b82      	ldrb	r2, [r0, #14]
10005364:	0712      	lsls	r2, r2, #28
10005366:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
                               _VAL2FLD(SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT, config->settlingCount) |
1000536a:	4313      	orrs	r3, r2
        SRSS_CLK_FLL_CONFIG3 = _VAL2FLD(SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN, config->igain) |
1000536c:	4a13      	ldr	r2, [pc, #76]	; (100053bc <Cy_SysClk_FllManualConfigure+0xe0>)
1000536e:	f8c2 3588 	str.w	r3, [r2, #1416]	; 0x588

        /* update CLK_FLL_CONFIG4 register with 1 parameter; preserve other bits */
        /* asserts just check for bitfield overflow */
        CY_ASSERT_L1(CY_SYSCLK_FLL_IS_CCO_RANGE_VALID(config->ccoRange));
10005372:	7983      	ldrb	r3, [r0, #6]
10005374:	2b04      	cmp	r3, #4
10005376:	d900      	bls.n	1000537a <Cy_SysClk_FllManualConfigure+0x9e>
10005378:	be01      	bkpt	0x0001
        CY_ASSERT_L1(config->cco_Freq <= (SRSS_CLK_FLL_CONFIG4_CCO_FREQ_Msk >> SRSS_CLK_FLL_CONFIG4_CCO_FREQ_Pos));
1000537a:	8a03      	ldrh	r3, [r0, #16]
1000537c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
10005380:	d300      	bcc.n	10005384 <Cy_SysClk_FllManualConfigure+0xa8>
10005382:	be01      	bkpt	0x0001

        CY_REG32_CLR_SET(SRSS_CLK_FLL_CONFIG4, SRSS_CLK_FLL_CONFIG4_CCO_RANGE, (uint32_t)(config->ccoRange));
10005384:	7983      	ldrb	r3, [r0, #6]
10005386:	f8d2 158c 	ldr.w	r1, [r2, #1420]	; 0x58c
1000538a:	021b      	lsls	r3, r3, #8
1000538c:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
10005390:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
10005394:	430b      	orrs	r3, r1
10005396:	f8c2 358c 	str.w	r3, [r2, #1420]	; 0x58c
        CY_REG32_CLR_SET(SRSS_CLK_FLL_CONFIG4, SRSS_CLK_FLL_CONFIG4_CCO_FREQ, (uint32_t)(config->cco_Freq));
1000539a:	f8d2 158c 	ldr.w	r1, [r2, #1420]	; 0x58c
1000539e:	8a00      	ldrh	r0, [r0, #16]
100053a0:	4b07      	ldr	r3, [pc, #28]	; (100053c0 <Cy_SysClk_FllManualConfigure+0xe4>)
100053a2:	f021 71ff 	bic.w	r1, r1, #33423360	; 0x1fe0000
100053a6:	ea03 4300 	and.w	r3, r3, r0, lsl #16
100053aa:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
100053ae:	430b      	orrs	r3, r1
100053b0:	f8c2 358c 	str.w	r3, [r2, #1420]	; 0x58c

        retVal = CY_SYSCLK_SUCCESS;
100053b4:	2000      	movs	r0, #0
100053b6:	4770      	bx	lr
    retVal = CY_SYSCLK_INVALID_STATE;
100053b8:	4803      	ldr	r0, [pc, #12]	; (100053c8 <Cy_SysClk_FllManualConfigure+0xec>)
    }

#endif /* ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE))) */
    return (retVal);
}
100053ba:	4770      	bx	lr
100053bc:	40260000 	.word	0x40260000
100053c0:	01ff0000 	.word	0x01ff0000
100053c4:	001fff00 	.word	0x001fff00
100053c8:	004a0003 	.word	0x004a0003

100053cc <Cy_SysClk_FllGetConfiguration>:


void Cy_SysClk_FllGetConfiguration(cy_stc_fll_manual_config_t *config)
{
    CY_ASSERT_L1(config != NULL);
100053cc:	b900      	cbnz	r0, 100053d0 <Cy_SysClk_FllGetConfiguration+0x4>
100053ce:	be01      	bkpt	0x0001
    /* read 2 parameters from CLK_FLL_CONFIG register */
    uint32_t tempReg = SRSS_CLK_FLL_CONFIG;
100053d0:	4a13      	ldr	r2, [pc, #76]	; (10005420 <Cy_SysClk_FllGetConfiguration+0x54>)
100053d2:	f8d2 3580 	ldr.w	r3, [r2, #1408]	; 0x580
    config->fllMult         = _FLD2VAL(SRSS_CLK_FLL_CONFIG_FLL_MULT, tempReg);
100053d6:	f3c3 0111 	ubfx	r1, r3, #0, #18
    config->enableOutputDiv = _FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_OUTPUT_DIV, tempReg);
100053da:	f3c3 6300 	ubfx	r3, r3, #24, #1
    config->fllMult         = _FLD2VAL(SRSS_CLK_FLL_CONFIG_FLL_MULT, tempReg);
100053de:	6001      	str	r1, [r0, #0]
    config->enableOutputDiv = _FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_OUTPUT_DIV, tempReg);
100053e0:	71c3      	strb	r3, [r0, #7]
    /* read 2 parameters from CLK_FLL_CONFIG2 register */
    tempReg = SRSS_CLK_FLL_CONFIG2;
100053e2:	f8d2 3584 	ldr.w	r3, [r2, #1412]	; 0x584
    config->refDiv          = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV, tempReg);
100053e6:	f3c3 010c 	ubfx	r1, r3, #0, #13
    config->lockTolerance   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_LOCK_TOL, tempReg);
100053ea:	f3c3 4308 	ubfx	r3, r3, #16, #9
    config->refDiv          = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV, tempReg);
100053ee:	8081      	strh	r1, [r0, #4]
    config->lockTolerance   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_LOCK_TOL, tempReg);
100053f0:	8103      	strh	r3, [r0, #8]
    /* read 4 parameters from CLK_FLL_CONFIG3 register */
    tempReg = SRSS_CLK_FLL_CONFIG3;
100053f2:	f8d2 3588 	ldr.w	r3, [r2, #1416]	; 0x588
    config->igain           = (uint8_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN, tempReg);
100053f6:	f003 010f 	and.w	r1, r3, #15
100053fa:	7281      	strb	r1, [r0, #10]
    config->pgain           = (uint8_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN, tempReg);
100053fc:	f3c3 1103 	ubfx	r1, r3, #4, #4
10005400:	72c1      	strb	r1, [r0, #11]
    config->settlingCount   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT, tempReg);
10005402:	f3c3 210c 	ubfx	r1, r3, #8, #13
    config->outputMode      = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, tempReg));
10005406:	f3c3 7301 	ubfx	r3, r3, #28, #2
    config->settlingCount   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT, tempReg);
1000540a:	8181      	strh	r1, [r0, #12]
    config->outputMode      = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, tempReg));
1000540c:	7383      	strb	r3, [r0, #14]
    /* read 2 parameters from CLK_FLL_CONFIG4 register */
    tempReg = SRSS_CLK_FLL_CONFIG4;
1000540e:	f8d2 358c 	ldr.w	r3, [r2, #1420]	; 0x58c
    config->ccoRange        = (cy_en_fll_cco_ranges_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_RANGE, tempReg));
10005412:	f3c3 2202 	ubfx	r2, r3, #8, #3
    config->cco_Freq        = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_FREQ, tempReg);
10005416:	f3c3 4308 	ubfx	r3, r3, #16, #9
    config->ccoRange        = (cy_en_fll_cco_ranges_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_RANGE, tempReg));
1000541a:	7182      	strb	r2, [r0, #6]
    config->cco_Freq        = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_FREQ, tempReg);
1000541c:	8203      	strh	r3, [r0, #16]
}
1000541e:	4770      	bx	lr
10005420:	40260000 	.word	0x40260000

10005424 <Cy_SysClk_FllEnable>:


cy_en_sysclk_status_t Cy_SysClk_FllEnable(uint32_t timeoutus)
{
10005424:	b570      	push	{r4, r5, r6, lr}
#endif /* defined (CY_DEVICE_SECURE) */
#if ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE)))
    bool zeroTimeout = (0UL == timeoutus);

    /* first set the CCO enable bit */
    SRSS_CLK_FLL_CONFIG4 |= SRSS_CLK_FLL_CONFIG4_CCO_ENABLE_Msk;
10005426:	4e20      	ldr	r6, [pc, #128]	; (100054a8 <Cy_SysClk_FllEnable+0x84>)
10005428:	f8d6 358c 	ldr.w	r3, [r6, #1420]	; 0x58c
1000542c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
{
10005430:	4605      	mov	r5, r0
    SRSS_CLK_FLL_CONFIG4 |= SRSS_CLK_FLL_CONFIG4_CCO_ENABLE_Msk;
10005432:	f8c6 358c 	str.w	r3, [r6, #1420]	; 0x58c

    /* Wait until CCO is ready */
    for (; (!_FLD2BOOL(SRSS_CLK_FLL_STATUS_CCO_READY, SRSS_CLK_FLL_STATUS)) && /* if cco_ready == 0 */
10005436:	4604      	mov	r4, r0
10005438:	f8d6 3590 	ldr.w	r3, [r6, #1424]	; 0x590
1000543c:	075a      	lsls	r2, r3, #29
1000543e:	d400      	bmi.n	10005442 <Cy_SysClk_FllEnable+0x1e>
10005440:	b9c4      	cbnz	r4, 10005474 <Cy_SysClk_FllEnable+0x50>
    {
        Cy_SysLib_DelayUs(1U);
    }

    /* Set the FLL bypass mode to FLL_REF */
    CY_REG32_CLR_SET(SRSS_CLK_FLL_CONFIG3, SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_INPUT);
10005442:	f8d6 3588 	ldr.w	r3, [r6, #1416]	; 0x588
10005446:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
1000544a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
1000544e:	f8c6 3588 	str.w	r3, [r6, #1416]	; 0x588

    /* Set the FLL enable bit, if CCO is ready */
    if (zeroTimeout || (0UL != timeoutus))
10005452:	b105      	cbz	r5, 10005456 <Cy_SysClk_FllEnable+0x32>
10005454:	b134      	cbz	r4, 10005464 <Cy_SysClk_FllEnable+0x40>
    {
        SRSS_CLK_FLL_CONFIG |= SRSS_CLK_FLL_CONFIG_FLL_ENABLE_Msk;
10005456:	4a14      	ldr	r2, [pc, #80]	; (100054a8 <Cy_SysClk_FllEnable+0x84>)
10005458:	f8d2 3580 	ldr.w	r3, [r2, #1408]	; 0x580
1000545c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
10005460:	f8c2 3580 	str.w	r3, [r2, #1408]	; 0x580
    return (_FLD2BOOL(SRSS_CLK_FLL_STATUS_LOCKED, SRSS_CLK_FLL_STATUS));
10005464:	4e10      	ldr	r6, [pc, #64]	; (100054a8 <Cy_SysClk_FllEnable+0x84>)
10005466:	f8d6 3590 	ldr.w	r3, [r6, #1424]	; 0x590
    }

    /* now do the timeout wait for FLL_STATUS, bit LOCKED */
    for (; (!Cy_SysClk_FllLocked()) && /* if locked == 0 */
1000546a:	07db      	lsls	r3, r3, #31
1000546c:	d40c      	bmi.n	10005488 <Cy_SysClk_FllEnable+0x64>
1000546e:	b934      	cbnz	r4, 1000547e <Cy_SysClk_FllEnable+0x5a>
         timeoutus--)
    {
        Cy_SysLib_DelayUs(1U);
    }

    if (zeroTimeout || (0UL != timeoutus))
10005470:	b15d      	cbz	r5, 1000548a <Cy_SysClk_FllEnable+0x66>
10005472:	e014      	b.n	1000549e <Cy_SysClk_FllEnable+0x7a>
        Cy_SysLib_DelayUs(1U);
10005474:	2001      	movs	r0, #1
10005476:	f000 fab5 	bl	100059e4 <Cy_SysLib_DelayUs>
         timeoutus--)
1000547a:	3c01      	subs	r4, #1
1000547c:	e7dc      	b.n	10005438 <Cy_SysClk_FllEnable+0x14>
        Cy_SysLib_DelayUs(1U);
1000547e:	2001      	movs	r0, #1
10005480:	f000 fab0 	bl	100059e4 <Cy_SysLib_DelayUs>
         timeoutus--)
10005484:	3c01      	subs	r4, #1
10005486:	e7ee      	b.n	10005466 <Cy_SysClk_FllEnable+0x42>
    if (zeroTimeout || (0UL != timeoutus))
10005488:	b93d      	cbnz	r5, 1000549a <Cy_SysClk_FllEnable+0x76>
    {
        /* Set the FLL bypass mode to FLL_OUT (ignoring lock indicator) */
        CY_REG32_CLR_SET(SRSS_CLK_FLL_CONFIG3, SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_OUTPUT);
1000548a:	f8d6 3588 	ldr.w	r3, [r6, #1416]	; 0x588
1000548e:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
10005492:	f8c6 3588 	str.w	r3, [r6, #1416]	; 0x588
    {
        /* If lock doesn't occur, FLL is stopped */
        (void)Cy_SysClk_FllDisable();
    }

    retStatus = ((zeroTimeout || (0UL != timeoutus)) ? CY_SYSCLK_SUCCESS : CY_SYSCLK_TIMEOUT);
10005496:	2000      	movs	r0, #0
#endif /* ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE))) */
    return retStatus;
}
10005498:	bd70      	pop	{r4, r5, r6, pc}
    if (zeroTimeout || (0UL != timeoutus))
1000549a:	2c00      	cmp	r4, #0
1000549c:	d1f5      	bne.n	1000548a <Cy_SysClk_FllEnable+0x66>
        (void)Cy_SysClk_FllDisable();
1000549e:	f7ff ff03 	bl	100052a8 <Cy_SysClk_FllDisable>
    retStatus = ((zeroTimeout || (0UL != timeoutus)) ? CY_SYSCLK_SUCCESS : CY_SYSCLK_TIMEOUT);
100054a2:	4802      	ldr	r0, [pc, #8]	; (100054ac <Cy_SysClk_FllEnable+0x88>)
    return retStatus;
100054a4:	e7f8      	b.n	10005498 <Cy_SysClk_FllEnable+0x74>
100054a6:	bf00      	nop
100054a8:	40260000 	.word	0x40260000
100054ac:	004a0002 	.word	0x004a0002

100054b0 <Cy_SysClk_PllIsEnabled>:


bool Cy_SysClk_PllIsEnabled(uint32_t clkPath)
{
    clkPath--; /* to correctly access PLL config and status registers structures */
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_PLL);
100054b0:	4b07      	ldr	r3, [pc, #28]	; (100054d0 <Cy_SysClk_PllIsEnabled+0x20>)
100054b2:	681b      	ldr	r3, [r3, #0]
100054b4:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
    clkPath--; /* to correctly access PLL config and status registers structures */
100054b8:	3801      	subs	r0, #1
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_PLL);
100054ba:	4283      	cmp	r3, r0
100054bc:	d800      	bhi.n	100054c0 <Cy_SysClk_PllIsEnabled+0x10>
100054be:	be01      	bkpt	0x0001
    return (_FLD2BOOL(SRSS_CLK_PLL_CONFIG_ENABLE, SRSS_CLK_PLL_CONFIG[clkPath]));
100054c0:	4b04      	ldr	r3, [pc, #16]	; (100054d4 <Cy_SysClk_PllIsEnabled+0x24>)
100054c2:	f500 70c0 	add.w	r0, r0, #384	; 0x180
100054c6:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
100054ca:	0fc0      	lsrs	r0, r0, #31
100054cc:	4770      	bx	lr
100054ce:	bf00      	nop
100054d0:	08003550 	.word	0x08003550
100054d4:	40260000 	.word	0x40260000

100054d8 <Cy_SysClk_PllDisable>:
#endif /* ((CY_CPU_CORTEX_M4) && (defined(CY_DEVICE_SECURE))) */
}


cy_en_sysclk_status_t Cy_SysClk_PllDisable(uint32_t clkPath)
{
100054d8:	b510      	push	{r4, lr}
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    clkPath--; /* to correctly access PLL config and status registers structures */
    if (clkPath < CY_SRSS_NUM_PLL)
100054da:	4b10      	ldr	r3, [pc, #64]	; (1000551c <Cy_SysClk_PllDisable+0x44>)
100054dc:	681b      	ldr	r3, [r3, #0]
100054de:	f893 203f 	ldrb.w	r2, [r3, #63]	; 0x3f
    clkPath--; /* to correctly access PLL config and status registers structures */
100054e2:	1e43      	subs	r3, r0, #1
    if (clkPath < CY_SRSS_NUM_PLL)
100054e4:	429a      	cmp	r2, r3
100054e6:	d917      	bls.n	10005518 <Cy_SysClk_PllDisable+0x40>
#if defined (CY_DEVICE_SECURE)
        retVal = (cy_en_sysclk_status_t)CY_PRA_FUNCTION_CALL_RETURN_PARAM(CY_PRA_MSG_TYPE_FUNC_POLICY, CY_PRA_CLK_FUNC_PLL_DISABLE, (clkPath + 1U));
#endif /* defined (CY_DEVICE_SECURE) */
#if ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE)))
        /* First bypass PLL */
        CY_REG32_CLR_SET(SRSS_CLK_PLL_CONFIG[clkPath], SRSS_CLK_PLL_CONFIG_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_INPUT);
100054e8:	0080      	lsls	r0, r0, #2
100054ea:	f100 4480 	add.w	r4, r0, #1073741824	; 0x40000000
100054ee:	f504 1418 	add.w	r4, r4, #2490368	; 0x260000
        /* Wait at least 6 PLL clock cycles */
        Cy_SysLib_DelayUs(1U);
100054f2:	2001      	movs	r0, #1
        CY_REG32_CLR_SET(SRSS_CLK_PLL_CONFIG[clkPath], SRSS_CLK_PLL_CONFIG_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_INPUT);
100054f4:	f8d4 35fc 	ldr.w	r3, [r4, #1532]	; 0x5fc
100054f8:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
100054fc:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
10005500:	f8c4 35fc 	str.w	r3, [r4, #1532]	; 0x5fc
        Cy_SysLib_DelayUs(1U);
10005504:	f000 fa6e 	bl	100059e4 <Cy_SysLib_DelayUs>
        /* And now disable the PLL itself */
        SRSS_CLK_PLL_CONFIG[clkPath] &= ~SRSS_CLK_PLL_CONFIG_ENABLE_Msk;
10005508:	f8d4 35fc 	ldr.w	r3, [r4, #1532]	; 0x5fc
1000550c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10005510:	f8c4 35fc 	str.w	r3, [r4, #1532]	; 0x5fc
        retVal = CY_SYSCLK_SUCCESS;
10005514:	2000      	movs	r0, #0
#endif /* ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE))) */
    }
    return (retVal);
}
10005516:	bd10      	pop	{r4, pc}
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
10005518:	4801      	ldr	r0, [pc, #4]	; (10005520 <Cy_SysClk_PllDisable+0x48>)
    return (retVal);
1000551a:	e7fc      	b.n	10005516 <Cy_SysClk_PllDisable+0x3e>
1000551c:	08003550 	.word	0x08003550
10005520:	004a0001 	.word	0x004a0001

10005524 <Cy_SysClk_PllManualConfigure>:
    return (retVal);
}


cy_en_sysclk_status_t Cy_SysClk_PllManualConfigure(uint32_t clkPath, const cy_stc_pll_manual_config_t *config)
{
10005524:	b570      	push	{r4, r5, r6, lr}
    cy_en_sysclk_status_t retVal = CY_SYSCLK_SUCCESS;

    /* check for errors */
    if (clkPath > CY_SRSS_NUM_PLL) /* invalid clock path number */
10005526:	4b21      	ldr	r3, [pc, #132]	; (100055ac <Cy_SysClk_PllManualConfigure+0x88>)
10005528:	681b      	ldr	r3, [r3, #0]
1000552a:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
1000552e:	4283      	cmp	r3, r0
{
10005530:	4602      	mov	r2, r0
    if (clkPath > CY_SRSS_NUM_PLL) /* invalid clock path number */
10005532:	d201      	bcs.n	10005538 <Cy_SysClk_PllManualConfigure+0x14>
    {
        retVal = CY_SYSCLK_BAD_PARAM;
10005534:	481e      	ldr	r0, [pc, #120]	; (100055b0 <Cy_SysClk_PllManualConfigure+0x8c>)
        CY_REG32_CLR_SET(SRSS_CLK_PLL_CONFIG[clkPath], SRSS_CLK_PLL_CONFIG_BYPASS_SEL, (uint32_t)config->outputMode);
#endif /* ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE))) */
    }

    return (retVal);
}
10005536:	bd70      	pop	{r4, r5, r6, pc}
    else if (Cy_SysClk_PllIsEnabled(clkPath))
10005538:	f7ff ffba 	bl	100054b0 <Cy_SysClk_PllIsEnabled>
1000553c:	bb98      	cbnz	r0, 100055a6 <Cy_SysClk_PllManualConfigure+0x82>
    else if ((config->outputDiv    < CY_SYSCLK_PLL_MIN_OUTPUT_DIV) || (CY_SYSCLK_PLL_MAX_OUTPUT_DIV < config->outputDiv)    ||
1000553e:	788b      	ldrb	r3, [r1, #2]
10005540:	1e98      	subs	r0, r3, #2
10005542:	280e      	cmp	r0, #14
10005544:	d8f6      	bhi.n	10005534 <Cy_SysClk_PllManualConfigure+0x10>
             (config->referenceDiv < CY_SYSCLK_PLL_MIN_REF_DIV)    || (CY_SYSCLK_PLL_MAX_REF_DIV    < config->referenceDiv) ||
10005546:	784d      	ldrb	r5, [r1, #1]
    else if ((config->outputDiv    < CY_SYSCLK_PLL_MIN_OUTPUT_DIV) || (CY_SYSCLK_PLL_MAX_OUTPUT_DIV < config->outputDiv)    ||
10005548:	1e68      	subs	r0, r5, #1
1000554a:	2811      	cmp	r0, #17
1000554c:	d8f2      	bhi.n	10005534 <Cy_SysClk_PllManualConfigure+0x10>
             (config->feedbackDiv  < CY_SYSCLK_PLL_MIN_FB_DIV)     || (CY_SYSCLK_PLL_MAX_FB_DIV     < config->feedbackDiv))
1000554e:	78cc      	ldrb	r4, [r1, #3]
10005550:	7808      	ldrb	r0, [r1, #0]
10005552:	b324      	cbz	r4, 1000559e <Cy_SysClk_PllManualConfigure+0x7a>
             (config->referenceDiv < CY_SYSCLK_PLL_MIN_REF_DIV)    || (CY_SYSCLK_PLL_MAX_REF_DIV    < config->referenceDiv) ||
10005554:	2812      	cmp	r0, #18
10005556:	d9ed      	bls.n	10005534 <Cy_SysClk_PllManualConfigure+0x10>
             (config->feedbackDiv  < CY_SYSCLK_PLL_MIN_FB_DIV)     || (CY_SYSCLK_PLL_MAX_FB_DIV     < config->feedbackDiv))
10005558:	2638      	movs	r6, #56	; 0x38
1000555a:	42b0      	cmp	r0, r6
1000555c:	d8ea      	bhi.n	10005534 <Cy_SysClk_PllManualConfigure+0x10>
        if (config->outputMode != CY_SYSCLK_FLLPLL_OUTPUT_INPUT)
1000555e:	790e      	ldrb	r6, [r1, #4]
10005560:	2e02      	cmp	r6, #2
10005562:	d00a      	beq.n	1000557a <Cy_SysClk_PllManualConfigure+0x56>
                _VAL2FLD(SRSS_CLK_PLL_CONFIG_OUTPUT_DIV,    config->outputDiv)    |
10005564:	041b      	lsls	r3, r3, #16
                _VAL2FLD(SRSS_CLK_PLL_CONFIG_REFERENCE_DIV, config->referenceDiv) |
10005566:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
1000556a:	4303      	orrs	r3, r0
                _VAL2FLD(SRSS_CLK_PLL_CONFIG_OUTPUT_DIV,    config->outputDiv)    |
1000556c:	ea43 63c4 	orr.w	r3, r3, r4, lsl #27
            SRSS_CLK_PLL_CONFIG[clkPath] =
10005570:	f202 107f 	addw	r0, r2, #383	; 0x17f
10005574:	4c0f      	ldr	r4, [pc, #60]	; (100055b4 <Cy_SysClk_PllManualConfigure+0x90>)
10005576:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
        CY_REG32_CLR_SET(SRSS_CLK_PLL_CONFIG[clkPath], SRSS_CLK_PLL_CONFIG_BYPASS_SEL, (uint32_t)config->outputMode);
1000557a:	0090      	lsls	r0, r2, #2
1000557c:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
10005580:	f500 1018 	add.w	r0, r0, #2490368	; 0x260000
10005584:	790b      	ldrb	r3, [r1, #4]
10005586:	f8d0 25fc 	ldr.w	r2, [r0, #1532]	; 0x5fc
1000558a:	071b      	lsls	r3, r3, #28
1000558c:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
10005590:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
10005594:	4313      	orrs	r3, r2
10005596:	f8c0 35fc 	str.w	r3, [r0, #1532]	; 0x5fc
    cy_en_sysclk_status_t retVal = CY_SYSCLK_SUCCESS;
1000559a:	2000      	movs	r0, #0
1000559c:	e7cb      	b.n	10005536 <Cy_SysClk_PllManualConfigure+0x12>
             (config->referenceDiv < CY_SYSCLK_PLL_MIN_REF_DIV)    || (CY_SYSCLK_PLL_MAX_REF_DIV    < config->referenceDiv) ||
1000559e:	2815      	cmp	r0, #21
100055a0:	d9c8      	bls.n	10005534 <Cy_SysClk_PllManualConfigure+0x10>
             (config->feedbackDiv  < CY_SYSCLK_PLL_MIN_FB_DIV)     || (CY_SYSCLK_PLL_MAX_FB_DIV     < config->feedbackDiv))
100055a2:	2670      	movs	r6, #112	; 0x70
100055a4:	e7d9      	b.n	1000555a <Cy_SysClk_PllManualConfigure+0x36>
        retVal = CY_SYSCLK_INVALID_STATE;
100055a6:	4804      	ldr	r0, [pc, #16]	; (100055b8 <Cy_SysClk_PllManualConfigure+0x94>)
    return (retVal);
100055a8:	e7c5      	b.n	10005536 <Cy_SysClk_PllManualConfigure+0x12>
100055aa:	bf00      	nop
100055ac:	08003550 	.word	0x08003550
100055b0:	004a0001 	.word	0x004a0001
100055b4:	40260000 	.word	0x40260000
100055b8:	004a0003 	.word	0x004a0003

100055bc <Cy_SysClk_PllGetConfiguration>:

cy_en_sysclk_status_t Cy_SysClk_PllGetConfiguration(uint32_t clkPath, cy_stc_pll_manual_config_t *config)
{
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    clkPath--; /* to correctly access PLL config and status register structures */
    if (clkPath < CY_SRSS_NUM_PLL)
100055bc:	4a0f      	ldr	r2, [pc, #60]	; (100055fc <Cy_SysClk_PllGetConfiguration+0x40>)
100055be:	6812      	ldr	r2, [r2, #0]
100055c0:	f892 203f 	ldrb.w	r2, [r2, #63]	; 0x3f
    clkPath--; /* to correctly access PLL config and status register structures */
100055c4:	1e43      	subs	r3, r0, #1
    if (clkPath < CY_SRSS_NUM_PLL)
100055c6:	429a      	cmp	r2, r3
100055c8:	d915      	bls.n	100055f6 <Cy_SysClk_PllGetConfiguration+0x3a>
    {
        uint32_t tempReg = SRSS_CLK_PLL_CONFIG[clkPath];
100055ca:	f200 107f 	addw	r0, r0, #383	; 0x17f
100055ce:	4b0c      	ldr	r3, [pc, #48]	; (10005600 <Cy_SysClk_PllGetConfiguration+0x44>)
100055d0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
        config->feedbackDiv  = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_FEEDBACK_DIV,  tempReg);
100055d4:	f003 027f 	and.w	r2, r3, #127	; 0x7f
100055d8:	700a      	strb	r2, [r1, #0]
        config->referenceDiv = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_REFERENCE_DIV, tempReg);
100055da:	f3c3 2204 	ubfx	r2, r3, #8, #5
100055de:	704a      	strb	r2, [r1, #1]
        config->outputDiv    = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_OUTPUT_DIV,    tempReg);
100055e0:	f3c3 4204 	ubfx	r2, r3, #16, #5
100055e4:	708a      	strb	r2, [r1, #2]
        config->lfMode       =         _FLD2BOOL(SRSS_CLK_PLL_CONFIG_PLL_LF_MODE,   tempReg);
100055e6:	f3c3 62c0 	ubfx	r2, r3, #27, #1
        config->outputMode   = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_BYPASS_SEL, tempReg));
100055ea:	f3c3 7301 	ubfx	r3, r3, #28, #2
        config->lfMode       =         _FLD2BOOL(SRSS_CLK_PLL_CONFIG_PLL_LF_MODE,   tempReg);
100055ee:	70ca      	strb	r2, [r1, #3]
        config->outputMode   = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_BYPASS_SEL, tempReg));
100055f0:	710b      	strb	r3, [r1, #4]
        retVal = CY_SYSCLK_SUCCESS;
100055f2:	2000      	movs	r0, #0
100055f4:	4770      	bx	lr
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
100055f6:	4803      	ldr	r0, [pc, #12]	; (10005604 <Cy_SysClk_PllGetConfiguration+0x48>)
    }
    return (retVal);
}
100055f8:	4770      	bx	lr
100055fa:	bf00      	nop
100055fc:	08003550 	.word	0x08003550
10005600:	40260000 	.word	0x40260000
10005604:	004a0001 	.word	0x004a0001

10005608 <Cy_SysClk_PllConfigure>:
{
10005608:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1000560c:	b08f      	sub	sp, #60	; 0x3c
    if (((config->inputFreq)  < CY_SYSCLK_PLL_MIN_IN_FREQ)  || (CY_SYSCLK_PLL_MAX_IN_FREQ  < (config->inputFreq)) ||
1000560e:	680b      	ldr	r3, [r1, #0]
10005610:	4a53      	ldr	r2, [pc, #332]	; (10005760 <Cy_SysClk_PllConfigure+0x158>)
10005612:	9300      	str	r3, [sp, #0]
10005614:	f5a3 1374 	sub.w	r3, r3, #3997696	; 0x3d0000
10005618:	f5a3 6310 	sub.w	r3, r3, #2304	; 0x900
{
1000561c:	2500      	movs	r5, #0
    if (((config->inputFreq)  < CY_SYSCLK_PLL_MIN_IN_FREQ)  || (CY_SYSCLK_PLL_MAX_IN_FREQ  < (config->inputFreq)) ||
1000561e:	4293      	cmp	r3, r2
{
10005620:	e9cd 5503 	strd	r5, r5, [sp, #12]
10005624:	9008      	str	r0, [sp, #32]
    if (((config->inputFreq)  < CY_SYSCLK_PLL_MIN_IN_FREQ)  || (CY_SYSCLK_PLL_MAX_IN_FREQ  < (config->inputFreq)) ||
10005626:	f200 8098 	bhi.w	1000575a <Cy_SysClk_PllConfigure+0x152>
        ((config->outputFreq) < CY_SYSCLK_PLL_MIN_OUT_FREQ) || (CY_SYSCLK_PLL_MAX_OUT_FREQ < (config->outputFreq)))
1000562a:	f891 a008 	ldrb.w	sl, [r1, #8]
1000562e:	4b4d      	ldr	r3, [pc, #308]	; (10005764 <Cy_SysClk_PllConfigure+0x15c>)
10005630:	4a4d      	ldr	r2, [pc, #308]	; (10005768 <Cy_SysClk_PllConfigure+0x160>)
10005632:	f8d1 8004 	ldr.w	r8, [r1, #4]
10005636:	45aa      	cmp	sl, r5
10005638:	bf08      	it	eq
1000563a:	4613      	moveq	r3, r2
    if (((config->inputFreq)  < CY_SYSCLK_PLL_MIN_IN_FREQ)  || (CY_SYSCLK_PLL_MAX_IN_FREQ  < (config->inputFreq)) ||
1000563c:	4598      	cmp	r8, r3
1000563e:	f0c0 808c 	bcc.w	1000575a <Cy_SysClk_PllConfigure+0x152>
        ((config->outputFreq) < CY_SYSCLK_PLL_MIN_OUT_FREQ) || (CY_SYSCLK_PLL_MAX_OUT_FREQ < (config->outputFreq)))
10005642:	4b4a      	ldr	r3, [pc, #296]	; (1000576c <Cy_SysClk_PllConfigure+0x164>)
10005644:	4598      	cmp	r8, r3
10005646:	f200 8088 	bhi.w	1000575a <Cy_SysClk_PllConfigure+0x152>
        if (config->outputMode != CY_SYSCLK_FLLPLL_OUTPUT_INPUT)
1000564a:	7a4b      	ldrb	r3, [r1, #9]
        cy_stc_pll_manual_config_t manualConfig = {0U, 0U, 0U, false, CY_SYSCLK_FLLPLL_OUTPUT_AUTO};
1000564c:	950c      	str	r5, [sp, #48]	; 0x30
        if (config->outputMode != CY_SYSCLK_FLLPLL_OUTPUT_INPUT)
1000564e:	2b02      	cmp	r3, #2
        cy_stc_pll_manual_config_t manualConfig = {0U, 0U, 0U, false, CY_SYSCLK_FLLPLL_OUTPUT_AUTO};
10005650:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
        if (config->outputMode != CY_SYSCLK_FLLPLL_OUTPUT_INPUT)
10005654:	9302      	str	r3, [sp, #8]
10005656:	d07c      	beq.n	10005752 <Cy_SysClk_PllConfigure+0x14a>
10005658:	45aa      	cmp	sl, r5
1000565a:	4a45      	ldr	r2, [pc, #276]	; (10005770 <Cy_SysClk_PllConfigure+0x168>)
1000565c:	9505      	str	r5, [sp, #20]
1000565e:	bf14      	ite	ne
10005660:	2313      	movne	r3, #19
10005662:	2316      	moveq	r3, #22
10005664:	9306      	str	r3, [sp, #24]
10005666:	4b43      	ldr	r3, [pc, #268]	; (10005774 <Cy_SysClk_PllConfigure+0x16c>)
            uint32_t foutBest = 0UL; /* to ensure at least one pass through the for loops below */
10005668:	9501      	str	r5, [sp, #4]
1000566a:	bf18      	it	ne
1000566c:	4613      	movne	r3, r2
1000566e:	9307      	str	r3, [sp, #28]
10005670:	9a00      	ldr	r2, [sp, #0]
10005672:	9b06      	ldr	r3, [sp, #24]
10005674:	fba3 3202 	umull	r3, r2, r3, r2
10005678:	e9cd 3209 	strd	r3, r2, [sp, #36]	; 0x24
        if (config->outputMode != CY_SYSCLK_FLLPLL_OUTPUT_INPUT)
1000567c:	2401      	movs	r4, #1
1000567e:	462f      	mov	r7, r5
                for (p = CY_SYSCLK_PLL_MIN_FB_DIV; p <= CY_SYSCLK_PLL_MAX_FB_DIV; p++)
10005680:	e9dd 6b09 	ldrd	r6, fp, [sp, #36]	; 0x24
10005684:	b2e3      	uxtb	r3, r4
10005686:	f8dd 9018 	ldr.w	r9, [sp, #24]
1000568a:	930b      	str	r3, [sp, #44]	; 0x2c
1000568c:	f1ba 0f00 	cmp.w	sl, #0
10005690:	d037      	beq.n	10005702 <Cy_SysClk_PllConfigure+0xfa>
10005692:	f1b9 0f38 	cmp.w	r9, #56	; 0x38
10005696:	d83f      	bhi.n	10005718 <Cy_SysClk_PllConfigure+0x110>
                    uint32_t fvco = (uint32_t)(((uint64_t)(config->inputFreq) * (uint64_t)p) / (uint64_t)q);
10005698:	463b      	mov	r3, r7
1000569a:	4622      	mov	r2, r4
1000569c:	4630      	mov	r0, r6
1000569e:	4659      	mov	r1, fp
100056a0:	f7fc fe7e 	bl	100023a0 <__aeabi_uldivmod>
                    if ((CY_SYSCLK_PLL_MIN_FVCO <= fvco) && (fvco <= CY_SYSCLK_PLL_MAX_FVCO))
100056a4:	4b34      	ldr	r3, [pc, #208]	; (10005778 <Cy_SysClk_PllConfigure+0x170>)
100056a6:	4298      	cmp	r0, r3
100056a8:	d924      	bls.n	100056f4 <Cy_SysClk_PllConfigure+0xec>
100056aa:	9b07      	ldr	r3, [sp, #28]
100056ac:	4283      	cmp	r3, r0
100056ae:	d321      	bcc.n	100056f4 <Cy_SysClk_PllConfigure+0xec>
                            uint32_t fout = ((p * config->inputFreq) / q) / out;
100056b0:	fbb6 fcf4 	udiv	ip, r6, r4
                        for (out = CY_SYSCLK_PLL_MIN_OUTPUT_DIV; out <= CY_SYSCLK_PLL_MAX_OUTPUT_DIV; out++)
100056b4:	2302      	movs	r3, #2
100056b6:	fa5f fe89 	uxtb.w	lr, r9
                                (uint32_t)abs((int32_t)foutBest - (int32_t)(config->outputFreq)))
100056ba:	9a01      	ldr	r2, [sp, #4]
                            uint32_t fout = ((p * config->inputFreq) / q) / out;
100056bc:	fbbc f0f3 	udiv	r0, ip, r3
                            if ((uint32_t)abs((int32_t)fout - (int32_t)(config->outputFreq)) <
100056c0:	eba0 0108 	sub.w	r1, r0, r8
                                (uint32_t)abs((int32_t)foutBest - (int32_t)(config->outputFreq)))
100056c4:	eba2 0208 	sub.w	r2, r2, r8
void srand(unsigned int seed);
#endif /* CONFIG_MINIMAL_LIBC_RAND */

static inline int abs(int __n)
{
	return (__n < 0) ? -__n : __n;
100056c8:	2900      	cmp	r1, #0
100056ca:	bfb8      	it	lt
100056cc:	4249      	neglt	r1, r1
100056ce:	2a00      	cmp	r2, #0
100056d0:	bfb8      	it	lt
100056d2:	4252      	neglt	r2, r2
                            if ((uint32_t)abs((int32_t)fout - (int32_t)(config->outputFreq)) <
100056d4:	4291      	cmp	r1, r2
100056d6:	d20a      	bcs.n	100056ee <Cy_SysClk_PllConfigure+0xe6>
                                if (foutBest == (config->outputFreq))
100056d8:	9a01      	ldr	r2, [sp, #4]
100056da:	4590      	cmp	r8, r2
100056dc:	d00a      	beq.n	100056f4 <Cy_SysClk_PllConfigure+0xec>
                                manualConfig.feedbackDiv  = (uint8_t)p;
100056de:	b2da      	uxtb	r2, r3
100056e0:	9204      	str	r2, [sp, #16]
100056e2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
100056e4:	f8cd e00c 	str.w	lr, [sp, #12]
                                if (foutBest == (config->outputFreq))
100056e8:	2201      	movs	r2, #1
                                foutBest = fout;
100056ea:	9001      	str	r0, [sp, #4]
                                if (foutBest == (config->outputFreq))
100056ec:	9205      	str	r2, [sp, #20]
                        for (out = CY_SYSCLK_PLL_MIN_OUTPUT_DIV; out <= CY_SYSCLK_PLL_MAX_OUTPUT_DIV; out++)
100056ee:	3301      	adds	r3, #1
100056f0:	2b11      	cmp	r3, #17
100056f2:	d1e2      	bne.n	100056ba <Cy_SysClk_PllConfigure+0xb2>
                for (p = CY_SYSCLK_PLL_MIN_FB_DIV; p <= CY_SYSCLK_PLL_MAX_FB_DIV; p++)
100056f4:	9b00      	ldr	r3, [sp, #0]
100056f6:	18f6      	adds	r6, r6, r3
100056f8:	f109 0901 	add.w	r9, r9, #1
100056fc:	f14b 0b00 	adc.w	fp, fp, #0
10005700:	e7c4      	b.n	1000568c <Cy_SysClk_PllConfigure+0x84>
10005702:	f1b9 0f71 	cmp.w	r9, #113	; 0x71
10005706:	d007      	beq.n	10005718 <Cy_SysClk_PllConfigure+0x110>
                    uint32_t fvco = (uint32_t)(((uint64_t)(config->inputFreq) * (uint64_t)p) / (uint64_t)q);
10005708:	463b      	mov	r3, r7
1000570a:	4622      	mov	r2, r4
1000570c:	4630      	mov	r0, r6
1000570e:	4659      	mov	r1, fp
10005710:	f7fc fe46 	bl	100023a0 <__aeabi_uldivmod>
                    if ((CY_SYSCLK_PLL_MIN_FVCO <= fvco) && (fvco <= CY_SYSCLK_PLL_MAX_FVCO))
10005714:	4b19      	ldr	r3, [pc, #100]	; (1000577c <Cy_SysClk_PllConfigure+0x174>)
10005716:	e7c6      	b.n	100056a6 <Cy_SysClk_PllConfigure+0x9e>
            for (q = CY_SYSCLK_PLL_MIN_REF_DIV; q <= CY_SYSCLK_PLL_MAX_REF_DIV; q++)
10005718:	3401      	adds	r4, #1
1000571a:	f147 0700 	adc.w	r7, r7, #0
1000571e:	f1a4 0313 	sub.w	r3, r4, #19
10005722:	433b      	orrs	r3, r7
10005724:	d1ac      	bne.n	10005680 <Cy_SysClk_PllConfigure+0x78>
10005726:	9b05      	ldr	r3, [sp, #20]
10005728:	b13b      	cbz	r3, 1000573a <Cy_SysClk_PllConfigure+0x132>
1000572a:	9b03      	ldr	r3, [sp, #12]
1000572c:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
10005730:	9b04      	ldr	r3, [sp, #16]
10005732:	f88d 5031 	strb.w	r5, [sp, #49]	; 0x31
10005736:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
            manualConfig.lfMode = config->lfMode;
1000573a:	f88d a033 	strb.w	sl, [sp, #51]	; 0x33
        manualConfig.outputMode = config->outputMode;
1000573e:	9b02      	ldr	r3, [sp, #8]
        retVal = Cy_SysClk_PllManualConfigure(clkPath, &manualConfig);
10005740:	9808      	ldr	r0, [sp, #32]
        manualConfig.outputMode = config->outputMode;
10005742:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
        retVal = Cy_SysClk_PllManualConfigure(clkPath, &manualConfig);
10005746:	a90c      	add	r1, sp, #48	; 0x30
10005748:	f7ff feec 	bl	10005524 <Cy_SysClk_PllManualConfigure>
}
1000574c:	b00f      	add	sp, #60	; 0x3c
1000574e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            (void)Cy_SysClk_PllGetConfiguration(clkPath, &manualConfig);
10005752:	a90c      	add	r1, sp, #48	; 0x30
10005754:	f7ff ff32 	bl	100055bc <Cy_SysClk_PllGetConfiguration>
10005758:	e7f1      	b.n	1000573e <Cy_SysClk_PllConfigure+0x136>
        retVal = CY_SYSCLK_BAD_PARAM;
1000575a:	4809      	ldr	r0, [pc, #36]	; (10005780 <Cy_SysClk_PllConfigure+0x178>)
    return (retVal);
1000575c:	e7f6      	b.n	1000574c <Cy_SysClk_PllConfigure+0x144>
1000575e:	bf00      	nop
10005760:	03938700 	.word	0x03938700
10005764:	00a21fe8 	.word	0x00a21fe8
10005768:	00bebc20 	.word	0x00bebc20
1000576c:	08f0d180 	.word	0x08f0d180
10005770:	0bebc200 	.word	0x0bebc200
10005774:	17d78400 	.word	0x17d78400
10005778:	0a21fe7f 	.word	0x0a21fe7f
1000577c:	0bebc1ff 	.word	0x0bebc1ff
10005780:	004a0001 	.word	0x004a0001

10005784 <Cy_SysClk_PllEnable>:


cy_en_sysclk_status_t Cy_SysClk_PllEnable(uint32_t clkPath, uint32_t timeoutus)
{
10005784:	b570      	push	{r4, r5, r6, lr}
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    bool zeroTimeout = (timeoutus == 0UL);
    clkPath--; /* to correctly access PLL config and status registers structures */
    if (clkPath < CY_SRSS_NUM_PLL)
10005786:	4b23      	ldr	r3, [pc, #140]	; (10005814 <Cy_SysClk_PllEnable+0x90>)
10005788:	681b      	ldr	r3, [r3, #0]
1000578a:	f893 203f 	ldrb.w	r2, [r3, #63]	; 0x3f
    clkPath--; /* to correctly access PLL config and status registers structures */
1000578e:	1e43      	subs	r3, r0, #1
    if (clkPath < CY_SRSS_NUM_PLL)
10005790:	429a      	cmp	r2, r3
{
10005792:	460d      	mov	r5, r1
    if (clkPath < CY_SRSS_NUM_PLL)
10005794:	d93b      	bls.n	1000580e <Cy_SysClk_PllEnable+0x8a>
        (void)zeroTimeout;
        retVal = (cy_en_sysclk_status_t)CY_PRA_FUNCTION_CALL_RETURN_PARAM(CY_PRA_MSG_TYPE_FUNC_POLICY, CY_PRA_CLK_FUNC_PLL_ENABLE, (clkPath + 1U));
#endif /* defined (CY_DEVICE_SECURE) */
#if ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE)))
        /* first set the PLL enable bit */
        SRSS_CLK_PLL_CONFIG[clkPath] |= SRSS_CLK_PLL_CONFIG_ENABLE_Msk;
10005796:	0080      	lsls	r0, r0, #2
10005798:	f100 4480 	add.w	r4, r0, #1073741824	; 0x40000000
1000579c:	f504 1418 	add.w	r4, r4, #2490368	; 0x260000

        /* now do the timeout wait for PLL_STATUS, bit LOCKED */
        for (; (0UL == (SRSS_CLK_PLL_STATUS_LOCKED_Msk & SRSS_CLK_PLL_STATUS[clkPath])) &&
100057a0:	460e      	mov	r6, r1
        SRSS_CLK_PLL_CONFIG[clkPath] |= SRSS_CLK_PLL_CONFIG_ENABLE_Msk;
100057a2:	f8d4 35fc 	ldr.w	r3, [r4, #1532]	; 0x5fc
100057a6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
100057aa:	f8c4 35fc 	str.w	r3, [r4, #1532]	; 0x5fc
        for (; (0UL == (SRSS_CLK_PLL_STATUS_LOCKED_Msk & SRSS_CLK_PLL_STATUS[clkPath])) &&
100057ae:	f8d4 363c 	ldr.w	r3, [r4, #1596]	; 0x63c
100057b2:	07db      	lsls	r3, r3, #31
100057b4:	d419      	bmi.n	100057ea <Cy_SysClk_PllEnable+0x66>
100057b6:	b99e      	cbnz	r6, 100057e0 <Cy_SysClk_PllEnable+0x5c>
             timeoutus--)
        {
            Cy_SysLib_DelayUs(1U);
        }

        if (zeroTimeout || (0UL != timeoutus))
100057b8:	b1d5      	cbz	r5, 100057f0 <Cy_SysClk_PllEnable+0x6c>
            retVal = CY_SYSCLK_SUCCESS;
        }
        else
        {
            /* If lock doesn't occur, then bypass PLL */
            CY_REG32_CLR_SET(SRSS_CLK_PLL_CONFIG[clkPath], SRSS_CLK_PLL_CONFIG_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_INPUT);
100057ba:	f8d4 35fc 	ldr.w	r3, [r4, #1532]	; 0x5fc
100057be:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
100057c2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
100057c6:	f8c4 35fc 	str.w	r3, [r4, #1532]	; 0x5fc
            /* Wait at least 6 PLL clock cycles */
            Cy_SysLib_DelayUs(1U);
100057ca:	2001      	movs	r0, #1
100057cc:	f000 f90a 	bl	100059e4 <Cy_SysLib_DelayUs>
            /* And now disable the PLL itself */
            SRSS_CLK_PLL_CONFIG[clkPath] &= ~SRSS_CLK_PLL_CONFIG_ENABLE_Msk;
100057d0:	f8d4 35fc 	ldr.w	r3, [r4, #1532]	; 0x5fc
            retVal = CY_SYSCLK_TIMEOUT;
100057d4:	4810      	ldr	r0, [pc, #64]	; (10005818 <Cy_SysClk_PllEnable+0x94>)
            SRSS_CLK_PLL_CONFIG[clkPath] &= ~SRSS_CLK_PLL_CONFIG_ENABLE_Msk;
100057d6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
100057da:	f8c4 35fc 	str.w	r3, [r4, #1532]	; 0x5fc
            retVal = CY_SYSCLK_TIMEOUT;
100057de:	e00e      	b.n	100057fe <Cy_SysClk_PllEnable+0x7a>
            Cy_SysLib_DelayUs(1U);
100057e0:	2001      	movs	r0, #1
100057e2:	f000 f8ff 	bl	100059e4 <Cy_SysLib_DelayUs>
             timeoutus--)
100057e6:	3e01      	subs	r6, #1
100057e8:	e7e1      	b.n	100057ae <Cy_SysClk_PllEnable+0x2a>
        if (zeroTimeout || (0UL != timeoutus))
100057ea:	b10d      	cbz	r5, 100057f0 <Cy_SysClk_PllEnable+0x6c>
100057ec:	2e00      	cmp	r6, #0
100057ee:	d0e4      	beq.n	100057ba <Cy_SysClk_PllEnable+0x36>
            if ((uint32_t)CY_SYSCLK_FLLPLL_OUTPUT_INPUT == (uint32_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_BYPASS_SEL, SRSS_CLK_PLL_CONFIG[clkPath]))
100057f0:	f8d4 35fc 	ldr.w	r3, [r4, #1532]	; 0x5fc
100057f4:	f3c3 7301 	ubfx	r3, r3, #28, #2
100057f8:	2b02      	cmp	r3, #2
100057fa:	d001      	beq.n	10005800 <Cy_SysClk_PllEnable+0x7c>
            retVal = CY_SYSCLK_SUCCESS;
100057fc:	2000      	movs	r0, #0
        }
#endif /* ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE))) */
    }
    return (retVal);
}
100057fe:	bd70      	pop	{r4, r5, r6, pc}
                CY_REG32_CLR_SET(SRSS_CLK_PLL_CONFIG[clkPath], SRSS_CLK_PLL_CONFIG_BYPASS_SEL, CY_SYSCLK_FLLPLL_OUTPUT_OUTPUT);
10005800:	f8d4 35fc 	ldr.w	r3, [r4, #1532]	; 0x5fc
10005804:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
10005808:	f8c4 35fc 	str.w	r3, [r4, #1532]	; 0x5fc
1000580c:	e7f6      	b.n	100057fc <Cy_SysClk_PllEnable+0x78>
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
1000580e:	4803      	ldr	r0, [pc, #12]	; (1000581c <Cy_SysClk_PllEnable+0x98>)
    return (retVal);
10005810:	e7f5      	b.n	100057fe <Cy_SysClk_PllEnable+0x7a>
10005812:	bf00      	nop
10005814:	08003550 	.word	0x08003550
10005818:	004a0002 	.word	0x004a0002
1000581c:	004a0001 	.word	0x004a0001

10005820 <Cy_SysClk_FllGetFrequency>:
    return (CY_SYSLIB_DIV_ROUND(freq, 1UL + (uint32_t)Cy_SysClk_ClkTimerGetDivider()));
}


uint32_t Cy_SysClk_FllGetFrequency(void)
{
10005820:	b570      	push	{r4, r5, r6, lr}
10005822:	b086      	sub	sp, #24
    uint32_t rDiv;    /* FLL reference divider */
    uint32_t oDiv;    /* FLL output divider */
    bool  enabled;    /* FLL enable status; n/a for direct */
    uint32_t freq = 0UL;    /* FLL Frequency */

    cy_stc_fll_manual_config_t fllCfg = {0UL,0U,CY_SYSCLK_FLL_CCO_RANGE0,false,0U,0U,0U,0U,CY_SYSCLK_FLLPLL_OUTPUT_AUTO,0U};
10005824:	2214      	movs	r2, #20
10005826:	2100      	movs	r1, #0
10005828:	a801      	add	r0, sp, #4
1000582a:	f002 fb89 	bl	10007f40 <memset>
    Cy_SysClk_FllGetConfiguration(&fllCfg);
1000582e:	a801      	add	r0, sp, #4
10005830:	f7ff fdcc 	bl	100053cc <Cy_SysClk_FllGetConfiguration>
    return (_FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_ENABLE, SRSS_CLK_FLL_CONFIG));
10005834:	4b10      	ldr	r3, [pc, #64]	; (10005878 <Cy_SysClk_FllGetFrequency+0x58>)
10005836:	f8d3 3580 	ldr.w	r3, [r3, #1408]	; 0x580
    enabled = (Cy_SysClk_FllIsEnabled()) && (CY_SYSCLK_FLLPLL_OUTPUT_INPUT != fllCfg.outputMode);
1000583a:	2b00      	cmp	r3, #0
1000583c:	da18      	bge.n	10005870 <Cy_SysClk_FllGetFrequency+0x50>
1000583e:	f89d 3012 	ldrb.w	r3, [sp, #18]
10005842:	2b02      	cmp	r3, #2
10005844:	d014      	beq.n	10005870 <Cy_SysClk_FllGetFrequency+0x50>
    fDiv = fllCfg.fllMult;
    rDiv = fllCfg.refDiv;
10005846:	f8bd 1008 	ldrh.w	r1, [sp, #8]
    oDiv = (fllCfg.enableOutputDiv) ? 2UL : 1UL;

    if (enabled && /* If FLL is enabled and not bypassed */
1000584a:	b199      	cbz	r1, 10005874 <Cy_SysClk_FllGetFrequency+0x54>
        (0UL != rDiv)) /* to avoid division by zero */
    {
        freq = Cy_SysClk_ClkPathMuxGetFrequency(0UL); /* FLL mapped always to path 0 */
1000584c:	2000      	movs	r0, #0
    fDiv = fllCfg.fllMult;
1000584e:	9d01      	ldr	r5, [sp, #4]
    oDiv = (fllCfg.enableOutputDiv) ? 2UL : 1UL;
10005850:	f89d 600b 	ldrb.w	r6, [sp, #11]
        freq = Cy_SysClk_ClkPathMuxGetFrequency(0UL); /* FLL mapped always to path 0 */
10005854:	f7ff fce2 	bl	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>
        freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
10005858:	fb06 1201 	mla	r2, r6, r1, r1
1000585c:	2300      	movs	r3, #0
        freq = Cy_SysClk_ClkPathMuxGetFrequency(0UL); /* FLL mapped always to path 0 */
1000585e:	4604      	mov	r4, r0
        freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
10005860:	0859      	lsrs	r1, r3, #1
10005862:	0850      	lsrs	r0, r2, #1
10005864:	fbe4 0105 	umlal	r0, r1, r4, r5
10005868:	f7fc fd9a 	bl	100023a0 <__aeabi_uldivmod>
                                             ((uint64_t)rDiv * (uint64_t)oDiv));
    }

    return (freq);
}
1000586c:	b006      	add	sp, #24
1000586e:	bd70      	pop	{r4, r5, r6, pc}
    uint32_t freq = 0UL;    /* FLL Frequency */
10005870:	2000      	movs	r0, #0
10005872:	e7fb      	b.n	1000586c <Cy_SysClk_FllGetFrequency+0x4c>
10005874:	4608      	mov	r0, r1
    return (freq);
10005876:	e7f9      	b.n	1000586c <Cy_SysClk_FllGetFrequency+0x4c>
10005878:	40260000 	.word	0x40260000

1000587c <Cy_SysClk_PllGetFrequency>:

uint32_t Cy_SysClk_PllGetFrequency(uint32_t clkPath)
{
1000587c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint32_t rDiv;    /* PLL reference divider */
    uint32_t oDiv;    /* PLL output divider */
    bool  enabled;    /* PLL enable status; n/a for direct */
    uint32_t freq=0UL;    /* PLL Frequency */

    if ((CY_SRSS_NUM_PLL > 0UL) && (clkPath > 0UL))
1000587e:	4b1f      	ldr	r3, [pc, #124]	; (100058fc <Cy_SysClk_PllGetFrequency+0x80>)
10005880:	681a      	ldr	r2, [r3, #0]
10005882:	f892 103f 	ldrb.w	r1, [r2, #63]	; 0x3f
{
10005886:	4605      	mov	r5, r0
    if ((CY_SRSS_NUM_PLL > 0UL) && (clkPath > 0UL))
10005888:	b911      	cbnz	r1, 10005890 <Cy_SysClk_PllGetFrequency+0x14>
    uint32_t freq=0UL;    /* PLL Frequency */
1000588a:	2000      	movs	r0, #0
            }
        }
    }

    return (freq);
}
1000588c:	b002      	add	sp, #8
1000588e:	bd70      	pop	{r4, r5, r6, pc}
    if ((CY_SRSS_NUM_PLL > 0UL) && (clkPath > 0UL))
10005890:	2800      	cmp	r0, #0
10005892:	d0fa      	beq.n	1000588a <Cy_SysClk_PllGetFrequency+0xe>
        CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
10005894:	f892 203e 	ldrb.w	r2, [r2, #62]	; 0x3e
10005898:	4282      	cmp	r2, r0
1000589a:	d800      	bhi.n	1000589e <Cy_SysClk_PllGetFrequency+0x22>
1000589c:	be01      	bkpt	0x0001
        if (clkPath <= CY_SRSS_NUM_PLL)
1000589e:	681b      	ldr	r3, [r3, #0]
100058a0:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
100058a4:	42ab      	cmp	r3, r5
100058a6:	d3f0      	bcc.n	1000588a <Cy_SysClk_PllGetFrequency+0xe>
            cy_stc_pll_manual_config_t pllcfg = {0U,0U,0U,false,CY_SYSCLK_FLLPLL_OUTPUT_AUTO};
100058a8:	2400      	movs	r4, #0
            (void)Cy_SysClk_PllGetConfiguration(clkPath, &pllcfg);
100058aa:	4669      	mov	r1, sp
100058ac:	4628      	mov	r0, r5
            cy_stc_pll_manual_config_t pllcfg = {0U,0U,0U,false,CY_SYSCLK_FLLPLL_OUTPUT_AUTO};
100058ae:	9400      	str	r4, [sp, #0]
100058b0:	f88d 4004 	strb.w	r4, [sp, #4]
            (void)Cy_SysClk_PllGetConfiguration(clkPath, &pllcfg);
100058b4:	f7ff fe82 	bl	100055bc <Cy_SysClk_PllGetConfiguration>
            enabled = (Cy_SysClk_PllIsEnabled(clkPath)) && (CY_SYSCLK_FLLPLL_OUTPUT_INPUT != pllcfg.outputMode);
100058b8:	4628      	mov	r0, r5
100058ba:	f7ff fdf9 	bl	100054b0 <Cy_SysClk_PllIsEnabled>
100058be:	2800      	cmp	r0, #0
100058c0:	d0e4      	beq.n	1000588c <Cy_SysClk_PllGetFrequency+0x10>
100058c2:	f89d 3004 	ldrb.w	r3, [sp, #4]
100058c6:	2b02      	cmp	r3, #2
100058c8:	d0df      	beq.n	1000588a <Cy_SysClk_PllGetFrequency+0xe>
            rDiv = pllcfg.referenceDiv;
100058ca:	f89d 4001 	ldrb.w	r4, [sp, #1]
            if (enabled && /* If PLL is enabled and not bypassed */
100058ce:	2c00      	cmp	r4, #0
100058d0:	d0db      	beq.n	1000588a <Cy_SysClk_PllGetFrequency+0xe>
            oDiv = pllcfg.outputDiv;
100058d2:	f89d 1002 	ldrb.w	r1, [sp, #2]
            (0UL != rDiv) && (0UL != oDiv)) /* to avoid division by zero */
100058d6:	b171      	cbz	r1, 100058f6 <Cy_SysClk_PllGetFrequency+0x7a>
                freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
100058d8:	4628      	mov	r0, r5
            fDiv = pllcfg.feedbackDiv;
100058da:	f89d 6000 	ldrb.w	r6, [sp]
                freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
100058de:	f7ff fc9d 	bl	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>
                freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
100058e2:	fba4 2301 	umull	r2, r3, r4, r1
                freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
100058e6:	4605      	mov	r5, r0
                freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
100058e8:	0859      	lsrs	r1, r3, #1
100058ea:	0850      	lsrs	r0, r2, #1
100058ec:	fbe5 0106 	umlal	r0, r1, r5, r6
100058f0:	f7fc fd56 	bl	100023a0 <__aeabi_uldivmod>
100058f4:	e7ca      	b.n	1000588c <Cy_SysClk_PllGetFrequency+0x10>
    uint32_t freq=0UL;    /* PLL Frequency */
100058f6:	4608      	mov	r0, r1
    return (freq);
100058f8:	e7c8      	b.n	1000588c <Cy_SysClk_PllGetFrequency+0x10>
100058fa:	bf00      	nop
100058fc:	08003550 	.word	0x08003550

10005900 <Cy_SysClk_ClkPathGetFrequency>:
{
10005900:	b510      	push	{r4, lr}
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
10005902:	4b0d      	ldr	r3, [pc, #52]	; (10005938 <Cy_SysClk_ClkPathGetFrequency+0x38>)
10005904:	681a      	ldr	r2, [r3, #0]
10005906:	f892 203e 	ldrb.w	r2, [r2, #62]	; 0x3e
1000590a:	4282      	cmp	r2, r0
{
1000590c:	4604      	mov	r4, r0
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
1000590e:	d800      	bhi.n	10005912 <Cy_SysClk_ClkPathGetFrequency+0x12>
10005910:	be01      	bkpt	0x0001
    if (clkPath == (uint32_t)CY_SYSCLK_CLKHF_IN_CLKPATH0) /* FLL? (always path 0) */
10005912:	b91c      	cbnz	r4, 1000591c <Cy_SysClk_ClkPathGetFrequency+0x1c>
        freq = Cy_SysClk_FllGetFrequency();
10005914:	f7ff ff84 	bl	10005820 <Cy_SysClk_FllGetFrequency>
    if(freq==0UL)
10005918:	b128      	cbz	r0, 10005926 <Cy_SysClk_ClkPathGetFrequency+0x26>
}
1000591a:	bd10      	pop	{r4, pc}
    else if (clkPath <= CY_SRSS_NUM_PLL) /* PLL? (always path 1...N)*/
1000591c:	681b      	ldr	r3, [r3, #0]
1000591e:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
10005922:	42a3      	cmp	r3, r4
10005924:	d204      	bcs.n	10005930 <Cy_SysClk_ClkPathGetFrequency+0x30>
        freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
10005926:	4620      	mov	r0, r4
}
10005928:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
1000592c:	f7ff bc76 	b.w	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>
        freq = Cy_SysClk_PllGetFrequency(clkPath);
10005930:	4620      	mov	r0, r4
10005932:	f7ff ffa3 	bl	1000587c <Cy_SysClk_PllGetFrequency>
10005936:	e7ef      	b.n	10005918 <Cy_SysClk_ClkPathGetFrequency+0x18>
10005938:	08003550 	.word	0x08003550

1000593c <Cy_SysClk_ClkTimerGetFrequency>:
{
1000593c:	b510      	push	{r4, lr}
    return (_FLD2BOOL(SRSS_CLK_TIMER_CTL_ENABLE, SRSS_CLK_TIMER_CTL));
1000593e:	4c1b      	ldr	r4, [pc, #108]	; (100059ac <Cy_SysClk_ClkTimerGetFrequency+0x70>)
10005940:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
    if (Cy_SysClk_ClkTimerIsEnabled())
10005944:	2b00      	cmp	r3, #0
10005946:	da11      	bge.n	1000596c <Cy_SysClk_ClkTimerGetFrequency+0x30>
        freq = Cy_SysClk_ClkHfGetFrequency(0UL);
10005948:	2000      	movs	r0, #0
1000594a:	f002 fe0e 	bl	1000856a <Cy_SysClk_ClkHfGetFrequency>
    return ((cy_en_clktimer_in_sources_t)((uint32_t)(SRSS_CLK_TIMER_CTL & CY_SRSS_CLK_TIMER_CTL_TIMER_Msk)));
1000594e:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504
10005952:	f240 3201 	movw	r2, #769	; 0x301
10005956:	4013      	ands	r3, r2
        switch (Cy_SysClk_ClkTimerGetSource())
10005958:	f240 1101 	movw	r1, #257	; 0x101
1000595c:	428b      	cmp	r3, r1
1000595e:	d01e      	beq.n	1000599e <Cy_SysClk_ClkTimerGetFrequency+0x62>
10005960:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
10005964:	d213      	bcs.n	1000598e <Cy_SysClk_ClkTimerGetFrequency+0x52>
10005966:	b1f3      	cbz	r3, 100059a6 <Cy_SysClk_ClkTimerGetFrequency+0x6a>
10005968:	2b01      	cmp	r3, #1
1000596a:	d000      	beq.n	1000596e <Cy_SysClk_ClkTimerGetFrequency+0x32>
{
1000596c:	2000      	movs	r0, #0
    return ((uint8_t)_FLD2VAL(SRSS_CLK_TIMER_CTL_TIMER_DIV, SRSS_CLK_TIMER_CTL));
1000596e:	4b0f      	ldr	r3, [pc, #60]	; (100059ac <Cy_SysClk_ClkTimerGetFrequency+0x70>)
10005970:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
10005974:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
    return (CY_SYSLIB_DIV_ROUND(freq, 1UL + (uint32_t)Cy_SysClk_ClkTimerGetDivider()));
10005978:	f3c2 4207 	ubfx	r2, r2, #16, #8
1000597c:	3201      	adds	r2, #1
1000597e:	f3c3 4307 	ubfx	r3, r3, #16, #8
10005982:	eb00 0052 	add.w	r0, r0, r2, lsr #1
10005986:	3301      	adds	r3, #1
}
10005988:	fbb0 f0f3 	udiv	r0, r0, r3
1000598c:	bd10      	pop	{r4, pc}
        switch (Cy_SysClk_ClkTimerGetSource())
1000598e:	f240 2101 	movw	r1, #513	; 0x201
10005992:	428b      	cmp	r3, r1
10005994:	d005      	beq.n	100059a2 <Cy_SysClk_ClkTimerGetFrequency+0x66>
10005996:	4293      	cmp	r3, r2
10005998:	d1e8      	bne.n	1000596c <Cy_SysClk_ClkTimerGetFrequency+0x30>
                freq /= 8UL;
1000599a:	08c0      	lsrs	r0, r0, #3
                break;
1000599c:	e7e7      	b.n	1000596e <Cy_SysClk_ClkTimerGetFrequency+0x32>
                freq /= 2UL;
1000599e:	0840      	lsrs	r0, r0, #1
                break;
100059a0:	e7e5      	b.n	1000596e <Cy_SysClk_ClkTimerGetFrequency+0x32>
                freq /= 4UL;
100059a2:	0880      	lsrs	r0, r0, #2
                break;
100059a4:	e7e3      	b.n	1000596e <Cy_SysClk_ClkTimerGetFrequency+0x32>
                freq = CY_SYSCLK_IMO_FREQ;
100059a6:	4802      	ldr	r0, [pc, #8]	; (100059b0 <Cy_SysClk_ClkTimerGetFrequency+0x74>)
100059a8:	e7e1      	b.n	1000596e <Cy_SysClk_ClkTimerGetFrequency+0x32>
100059aa:	bf00      	nop
100059ac:	40260000 	.word	0x40260000
100059b0:	007a1200 	.word	0x007a1200

100059b4 <Cy_SysLib_Delay>:
        #endif /* (__ARMCC_VERSION >= 6010050) */
#endif  /* (__ARMCC_VERSION) */


void Cy_SysLib_Delay(uint32_t milliseconds)
{
100059b4:	b538      	push	{r3, r4, r5, lr}
    {
        /* This loop prevents an overflow in value passed to Cy_SysLib_DelayCycles() API.
         * At 100 MHz, (milliseconds * cy_delayFreqKhz) product overflows
         * in case if milliseconds parameter is more than 42 seconds.
         */
        Cy_SysLib_DelayCycles(cy_delay32kMs);
100059b6:	4d09      	ldr	r5, [pc, #36]	; (100059dc <Cy_SysLib_Delay+0x28>)
{
100059b8:	4604      	mov	r4, r0
    while(milliseconds > CY_DELAY_MS_OVERFLOW)
100059ba:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
100059be:	d806      	bhi.n	100059ce <Cy_SysLib_Delay+0x1a>
        milliseconds -= CY_DELAY_MS_OVERFLOW;
    }

    Cy_SysLib_DelayCycles(milliseconds * cy_delayFreqKhz);
100059c0:	4b07      	ldr	r3, [pc, #28]	; (100059e0 <Cy_SysLib_Delay+0x2c>)
100059c2:	6818      	ldr	r0, [r3, #0]
100059c4:	4360      	muls	r0, r4
}
100059c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Cy_SysLib_DelayCycles(milliseconds * cy_delayFreqKhz);
100059ca:	f7fc bc89 	b.w	100022e0 <Cy_SysLib_DelayCycles>
        Cy_SysLib_DelayCycles(cy_delay32kMs);
100059ce:	6828      	ldr	r0, [r5, #0]
100059d0:	f7fc fc86 	bl	100022e0 <Cy_SysLib_DelayCycles>
        milliseconds -= CY_DELAY_MS_OVERFLOW;
100059d4:	f5a4 4400 	sub.w	r4, r4, #32768	; 0x8000
100059d8:	e7ef      	b.n	100059ba <Cy_SysLib_Delay+0x6>
100059da:	bf00      	nop
100059dc:	08002898 	.word	0x08002898
100059e0:	0800289c 	.word	0x0800289c

100059e4 <Cy_SysLib_DelayUs>:


void Cy_SysLib_DelayUs(uint16_t microseconds)
{
    Cy_SysLib_DelayCycles((uint32_t) microseconds * cy_delayFreqMhz);
100059e4:	4b02      	ldr	r3, [pc, #8]	; (100059f0 <Cy_SysLib_DelayUs+0xc>)
100059e6:	781b      	ldrb	r3, [r3, #0]
100059e8:	4358      	muls	r0, r3
100059ea:	f7fc bc79 	b.w	100022e0 <Cy_SysLib_DelayCycles>
100059ee:	bf00      	nop
100059f0:	08002980 	.word	0x08002980

100059f4 <Cy_SysLib_SetWaitStates>:
}
#endif /* (CY_ARM_FAULT_DEBUG == CY_ARM_FAULT_DEBUG_ENABLED) || defined(CY_DOXYGEN) */


void Cy_SysLib_SetWaitStates(bool ulpMode, uint32_t clkHfMHz)
{
100059f4:	b570      	push	{r4, r5, r6, lr}
100059f6:	460a      	mov	r2, r1
#ifdef CY_IP_M4CPUSS
#if !((CY_CPU_CORTEX_M4) && (defined(CY_DEVICE_SECURE)))
    uint32_t waitStates;
    uint32_t freqMax;

    freqMax = ulpMode ? CY_SYSLIB_ULP_SLOW_WS_0_FREQ_MAX : CY_SYSLIB_LP_SLOW_WS_0_FREQ_MAX;
100059f8:	1e01      	subs	r1, r0, #0
    waitStates = (clkHfMHz <= freqMax) ? 0UL : 1UL;

    /* ROM */
    CPUSS_ROM_CTL = _CLR_SET_FLD32U(CPUSS_ROM_CTL, CPUSS_ROM_CTL_SLOW_WS, waitStates);
100059fa:	482d      	ldr	r0, [pc, #180]	; (10005ab0 <Cy_SysLib_SetWaitStates+0xbc>)
100059fc:	6803      	ldr	r3, [r0, #0]
100059fe:	f8b3 60ac 	ldrh.w	r6, [r3, #172]	; 0xac
10005a02:	681d      	ldr	r5, [r3, #0]
    freqMax = ulpMode ? CY_SYSLIB_ULP_SLOW_WS_0_FREQ_MAX : CY_SYSLIB_LP_SLOW_WS_0_FREQ_MAX;
10005a04:	bf18      	it	ne
10005a06:	2419      	movne	r4, #25
    CPUSS_ROM_CTL = _CLR_SET_FLD32U(CPUSS_ROM_CTL, CPUSS_ROM_CTL_SLOW_WS, waitStates);
10005a08:	5973      	ldr	r3, [r6, r5]
    freqMax = ulpMode ? CY_SYSLIB_ULP_SLOW_WS_0_FREQ_MAX : CY_SYSLIB_LP_SLOW_WS_0_FREQ_MAX;
10005a0a:	bf08      	it	eq
10005a0c:	2464      	moveq	r4, #100	; 0x64
    waitStates = (clkHfMHz <= freqMax) ? 0UL : 1UL;
10005a0e:	4294      	cmp	r4, r2
10005a10:	bf2c      	ite	cs
10005a12:	2400      	movcs	r4, #0
10005a14:	2401      	movcc	r4, #1
    CPUSS_ROM_CTL = _CLR_SET_FLD32U(CPUSS_ROM_CTL, CPUSS_ROM_CTL_SLOW_WS, waitStates);
10005a16:	f023 0303 	bic.w	r3, r3, #3
10005a1a:	4323      	orrs	r3, r4
10005a1c:	5173      	str	r3, [r6, r5]
    CPUSS_ROM_CTL = _CLR_SET_FLD32U(CPUSS_ROM_CTL, CPUSS_ROM_CTL_FAST_WS, 0UL);
10005a1e:	6803      	ldr	r3, [r0, #0]
10005a20:	f8b3 60ac 	ldrh.w	r6, [r3, #172]	; 0xac
10005a24:	681d      	ldr	r5, [r3, #0]
10005a26:	5973      	ldr	r3, [r6, r5]
10005a28:	f423 7340 	bic.w	r3, r3, #768	; 0x300
10005a2c:	5173      	str	r3, [r6, r5]

    /* SRAM */
    CPUSS_RAM0_CTL0 = _CLR_SET_FLD32U(CPUSS_RAM0_CTL0, CPUSS_RAM0_CTL0_SLOW_WS, waitStates);
10005a2e:	6803      	ldr	r3, [r0, #0]
10005a30:	681d      	ldr	r5, [r3, #0]
10005a32:	f8b3 60ae 	ldrh.w	r6, [r3, #174]	; 0xae
10005a36:	5973      	ldr	r3, [r6, r5]
10005a38:	f023 0303 	bic.w	r3, r3, #3
10005a3c:	4323      	orrs	r3, r4
10005a3e:	5173      	str	r3, [r6, r5]
    CPUSS_RAM0_CTL0 = _CLR_SET_FLD32U(CPUSS_RAM0_CTL0, CPUSS_RAM0_CTL0_FAST_WS, 0UL);
10005a40:	6803      	ldr	r3, [r0, #0]
10005a42:	f8b3 50ae 	ldrh.w	r5, [r3, #174]	; 0xae
10005a46:	681c      	ldr	r4, [r3, #0]
10005a48:	592b      	ldr	r3, [r5, r4]
10005a4a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
10005a4e:	512b      	str	r3, [r5, r4]
        CPUSS_RAM2_CTL0 = _CLR_SET_FLD32U(CPUSS_RAM2_CTL0, CPUSS_RAM2_CTL0_SLOW_WS, waitStates);
        CPUSS_RAM2_CTL0 = _CLR_SET_FLD32U(CPUSS_RAM2_CTL0, CPUSS_RAM2_CTL0_FAST_WS, 0UL);
    #endif /* defined (RAMC2_PRESENT) && (RAMC2_PRESENT == 1UL) */

    /* Flash */
    if (ulpMode)
10005a50:	b169      	cbz	r1, 10005a6e <Cy_SysLib_SetWaitStates+0x7a>
    {
        waitStates =  (clkHfMHz <= CY_SYSLIB_FLASH_ULP_WS_0_FREQ_MAX) ? 0UL :
10005a52:	2a10      	cmp	r2, #16
10005a54:	d923      	bls.n	10005a9e <Cy_SysLib_SetWaitStates+0xaa>
                     ((clkHfMHz <= CY_SYSLIB_FLASH_ULP_WS_1_FREQ_MAX) ? 1UL : 2UL);
    }
    else
    {
        waitStates =  (clkHfMHz <= cy_device->flashCtlMainWs0Freq) ? 0UL :
10005a56:	2a21      	cmp	r2, #33	; 0x21
10005a58:	bf8c      	ite	hi
10005a5a:	2102      	movhi	r1, #2
10005a5c:	2101      	movls	r1, #1
                     ((clkHfMHz <= cy_device->flashCtlMainWs2Freq) ? 2UL :
                     ((clkHfMHz <= cy_device->flashCtlMainWs3Freq) ? 3UL :
                     ((clkHfMHz <= cy_device->flashCtlMainWs4Freq) ? 4UL : 5UL))));
    }

    FLASHC_FLASH_CTL = _CLR_SET_FLD32U(FLASHC_FLASH_CTL, FLASHC_FLASH_CTL_MAIN_WS, waitStates);
10005a5e:	6803      	ldr	r3, [r0, #0]
10005a60:	685a      	ldr	r2, [r3, #4]
10005a62:	6813      	ldr	r3, [r2, #0]
10005a64:	f023 030f 	bic.w	r3, r3, #15
10005a68:	430b      	orrs	r3, r1
10005a6a:	6013      	str	r3, [r2, #0]
#else
    (void) ulpMode;
    (void) clkHfMHz;
#endif /* !((CY_CPU_CORTEX_M4) && (defined(CY_DEVICE_SECURE))) */
#endif
}
10005a6c:	bd70      	pop	{r4, r5, r6, pc}
        waitStates =  (clkHfMHz <= cy_device->flashCtlMainWs0Freq) ? 0UL :
10005a6e:	6803      	ldr	r3, [r0, #0]
10005a70:	f893 4055 	ldrb.w	r4, [r3, #85]	; 0x55
10005a74:	4294      	cmp	r4, r2
10005a76:	d2f2      	bcs.n	10005a5e <Cy_SysLib_SetWaitStates+0x6a>
                     ((clkHfMHz <= cy_device->flashCtlMainWs1Freq) ? 1UL :
10005a78:	f893 1056 	ldrb.w	r1, [r3, #86]	; 0x56
        waitStates =  (clkHfMHz <= cy_device->flashCtlMainWs0Freq) ? 0UL :
10005a7c:	4291      	cmp	r1, r2
10005a7e:	d210      	bcs.n	10005aa2 <Cy_SysLib_SetWaitStates+0xae>
                     ((clkHfMHz <= cy_device->flashCtlMainWs2Freq) ? 2UL :
10005a80:	f893 1057 	ldrb.w	r1, [r3, #87]	; 0x57
        waitStates =  (clkHfMHz <= cy_device->flashCtlMainWs0Freq) ? 0UL :
10005a84:	4291      	cmp	r1, r2
10005a86:	d20e      	bcs.n	10005aa6 <Cy_SysLib_SetWaitStates+0xb2>
                     ((clkHfMHz <= cy_device->flashCtlMainWs3Freq) ? 3UL :
10005a88:	f893 1058 	ldrb.w	r1, [r3, #88]	; 0x58
        waitStates =  (clkHfMHz <= cy_device->flashCtlMainWs0Freq) ? 0UL :
10005a8c:	4291      	cmp	r1, r2
10005a8e:	d20c      	bcs.n	10005aaa <Cy_SysLib_SetWaitStates+0xb6>
                     ((clkHfMHz <= cy_device->flashCtlMainWs4Freq) ? 4UL : 5UL))));
10005a90:	f893 3059 	ldrb.w	r3, [r3, #89]	; 0x59
        waitStates =  (clkHfMHz <= cy_device->flashCtlMainWs0Freq) ? 0UL :
10005a94:	4293      	cmp	r3, r2
10005a96:	bf34      	ite	cc
10005a98:	2105      	movcc	r1, #5
10005a9a:	2104      	movcs	r1, #4
10005a9c:	e7df      	b.n	10005a5e <Cy_SysLib_SetWaitStates+0x6a>
        waitStates =  (clkHfMHz <= CY_SYSLIB_FLASH_ULP_WS_0_FREQ_MAX) ? 0UL :
10005a9e:	2100      	movs	r1, #0
10005aa0:	e7dd      	b.n	10005a5e <Cy_SysLib_SetWaitStates+0x6a>
        waitStates =  (clkHfMHz <= cy_device->flashCtlMainWs0Freq) ? 0UL :
10005aa2:	2101      	movs	r1, #1
10005aa4:	e7db      	b.n	10005a5e <Cy_SysLib_SetWaitStates+0x6a>
10005aa6:	2102      	movs	r1, #2
10005aa8:	e7d9      	b.n	10005a5e <Cy_SysLib_SetWaitStates+0x6a>
10005aaa:	2103      	movs	r1, #3
10005aac:	e7d7      	b.n	10005a5e <Cy_SysLib_SetWaitStates+0x6a>
10005aae:	bf00      	nop
10005ab0:	08003550 	.word	0x08003550

10005ab4 <Cy_SysPm_LdoGetVoltage>:

cy_en_syspm_ldo_voltage_t Cy_SysPm_LdoGetVoltage(void)
{
    uint32_t curVoltage;

    curVoltage = _FLD2VAL(SRSS_PWR_TRIM_PWRSYS_CTL_ACT_REG_TRIM, SRSS_PWR_TRIM_PWRSYS_CTL);
10005ab4:	4b06      	ldr	r3, [pc, #24]	; (10005ad0 <Cy_SysPm_LdoGetVoltage+0x1c>)

    return ((curVoltage == (SFLASH_LDO_0P9V_TRIM)) ? CY_SYSPM_LDO_VOLTAGE_ULP : CY_SYSPM_LDO_VOLTAGE_LP);
10005ab6:	f04f 52b0 	mov.w	r2, #369098752	; 0x16000000
    curVoltage = _FLD2VAL(SRSS_PWR_TRIM_PWRSYS_CTL_ACT_REG_TRIM, SRSS_PWR_TRIM_PWRSYS_CTL);
10005aba:	f8d3 3f1c 	ldr.w	r3, [r3, #3868]	; 0xf1c
    return ((curVoltage == (SFLASH_LDO_0P9V_TRIM)) ? CY_SYSPM_LDO_VOLTAGE_ULP : CY_SYSPM_LDO_VOLTAGE_LP);
10005abe:	f892 0740 	ldrb.w	r0, [r2, #1856]	; 0x740
    curVoltage = _FLD2VAL(SRSS_PWR_TRIM_PWRSYS_CTL_ACT_REG_TRIM, SRSS_PWR_TRIM_PWRSYS_CTL);
10005ac2:	f003 031f 	and.w	r3, r3, #31
}
10005ac6:	1a18      	subs	r0, r3, r0
10005ac8:	bf18      	it	ne
10005aca:	2001      	movne	r0, #1
10005acc:	4770      	bx	lr
10005ace:	bf00      	nop
10005ad0:	4026f000 	.word	0x4026f000

10005ad4 <Cy_SysPm_LdoIsEnabled>:


bool Cy_SysPm_LdoIsEnabled(void)
{
    return ((0U != _FLD2VAL(SRSS_PWR_CTL_LINREG_DIS, SRSS_PWR_CTL)) ? false : true);
10005ad4:	4b03      	ldr	r3, [pc, #12]	; (10005ae4 <Cy_SysPm_LdoIsEnabled+0x10>)
10005ad6:	6818      	ldr	r0, [r3, #0]
10005ad8:	f480 0000 	eor.w	r0, r0, #8388608	; 0x800000
}
10005adc:	f3c0 50c0 	ubfx	r0, r0, #23, #1
10005ae0:	4770      	bx	lr
10005ae2:	bf00      	nop
10005ae4:	40260000 	.word	0x40260000

10005ae8 <Cy_SysPm_ReadStatus>:
{
10005ae8:	b508      	push	{r3, lr}
    if ((CPUSS_CM4_STATUS & CM4_DEEPSLEEP_MASK) == CM4_DEEPSLEEP_MASK)
10005aea:	4b1a      	ldr	r3, [pc, #104]	; (10005b54 <Cy_SysPm_ReadStatus+0x6c>)
10005aec:	681a      	ldr	r2, [r3, #0]
10005aee:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
10005af2:	6813      	ldr	r3, [r2, #0]
10005af4:	5819      	ldr	r1, [r3, r0]
10005af6:	f001 0103 	and.w	r1, r1, #3
10005afa:	2903      	cmp	r1, #3
    else if(0U != _FLD2VAL(CPUSS_CM4_STATUS_SLEEPING, CPUSS_CM4_STATUS))
10005afc:	bf18      	it	ne
10005afe:	5819      	ldrne	r1, [r3, r0]
    if ((CPUSS_CM0_STATUS & CM0_DEEPSLEEP_MASK) == CM0_DEEPSLEEP_MASK)
10005b00:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
10005b04:	581a      	ldr	r2, [r3, r0]
    else if(0U != _FLD2VAL(CPUSS_CM4_STATUS_SLEEPING, CPUSS_CM4_STATUS))
10005b06:	bf18      	it	ne
10005b08:	f001 0101 	andne.w	r1, r1, #1
    if ((CPUSS_CM0_STATUS & CM0_DEEPSLEEP_MASK) == CM0_DEEPSLEEP_MASK)
10005b0c:	f002 0203 	and.w	r2, r2, #3
10005b10:	bf14      	ite	ne
10005b12:	3101      	addne	r1, #1
        pmStatus |= CY_SYSPM_STATUS_CM4_DEEPSLEEP;
10005b14:	2104      	moveq	r1, #4
    if ((CPUSS_CM0_STATUS & CM0_DEEPSLEEP_MASK) == CM0_DEEPSLEEP_MASK)
10005b16:	2a03      	cmp	r2, #3
10005b18:	d10a      	bne.n	10005b30 <Cy_SysPm_ReadStatus+0x48>
        pmStatus |= CY_SYSPM_STATUS_CM0_DEEPSLEEP;
10005b1a:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
    if (Cy_SysPm_LdoIsEnabled())
10005b1e:	f7ff ffd9 	bl	10005ad4 <Cy_SysPm_LdoIsEnabled>
10005b22:	b168      	cbz	r0, 10005b40 <Cy_SysPm_ReadStatus+0x58>
        if (Cy_SysPm_LdoGetVoltage() != CY_SYSPM_LDO_VOLTAGE_ULP)
10005b24:	f7ff ffc6 	bl	10005ab4 <Cy_SysPm_LdoGetVoltage>
10005b28:	b180      	cbz	r0, 10005b4c <Cy_SysPm_ReadStatus+0x64>
            pmStatus |= CY_SYSPM_STATUS_SYSTEM_LP;
10005b2a:	f041 0080 	orr.w	r0, r1, #128	; 0x80
}
10005b2e:	bd08      	pop	{r3, pc}
    else if (0U != _FLD2VAL(CPUSS_CM0_STATUS_SLEEPING, CPUSS_CM0_STATUS))
10005b30:	581b      	ldr	r3, [r3, r0]
10005b32:	07db      	lsls	r3, r3, #31
        pmStatus |= CY_SYSPM_STATUS_CM0_SLEEP;
10005b34:	bf4c      	ite	mi
10005b36:	f441 7100 	orrmi.w	r1, r1, #512	; 0x200
        pmStatus |= CY_SYSPM_STATUS_CM0_ACTIVE;
10005b3a:	f441 7180 	orrpl.w	r1, r1, #256	; 0x100
10005b3e:	e7ee      	b.n	10005b1e <Cy_SysPm_ReadStatus+0x36>
    retVal = _FLD2VAL(SRSS_PWR_BUCK_CTL_BUCK_OUT1_SEL, SRSS_PWR_BUCK_CTL);
10005b40:	4b05      	ldr	r3, [pc, #20]	; (10005b58 <Cy_SysPm_ReadStatus+0x70>)
10005b42:	695b      	ldr	r3, [r3, #20]
10005b44:	f003 0307 	and.w	r3, r3, #7
        if (Cy_SysPm_BuckGetVoltage1() != CY_SYSPM_BUCK_OUT1_VOLTAGE_ULP)
10005b48:	2b02      	cmp	r3, #2
10005b4a:	d1ee      	bne.n	10005b2a <Cy_SysPm_ReadStatus+0x42>
            pmStatus |= CY_SYSPM_STATUS_SYSTEM_ULP;
10005b4c:	f441 6000 	orr.w	r0, r1, #2048	; 0x800
    return pmStatus;
10005b50:	e7ed      	b.n	10005b2e <Cy_SysPm_ReadStatus+0x46>
10005b52:	bf00      	nop
10005b54:	08003550 	.word	0x08003550
10005b58:	40260000 	.word	0x40260000

10005b5c <Cy_SysTick_SetClockSource>:
    SYSTICK_CTRL &= ~SysTick_CTRL_ENABLE_Msk;
}

void Cy_SysTick_SetClockSource(cy_en_systick_clock_source_t clockSource)
{
    if (clockSource == CY_SYSTICK_CLOCK_SOURCE_CLK_CPU)
10005b5c:	2804      	cmp	r0, #4
10005b5e:	d106      	bne.n	10005b6e <Cy_SysTick_SetClockSource+0x12>
    {
        SYSTICK_CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
10005b60:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
10005b64:	6913      	ldr	r3, [r2, #16]
10005b66:	f043 0304 	orr.w	r3, r3, #4
    else
    {
        #if ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE)))
            CPUSS_SYSTICK_CTL = _VAL2FLD(CPUSS_SYSTICK_CTL_CLOCK_SOURCE, (uint32_t) clockSource);
        #endif /* ((CY_CPU_CORTEX_M0P) || (!defined(CY_DEVICE_SECURE))) */
        SYSTICK_CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
10005b6a:	6113      	str	r3, [r2, #16]
    }
}
10005b6c:	4770      	bx	lr
            CPUSS_SYSTICK_CTL = _VAL2FLD(CPUSS_SYSTICK_CTL_CLOCK_SOURCE, (uint32_t) clockSource);
10005b6e:	4b07      	ldr	r3, [pc, #28]	; (10005b8c <Cy_SysTick_SetClockSource+0x30>)
10005b70:	681b      	ldr	r3, [r3, #0]
10005b72:	0600      	lsls	r0, r0, #24
10005b74:	681a      	ldr	r2, [r3, #0]
10005b76:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
10005b7a:	f000 7040 	and.w	r0, r0, #50331648	; 0x3000000
10005b7e:	50d0      	str	r0, [r2, r3]
        SYSTICK_CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
10005b80:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
10005b84:	6913      	ldr	r3, [r2, #16]
10005b86:	f023 0304 	bic.w	r3, r3, #4
10005b8a:	e7ee      	b.n	10005b6a <Cy_SysTick_SetClockSource+0xe>
10005b8c:	08003550 	.word	0x08003550

10005b90 <Cy_TrigMux_Connect>:
*
*******************************************************************************/
cy_en_trigmux_status_t Cy_TrigMux_Connect(uint32_t inTrig, uint32_t outTrig, bool invert, en_trig_type_t trigType)
{
    cy_en_trigmux_status_t retVal = CY_TRIGMUX_BAD_PARAM;
    CY_ASSERT_L3(CY_TRIGMUX_IS_TRIGTYPE_VALID(trigType));
10005b90:	2b01      	cmp	r3, #1
{
10005b92:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
10005b96:	4604      	mov	r4, r0
10005b98:	460e      	mov	r6, r1
10005b9a:	4617      	mov	r7, r2
10005b9c:	461d      	mov	r5, r3
    CY_ASSERT_L3(CY_TRIGMUX_IS_TRIGTYPE_VALID(trigType));
10005b9e:	d900      	bls.n	10005ba2 <Cy_TrigMux_Connect+0x12>
10005ba0:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_TRIGMUX_IS_INTRIG_VALID(inTrig));
10005ba2:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
10005ba6:	d300      	bcc.n	10005baa <Cy_TrigMux_Connect+0x1a>
10005ba8:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_TRIGMUX_IS_OUTTRIG_VALID(outTrig));
10005baa:	f8df 9084 	ldr.w	r9, [pc, #132]	; 10005c30 <Cy_TrigMux_Connect+0xa0>
10005bae:	f8d9 3000 	ldr.w	r3, [r9]
10005bb2:	f8b3 0072 	ldrh.w	r0, [r3, #114]	; 0x72
10005bb6:	0880      	lsrs	r0, r0, #2
10005bb8:	4240      	negs	r0, r0
10005bba:	f020 4080 	bic.w	r0, r0, #1073741824	; 0x40000000
10005bbe:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
10005bc2:	4230      	tst	r0, r6
10005bc4:	d101      	bne.n	10005bca <Cy_TrigMux_Connect+0x3a>
10005bc6:	0073      	lsls	r3, r6, #1
10005bc8:	d400      	bmi.n	10005bcc <Cy_TrigMux_Connect+0x3c>
10005bca:	be01      	bkpt	0x0001

    /* inTrig and outTrig should be in the same group */
    if ((inTrig & PERI_TR_CMD_GROUP_SEL_Msk) == (outTrig & PERI_TR_CMD_GROUP_SEL_Msk))
10005bcc:	ea84 0806 	eor.w	r8, r4, r6
10005bd0:	f418 6870 	ands.w	r8, r8, #3840	; 0xf00
10005bd4:	d129      	bne.n	10005c2a <Cy_TrigMux_Connect+0x9a>
    {
        uint32_t interruptState = Cy_SysLib_EnterCriticalSection();
10005bd6:	f7fc fb8c 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>

        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005bda:	f8d9 1000 	ldr.w	r1, [r9]
10005bde:	f8b1 c072 	ldrh.w	ip, [r1, #114]	; 0x72
10005be2:	f8b1 3070 	ldrh.w	r3, [r1, #112]	; 0x70
10005be6:	f8d1 e008 	ldr.w	lr, [r1, #8]
10005bea:	f8b1 106e 	ldrh.w	r1, [r1, #110]	; 0x6e
10005bee:	ea4f 029c 	mov.w	r2, ip, lsr #2
10005bf2:	3a01      	subs	r2, #1
10005bf4:	4031      	ands	r1, r6
10005bf6:	4032      	ands	r2, r6
10005bf8:	4473      	add	r3, lr
10005bfa:	0a09      	lsrs	r1, r1, #8
10005bfc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
10005c00:	fb0c f101 	mul.w	r1, ip, r1
                                      (uint32_t)~(PERI_TR_GR_TR_OUT_CTL_TR_SEL_Msk |
                                                  PERI_TR_GR_TR_OUT_CTL_TR_INV_Msk |
                                                  PERI_TR_GR_TR_OUT_CTL_TR_EDGE_Msk)) |
                                        (_VAL2FLD(PERI_TR_GR_TR_OUT_CTL_TR_SEL, inTrig) |
10005c04:	b2e4      	uxtb	r4, r4
        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005c06:	585a      	ldr	r2, [r3, r1]
                                        _BOOL2FLD(PERI_TR_GR_TR_OUT_CTL_TR_INV, invert) |
                                         _VAL2FLD(PERI_TR_GR_TR_OUT_CTL_TR_EDGE, trigType));
10005c08:	026d      	lsls	r5, r5, #9
                                        (_VAL2FLD(PERI_TR_GR_TR_OUT_CTL_TR_SEL, inTrig) |
10005c0a:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
                                         _VAL2FLD(PERI_TR_GR_TR_OUT_CTL_TR_EDGE, trigType));
10005c0e:	f405 7500 	and.w	r5, r5, #512	; 0x200
        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005c12:	f422 727f 	bic.w	r2, r2, #1020	; 0x3fc
                                        _BOOL2FLD(PERI_TR_GR_TR_OUT_CTL_TR_INV, invert) |
10005c16:	432c      	orrs	r4, r5
        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005c18:	f022 0203 	bic.w	r2, r2, #3
                                                  PERI_TR_GR_TR_OUT_CTL_TR_EDGE_Msk)) |
10005c1c:	4314      	orrs	r4, r2
        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005c1e:	505c      	str	r4, [r3, r1]

        Cy_SysLib_ExitCriticalSection(interruptState);
10005c20:	f7fc fb6b 	bl	100022fa <Cy_SysLib_ExitCriticalSection>

        retVal = CY_TRIGMUX_SUCCESS;
    }

    return retVal;
}
10005c24:	4640      	mov	r0, r8
10005c26:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    cy_en_trigmux_status_t retVal = CY_TRIGMUX_BAD_PARAM;
10005c2a:	f8df 8008 	ldr.w	r8, [pc, #8]	; 10005c34 <Cy_TrigMux_Connect+0xa4>
    return retVal;
10005c2e:	e7f9      	b.n	10005c24 <Cy_TrigMux_Connect+0x94>
10005c30:	08003550 	.word	0x08003550
10005c34:	00ce0001 	.word	0x00ce0001

10005c38 <Cy_TrigMux_Select>:
*******************************************************************************/
cy_en_trigmux_status_t Cy_TrigMux_Select(uint32_t outTrig, bool invert, en_trig_type_t trigType)
{
    cy_en_trigmux_status_t retVal = CY_TRIGMUX_BAD_PARAM;

    CY_ASSERT_L3(CY_TRIGMUX_IS_TRIGTYPE_VALID(trigType));
10005c38:	2a01      	cmp	r2, #1
{
10005c3a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10005c3c:	4606      	mov	r6, r0
10005c3e:	460d      	mov	r5, r1
10005c40:	4614      	mov	r4, r2
    CY_ASSERT_L3(CY_TRIGMUX_IS_TRIGTYPE_VALID(trigType));
10005c42:	d900      	bls.n	10005c46 <Cy_TrigMux_Select+0xe>
10005c44:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_TRIGMUX_IS_ONETRIG_VALID(outTrig));
10005c46:	4f1f      	ldr	r7, [pc, #124]	; (10005cc4 <Cy_TrigMux_Select+0x8c>)
10005c48:	683b      	ldr	r3, [r7, #0]
10005c4a:	f8b3 3072 	ldrh.w	r3, [r3, #114]	; 0x72
10005c4e:	089b      	lsrs	r3, r3, #2
10005c50:	425b      	negs	r3, r3
10005c52:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
10005c56:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
10005c5a:	4233      	tst	r3, r6
10005c5c:	d102      	bne.n	10005c64 <Cy_TrigMux_Select+0x2c>
10005c5e:	4b1a      	ldr	r3, [pc, #104]	; (10005cc8 <Cy_TrigMux_Select+0x90>)
10005c60:	43b3      	bics	r3, r6
10005c62:	d000      	beq.n	10005c66 <Cy_TrigMux_Select+0x2e>
10005c64:	be01      	bkpt	0x0001

    if (!CY_PERI_V1)
10005c66:	683b      	ldr	r3, [r7, #0]
10005c68:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
10005c6c:	2b1f      	cmp	r3, #31
10005c6e:	d926      	bls.n	10005cbe <Cy_TrigMux_Select+0x86>
    {
        uint32_t interruptState;

        interruptState = Cy_SysLib_EnterCriticalSection();
10005c70:	f7fc fb3f 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>

        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005c74:	6839      	ldr	r1, [r7, #0]
10005c76:	f8b1 7072 	ldrh.w	r7, [r1, #114]	; 0x72
10005c7a:	f8b1 2070 	ldrh.w	r2, [r1, #112]	; 0x70
10005c7e:	f8d1 c008 	ldr.w	ip, [r1, #8]
10005c82:	08bb      	lsrs	r3, r7, #2
10005c84:	3b01      	subs	r3, #1
10005c86:	4033      	ands	r3, r6
10005c88:	4462      	add	r2, ip
10005c8a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
10005c8e:	f8b1 306e 	ldrh.w	r3, [r1, #110]	; 0x6e
10005c92:	4033      	ands	r3, r6
10005c94:	0a1b      	lsrs	r3, r3, #8
10005c96:	437b      	muls	r3, r7
                          (uint32_t)~(PERI_TR_1TO1_GR_V2_TR_CTL_TR_INV_Msk |
                                      PERI_TR_1TO1_GR_V2_TR_CTL_TR_EDGE_Msk)) |
                                     (PERI_TR_1TO1_GR_V2_TR_CTL_TR_SEL_Msk      |
                            _BOOL2FLD(PERI_TR_1TO1_GR_V2_TR_CTL_TR_INV, invert) |
                             _VAL2FLD(PERI_TR_1TO1_GR_V2_TR_CTL_TR_EDGE, trigType));
10005c98:	0264      	lsls	r4, r4, #9
        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005c9a:	58d6      	ldr	r6, [r2, r3]
                                     (PERI_TR_1TO1_GR_V2_TR_CTL_TR_SEL_Msk      |
10005c9c:	2d00      	cmp	r5, #0
        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005c9e:	f426 7640 	bic.w	r6, r6, #768	; 0x300
                             _VAL2FLD(PERI_TR_1TO1_GR_V2_TR_CTL_TR_EDGE, trigType));
10005ca2:	f404 7400 	and.w	r4, r4, #512	; 0x200
                                     (PERI_TR_1TO1_GR_V2_TR_CTL_TR_SEL_Msk      |
10005ca6:	f240 1101 	movw	r1, #257	; 0x101
                                      PERI_TR_1TO1_GR_V2_TR_CTL_TR_EDGE_Msk)) |
10005caa:	ea44 0406 	orr.w	r4, r4, r6
                                     (PERI_TR_1TO1_GR_V2_TR_CTL_TR_SEL_Msk      |
10005cae:	bf08      	it	eq
10005cb0:	2101      	moveq	r1, #1
                                      PERI_TR_1TO1_GR_V2_TR_CTL_TR_EDGE_Msk)) |
10005cb2:	430c      	orrs	r4, r1
        CY_TRIGMUX_TR_CTL(outTrig) = (CY_TRIGMUX_TR_CTL(outTrig) &
10005cb4:	50d4      	str	r4, [r2, r3]

        Cy_SysLib_ExitCriticalSection(interruptState);
10005cb6:	f7fc fb20 	bl	100022fa <Cy_SysLib_ExitCriticalSection>

        retVal = CY_TRIGMUX_SUCCESS;
10005cba:	2000      	movs	r0, #0
    }

    return retVal;
}
10005cbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    cy_en_trigmux_status_t retVal = CY_TRIGMUX_BAD_PARAM;
10005cbe:	4803      	ldr	r0, [pc, #12]	; (10005ccc <Cy_TrigMux_Select+0x94>)
    return retVal;
10005cc0:	e7fc      	b.n	10005cbc <Cy_TrigMux_Select+0x84>
10005cc2:	bf00      	nop
10005cc4:	08003550 	.word	0x08003550
10005cc8:	40001000 	.word	0x40001000
10005ccc:	00ce0001 	.word	0x00ce0001

10005cd0 <Cy_TrigMux_Deselect>:
* \funcusage
* \snippet trigmux/snippet/main.c snippet_Cy_TrigMux_Deselect
*
*******************************************************************************/
cy_en_trigmux_status_t Cy_TrigMux_Deselect(uint32_t outTrig)
{
10005cd0:	b538      	push	{r3, r4, r5, lr}
    cy_en_trigmux_status_t retVal = CY_TRIGMUX_BAD_PARAM;

    CY_ASSERT_L2(CY_TRIGMUX_IS_ONETRIG_VALID(outTrig));
10005cd2:	4d1b      	ldr	r5, [pc, #108]	; (10005d40 <Cy_TrigMux_Deselect+0x70>)
10005cd4:	682b      	ldr	r3, [r5, #0]
10005cd6:	f8b3 3072 	ldrh.w	r3, [r3, #114]	; 0x72
10005cda:	089b      	lsrs	r3, r3, #2
10005cdc:	425b      	negs	r3, r3
10005cde:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
10005ce2:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
10005ce6:	4203      	tst	r3, r0
{
10005ce8:	4604      	mov	r4, r0
    CY_ASSERT_L2(CY_TRIGMUX_IS_ONETRIG_VALID(outTrig));
10005cea:	d102      	bne.n	10005cf2 <Cy_TrigMux_Deselect+0x22>
10005cec:	4b15      	ldr	r3, [pc, #84]	; (10005d44 <Cy_TrigMux_Deselect+0x74>)
10005cee:	4383      	bics	r3, r0
10005cf0:	d000      	beq.n	10005cf4 <Cy_TrigMux_Deselect+0x24>
10005cf2:	be01      	bkpt	0x0001

    if (!CY_PERI_V1)
10005cf4:	682b      	ldr	r3, [r5, #0]
10005cf6:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
10005cfa:	2b1f      	cmp	r3, #31
10005cfc:	d91d      	bls.n	10005d3a <Cy_TrigMux_Deselect+0x6a>
    {
        uint32_t interruptState;

        interruptState = Cy_SysLib_EnterCriticalSection();
10005cfe:	f7fc faf8 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>

        CY_TRIGMUX_TR_CTL(outTrig) &= (uint32_t)~(PERI_TR_1TO1_GR_V2_TR_CTL_TR_SEL_Msk |
10005d02:	682d      	ldr	r5, [r5, #0]
10005d04:	f8b5 106e 	ldrh.w	r1, [r5, #110]	; 0x6e
10005d08:	f8b5 3072 	ldrh.w	r3, [r5, #114]	; 0x72
10005d0c:	f8b5 2070 	ldrh.w	r2, [r5, #112]	; 0x70
10005d10:	68ad      	ldr	r5, [r5, #8]
10005d12:	4021      	ands	r1, r4
10005d14:	0a09      	lsrs	r1, r1, #8
10005d16:	442a      	add	r2, r5
10005d18:	fb03 2201 	mla	r2, r3, r1, r2
10005d1c:	089b      	lsrs	r3, r3, #2
10005d1e:	3b01      	subs	r3, #1
10005d20:	4023      	ands	r3, r4
10005d22:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
10005d26:	f421 7140 	bic.w	r1, r1, #768	; 0x300
10005d2a:	f021 0101 	bic.w	r1, r1, #1
10005d2e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                                  PERI_TR_1TO1_GR_V2_TR_CTL_TR_INV_Msk |
                                                  PERI_TR_1TO1_GR_V2_TR_CTL_TR_EDGE_Msk);

        Cy_SysLib_ExitCriticalSection(interruptState);
10005d32:	f7fc fae2 	bl	100022fa <Cy_SysLib_ExitCriticalSection>

        retVal = CY_TRIGMUX_SUCCESS;
10005d36:	2000      	movs	r0, #0
    }

    return retVal;
}
10005d38:	bd38      	pop	{r3, r4, r5, pc}
    cy_en_trigmux_status_t retVal = CY_TRIGMUX_BAD_PARAM;
10005d3a:	4803      	ldr	r0, [pc, #12]	; (10005d48 <Cy_TrigMux_Deselect+0x78>)
    return retVal;
10005d3c:	e7fc      	b.n	10005d38 <Cy_TrigMux_Deselect+0x68>
10005d3e:	bf00      	nop
10005d40:	08003550 	.word	0x08003550
10005d44:	40001000 	.word	0x40001000
10005d48:	00ce0001 	.word	0x00ce0001

10005d4c <_cyhal_uart_init_hw>:

    return result;
}

static cy_rslt_t _cyhal_uart_init_hw(cyhal_uart_t *obj)
{
10005d4c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    obj->base = _CYHAL_SCB_BASE_ADDRESSES[obj->resource.block_num];
10005d4e:	4b1c      	ldr	r3, [pc, #112]	; (10005dc0 <_cyhal_uart_init_hw+0x74>)
10005d50:	7942      	ldrb	r2, [r0, #5]
{
10005d52:	4604      	mov	r4, r0
    obj->base = _CYHAL_SCB_BASE_ADDRESSES[obj->resource.block_num];
10005d54:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
10005d58:	4622      	mov	r2, r4

    cy_rslt_t result = (cy_rslt_t) Cy_SCB_UART_Init(obj->base, &(obj->config), &(obj->context));
10005d5a:	f104 0154 	add.w	r1, r4, #84	; 0x54
    obj->base = _CYHAL_SCB_BASE_ADDRESSES[obj->resource.block_num];
10005d5e:	f842 0b18 	str.w	r0, [r2], #24
    cy_rslt_t result = (cy_rslt_t) Cy_SCB_UART_Init(obj->base, &(obj->config), &(obj->context));
10005d62:	f7fe f9a3 	bl	100040ac <Cy_SCB_UART_Init>

    if (CY_RSLT_SUCCESS == result)
10005d66:	4605      	mov	r5, r0
10005d68:	bb38      	cbnz	r0, 10005dba <_cyhal_uart_init_hw+0x6e>
    {
        obj->callback_data.callback = NULL;
        obj->callback_data.callback_arg = NULL;
        obj->irq_cause = CYHAL_UART_IRQ_NONE;

        cy_stc_sysint_t irqCfg = { _CYHAL_SCB_IRQ_N[obj->resource.block_num], CYHAL_ISR_PRIORITY_DEFAULT };
10005d6a:	4e16      	ldr	r6, [pc, #88]	; (10005dc4 <_cyhal_uart_init_hw+0x78>)
10005d6c:	7963      	ldrb	r3, [r4, #5]
        obj->irq_cause = CYHAL_UART_IRQ_NONE;
10005d6e:	f8c4 0094 	str.w	r0, [r4, #148]	; 0x94
        cy_stc_sysint_t irqCfg = { _CYHAL_SCB_IRQ_N[obj->resource.block_num], CYHAL_ISR_PRIORITY_DEFAULT };
10005d72:	f836 3013 	ldrh.w	r3, [r6, r3, lsl #1]
10005d76:	f8ad 3000 	strh.w	r3, [sp]
        obj->callback_data.callback_arg = NULL;
10005d7a:	e9c4 0027 	strd	r0, r0, [r4, #156]	; 0x9c
        cy_stc_sysint_t irqCfg = { _CYHAL_SCB_IRQ_N[obj->resource.block_num], CYHAL_ISR_PRIORITY_DEFAULT };
10005d7e:	2307      	movs	r3, #7
        Cy_SysInt_Init(&irqCfg, _cyhal_uart_irq_handler);
10005d80:	4911      	ldr	r1, [pc, #68]	; (10005dc8 <_cyhal_uart_init_hw+0x7c>)
        cy_stc_sysint_t irqCfg = { _CYHAL_SCB_IRQ_N[obj->resource.block_num], CYHAL_ISR_PRIORITY_DEFAULT };
10005d82:	9301      	str	r3, [sp, #4]
        Cy_SysInt_Init(&irqCfg, _cyhal_uart_irq_handler);
10005d84:	4668      	mov	r0, sp
10005d86:	f002 f897 	bl	10007eb8 <Cy_SysInt_Init>
        NVIC_EnableIRQ(_CYHAL_SCB_IRQ_N[obj->resource.block_num]);
10005d8a:	7963      	ldrb	r3, [r4, #5]
10005d8c:	f936 3013 	ldrsh.w	r3, [r6, r3, lsl #1]
  if ((int32_t)(IRQn) >= 0)
10005d90:	2b00      	cmp	r3, #0
10005d92:	db08      	blt.n	10005da6 <_cyhal_uart_init_hw+0x5a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
10005d94:	2201      	movs	r2, #1
10005d96:	0959      	lsrs	r1, r3, #5
10005d98:	f003 031f 	and.w	r3, r3, #31
10005d9c:	fa02 f303 	lsl.w	r3, r2, r3
10005da0:	4a0a      	ldr	r2, [pc, #40]	; (10005dcc <_cyhal_uart_init_hw+0x80>)
10005da2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

        _cyhal_scb_update_instance_data(obj->resource.block_num, (void*)obj, &_cyhal_uart_pm_callback_instance);
10005da6:	4a0a      	ldr	r2, [pc, #40]	; (10005dd0 <_cyhal_uart_init_hw+0x84>)
10005da8:	7960      	ldrb	r0, [r4, #5]
10005daa:	4621      	mov	r1, r4
10005dac:	f000 fa46 	bl	1000623c <_cyhal_scb_update_instance_data>

        Cy_SCB_UART_Enable(obj->base);
10005db0:	6822      	ldr	r2, [r4, #0]
* The pointer to the UART SCB instance.
*
*******************************************************************************/
__STATIC_INLINE void Cy_SCB_UART_Enable(CySCB_Type *base)
{
    SCB_CTRL(base) |= SCB_CTRL_ENABLED_Msk;
10005db2:	6813      	ldr	r3, [r2, #0]
10005db4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
10005db8:	6013      	str	r3, [r2, #0]
    }

    return result;
}
10005dba:	4628      	mov	r0, r5
10005dbc:	b002      	add	sp, #8
10005dbe:	bd70      	pop	{r4, r5, r6, pc}
10005dc0:	10009420 	.word	0x10009420
10005dc4:	100097ca 	.word	0x100097ca
10005dc8:	10008691 	.word	0x10008691
10005dcc:	e000e100 	.word	0xe000e100
10005dd0:	10005dd5 	.word	0x10005dd5

10005dd4 <_cyhal_uart_pm_callback_instance>:
{
10005dd4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    GPIO_PRT_Type *txport = obj->pin_tx != NC ? CYHAL_GET_PORTADDR(obj->pin_tx) : NULL;
10005dd8:	f890 8008 	ldrb.w	r8, [r0, #8]
10005ddc:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
{
10005de0:	4605      	mov	r5, r0
    GPIO_PRT_Type *txport = obj->pin_tx != NC ? CYHAL_GET_PORTADDR(obj->pin_tx) : NULL;
10005de2:	d024      	beq.n	10005e2e <_cyhal_uart_pm_callback_instance+0x5a>
{
    GPIO_PRT_Type* portBase;

    if(portNum < (uint32_t)IOSS_GPIO_GPIO_PORT_NR)
    {
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
10005de4:	4943      	ldr	r1, [pc, #268]	; (10005ef4 <_cyhal_uart_pm_callback_instance+0x120>)
10005de6:	6809      	ldr	r1, [r1, #0]
    if(portNum < (uint32_t)IOSS_GPIO_GPIO_PORT_NR)
10005de8:	f1b8 0f77 	cmp.w	r8, #119	; 0x77
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
10005dec:	698e      	ldr	r6, [r1, #24]
10005dee:	ea4f 03d8 	mov.w	r3, r8, lsr #3
    if(portNum < (uint32_t)IOSS_GPIO_GPIO_PORT_NR)
10005df2:	d801      	bhi.n	10005df8 <_cyhal_uart_pm_callback_instance+0x24>
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
10005df4:	eb06 16c3 	add.w	r6, r6, r3, lsl #7
    GPIO_PRT_Type *rtsport = ((obj->pin_rts != NC) && obj->rts_enabled) ? CYHAL_GET_PORTADDR(obj->pin_rts) : NULL;
10005df8:	7aaf      	ldrb	r7, [r5, #10]
10005dfa:	2fff      	cmp	r7, #255	; 0xff
10005dfc:	d019      	beq.n	10005e32 <_cyhal_uart_pm_callback_instance+0x5e>
10005dfe:	7b2c      	ldrb	r4, [r5, #12]
10005e00:	b144      	cbz	r4, 10005e14 <_cyhal_uart_pm_callback_instance+0x40>
10005e02:	493c      	ldr	r1, [pc, #240]	; (10005ef4 <_cyhal_uart_pm_callback_instance+0x120>)
10005e04:	6809      	ldr	r1, [r1, #0]
    if(portNum < (uint32_t)IOSS_GPIO_GPIO_PORT_NR)
10005e06:	2f77      	cmp	r7, #119	; 0x77
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
10005e08:	698c      	ldr	r4, [r1, #24]
10005e0a:	ea4f 03d7 	mov.w	r3, r7, lsr #3
    if(portNum < (uint32_t)IOSS_GPIO_GPIO_PORT_NR)
10005e0e:	d801      	bhi.n	10005e14 <_cyhal_uart_pm_callback_instance+0x40>
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
10005e10:	eb04 14c3 	add.w	r4, r4, r3, lsl #7
    switch (pdl_mode)
10005e14:	3a01      	subs	r2, #1
    uint8_t txpin = (uint8_t)CYHAL_GET_PIN(obj->pin_tx);
10005e16:	f008 0807 	and.w	r8, r8, #7
    uint8_t rtspin = (uint8_t)CYHAL_GET_PIN(obj->pin_rts);
10005e1a:	f007 0707 	and.w	r7, r7, #7
    switch (pdl_mode)
10005e1e:	2a07      	cmp	r2, #7
10005e20:	d865      	bhi.n	10005eee <_cyhal_uart_pm_callback_instance+0x11a>
10005e22:	e8df f002 	tbb	[pc, r2]
10005e26:	4f08      	.short	0x4f08
10005e28:	64644c64 	.word	0x64644c64
10005e2c:	4f64      	.short	0x4f64
    GPIO_PRT_Type *txport = obj->pin_tx != NC ? CYHAL_GET_PORTADDR(obj->pin_tx) : NULL;
10005e2e:	2600      	movs	r6, #0
10005e30:	e7e2      	b.n	10005df8 <_cyhal_uart_pm_callback_instance+0x24>
    GPIO_PRT_Type *rtsport = ((obj->pin_rts != NC) && obj->rts_enabled) ? CYHAL_GET_PORTADDR(obj->pin_rts) : NULL;
10005e32:	2400      	movs	r4, #0
10005e34:	e7ee      	b.n	10005e14 <_cyhal_uart_pm_callback_instance+0x40>
            if ((0UL == (CY_SCB_UART_TRANSMIT_ACTIVE & Cy_SCB_UART_GetTransmitStatus(obj->base, &(obj->context)))) &&
10005e36:	f105 0a18 	add.w	sl, r5, #24
10005e3a:	6828      	ldr	r0, [r5, #0]
10005e3c:	4651      	mov	r1, sl
10005e3e:	f002 f99c 	bl	1000817a <Cy_SCB_UART_GetTransmitStatus>
10005e42:	07c2      	lsls	r2, r0, #31
10005e44:	d454      	bmi.n	10005ef0 <_cyhal_uart_pm_callback_instance+0x11c>
                (0UL == (CY_SCB_UART_RECEIVE_ACTIVE  & Cy_SCB_UART_GetReceiveStatus (obj->base, &(obj->context)))))
10005e46:	6828      	ldr	r0, [r5, #0]
10005e48:	4651      	mov	r1, sl
10005e4a:	f002 f994 	bl	10008176 <Cy_SCB_UART_GetReceiveStatus>
            if ((0UL == (CY_SCB_UART_TRANSMIT_ACTIVE & Cy_SCB_UART_GetTransmitStatus(obj->base, &(obj->context)))) &&
10005e4e:	07c3      	lsls	r3, r0, #31
10005e50:	d44e      	bmi.n	10005ef0 <_cyhal_uart_pm_callback_instance+0x11c>
                if (Cy_SCB_UART_IsTxComplete(obj->base))
10005e52:	682b      	ldr	r3, [r5, #0]
* The number or data elements in the TX FIFO.
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_SCB_GetNumInTxFifo(CySCB_Type const *base)
{
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
10005e54:	f8d3 1208 	ldr.w	r1, [r3, #520]	; 0x208
* 1 - TX shift register valid; 0 - TX shift register not valid.
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_SCB_GetTxSrValid(CySCB_Type const *base)
{
    return _FLD2VAL(SCB_TX_FIFO_STATUS_SR_VALID, SCB_TX_FIFO_STATUS(base));
10005e58:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
10005e5c:	f3c1 0108 	ubfx	r1, r1, #0, #9
    return _FLD2VAL(SCB_TX_FIFO_STATUS_SR_VALID, SCB_TX_FIFO_STATUS(base));
10005e60:	f3c2 32c0 	ubfx	r2, r2, #15, #1
10005e64:	42ca      	cmn	r2, r1
10005e66:	d143      	bne.n	10005ef0 <_cyhal_uart_pm_callback_instance+0x11c>
    return _FLD2VAL(SCB_RX_FIFO_STATUS_USED, SCB_RX_FIFO_STATUS(base));
10005e68:	f8d3 2308 	ldr.w	r2, [r3, #776]	; 0x308
10005e6c:	f3c2 0908 	ubfx	r9, r2, #0, #9
                    if (0UL == Cy_SCB_UART_GetNumInRxFifo(obj->base))
10005e70:	f1b9 0f00 	cmp.w	r9, #0
10005e74:	d13c      	bne.n	10005ef0 <_cyhal_uart_pm_callback_instance+0x11c>
                        if (NULL != txport)
10005e76:	b176      	cbz	r6, 10005e96 <_cyhal_uart_pm_callback_instance+0xc2>
                            obj->saved_tx_hsiom = Cy_GPIO_GetHSIOM(txport, txpin);
10005e78:	4641      	mov	r1, r8
10005e7a:	4630      	mov	r0, r6
10005e7c:	f7fe fb36 	bl	100044ec <Cy_GPIO_GetHSIOM>
                            Cy_GPIO_Set(txport, txpin);
10005e80:	4641      	mov	r1, r8
                            obj->saved_tx_hsiom = Cy_GPIO_GetHSIOM(txport, txpin);
10005e82:	f885 0098 	strb.w	r0, [r5, #152]	; 0x98
                            Cy_GPIO_Set(txport, txpin);
10005e86:	4630      	mov	r0, r6
10005e88:	f002 fb36 	bl	100084f8 <Cy_GPIO_Set>
                            Cy_GPIO_SetHSIOM(txport, txpin, HSIOM_SEL_GPIO);
10005e8c:	464a      	mov	r2, r9
10005e8e:	4641      	mov	r1, r8
10005e90:	4630      	mov	r0, r6
10005e92:	f7fe fac5 	bl	10004420 <Cy_GPIO_SetHSIOM>
                        if (NULL != rtsport)
10005e96:	b174      	cbz	r4, 10005eb6 <_cyhal_uart_pm_callback_instance+0xe2>
                            obj->saved_rts_hsiom = Cy_GPIO_GetHSIOM(rtsport, rtspin);
10005e98:	4639      	mov	r1, r7
10005e9a:	4620      	mov	r0, r4
10005e9c:	f7fe fb26 	bl	100044ec <Cy_GPIO_GetHSIOM>
                            Cy_GPIO_Set(rtsport, rtspin);
10005ea0:	4639      	mov	r1, r7
                            obj->saved_rts_hsiom = Cy_GPIO_GetHSIOM(rtsport, rtspin);
10005ea2:	f885 0099 	strb.w	r0, [r5, #153]	; 0x99
                            Cy_GPIO_Set(rtsport, rtspin);
10005ea6:	4620      	mov	r0, r4
10005ea8:	f002 fb26 	bl	100084f8 <Cy_GPIO_Set>
                            Cy_GPIO_SetHSIOM(rtsport, rtspin, HSIOM_SEL_GPIO);
10005eac:	2200      	movs	r2, #0
10005eae:	4639      	mov	r1, r7
10005eb0:	4620      	mov	r0, r4
10005eb2:	f7fe fab5 	bl	10004420 <Cy_GPIO_SetHSIOM>
                        Cy_SCB_UART_Disable(obj->base, &(obj->context));
10005eb6:	6828      	ldr	r0, [r5, #0]
10005eb8:	4651      	mov	r1, sl
10005eba:	f002 f947 	bl	1000814c <Cy_SCB_UART_Disable>
    bool allow = false;
10005ebe:	2001      	movs	r0, #1
}
10005ec0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            Cy_SCB_UART_Enable(obj->base);
10005ec4:	682a      	ldr	r2, [r5, #0]
10005ec6:	6813      	ldr	r3, [r2, #0]
10005ec8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
10005ecc:	6013      	str	r3, [r2, #0]
            if (NULL != txport)
10005ece:	b12e      	cbz	r6, 10005edc <_cyhal_uart_pm_callback_instance+0x108>
                Cy_GPIO_SetHSIOM(txport, txpin, obj->saved_tx_hsiom);
10005ed0:	f895 2098 	ldrb.w	r2, [r5, #152]	; 0x98
10005ed4:	4641      	mov	r1, r8
10005ed6:	4630      	mov	r0, r6
10005ed8:	f7fe faa2 	bl	10004420 <Cy_GPIO_SetHSIOM>
            if (NULL != rtsport)
10005edc:	2c00      	cmp	r4, #0
10005ede:	d0ee      	beq.n	10005ebe <_cyhal_uart_pm_callback_instance+0xea>
                Cy_GPIO_SetHSIOM(rtsport, rtspin, obj->saved_rts_hsiom);
10005ee0:	f895 2099 	ldrb.w	r2, [r5, #153]	; 0x99
10005ee4:	4639      	mov	r1, r7
10005ee6:	4620      	mov	r0, r4
10005ee8:	f7fe fa9a 	bl	10004420 <Cy_GPIO_SetHSIOM>
10005eec:	e7e7      	b.n	10005ebe <_cyhal_uart_pm_callback_instance+0xea>
10005eee:	be01      	bkpt	0x0001
    bool allow = false;
10005ef0:	2000      	movs	r0, #0
10005ef2:	e7e5      	b.n	10005ec0 <_cyhal_uart_pm_callback_instance+0xec>
10005ef4:	08003550 	.word	0x08003550

10005ef8 <cyhal_uart_set_baud>:
        }
    }
}

cy_rslt_t cyhal_uart_set_baud(cyhal_uart_t *obj, uint32_t baudrate, uint32_t *actualbaud)
{
10005ef8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cy_rslt_t status;

    if (obj->is_clock_owned)
10005efc:	7b43      	ldrb	r3, [r0, #13]
{
10005efe:	4606      	mov	r6, r0
10005f00:	460d      	mov	r5, r1
10005f02:	4691      	mov	r9, r2
    if (obj->is_clock_owned)
10005f04:	2b00      	cmp	r3, #0
10005f06:	d076      	beq.n	10005ff6 <cyhal_uart_set_baud+0xfe>
    {
        uint8_t oversample_value;
        uint32_t calculated_baud;
        uint32_t divider;

        Cy_SCB_UART_Disable(obj->base, NULL);
10005f08:	4607      	mov	r7, r0
10005f0a:	2100      	movs	r1, #0
10005f0c:	f857 0b10 	ldr.w	r0, [r7], #16
10005f10:	f002 f91c 	bl	1000814c <Cy_SCB_UART_Disable>
        status = cyhal_clock_set_enabled(&(obj->clock), false, false);
10005f14:	2200      	movs	r2, #0
10005f16:	4611      	mov	r1, r2
10005f18:	4638      	mov	r0, r7
10005f1a:	f002 fecc 	bl	10008cb6 <cyhal_clock_set_enabled>
        if(status != CY_RSLT_SUCCESS)
10005f1e:	4680      	mov	r8, r0
10005f20:	b140      	cbz	r0, 10005f34 <cyhal_uart_set_baud+0x3c>
                    _BOOL2FLD(SCB_CTRL_BYTE_MODE, (obj->config.dataWidth <= CY_SCB_BYTE_WIDTH)) |
                    _VAL2FLD(SCB_CTRL_OVS, oversample_value - 1)                                |
                    _VAL2FLD(SCB_CTRL_MODE, CY_SCB_CTRL_MODE_UART);
        #endif

        Cy_SCB_UART_Enable(obj->base);
10005f22:	6832      	ldr	r2, [r6, #0]
10005f24:	6813      	ldr	r3, [r2, #0]
10005f26:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
10005f2a:	6013      	str	r3, [r2, #0]
        /* Not able to make changes in user-provided clock */
        status = CYHAL_UART_RSLT_CLOCK_ERROR;
    }

    return status;
}
10005f2c:	4640      	mov	r0, r8
10005f2e:	b003      	add	sp, #12
10005f30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(status != CY_RSLT_SUCCESS)
10005f34:	f04f 0808 	mov.w	r8, #8
10005f38:	ea4f 0ac5 	mov.w	sl, r5, lsl #3
    uint8_t best_oversample = _CYHAL_UART_OVERSAMPLE_MIN;
10005f3c:	4644      	mov	r4, r8
    uint8_t best_difference = 0xFF;
10005f3e:	f04f 0bff 	mov.w	fp, #255	; 0xff
    return Cy_SysClk_ClkPeriGetFrequency();
10005f42:	f002 fb22 	bl	1000858a <Cy_SysClk_ClkPeriGetFrequency>
    return ((_cyhal_utils_get_peripheral_clock_frequency(clocked_item) * (1 << frac_bits)) + (frequency / 2)) / frequency;
10005f46:	eb00 035a 	add.w	r3, r0, sl, lsr #1
10005f4a:	fbb3 f3fa 	udiv	r3, r3, sl
10005f4e:	9301      	str	r3, [sp, #4]
    return Cy_SysClk_ClkPeriGetFrequency();
10005f50:	f002 fb1b 	bl	1000858a <Cy_SysClk_ClkPeriGetFrequency>
    return _cyhal_utils_get_peripheral_clock_frequency(resource) / (divider * oversample);
10005f54:	9b01      	ldr	r3, [sp, #4]
10005f56:	fb03 f308 	mul.w	r3, r3, r8
10005f5a:	fbb0 f3f3 	udiv	r3, r0, r3
        : ((desired_baud * 100) - (actual_baud * 100)) / desired_baud;
10005f5e:	429d      	cmp	r5, r3
        ? ((actual_baud * 100) - (desired_baud * 100)) / desired_baud
10005f60:	bf34      	ite	cc
10005f62:	1b5b      	subcc	r3, r3, r5
        : ((desired_baud * 100) - (actual_baud * 100)) / desired_baud;
10005f64:	1aeb      	subcs	r3, r5, r3
10005f66:	2264      	movs	r2, #100	; 0x64
10005f68:	4353      	muls	r3, r2
10005f6a:	fbb3 f3f5 	udiv	r3, r3, r5
        uint8_t difference = (uint8_t)_cyhal_uart_baud_perdif(baudrate, _cyhal_uart_actual_baud(resource, divider, i));
10005f6e:	b2db      	uxtb	r3, r3
        if (difference < best_difference)
10005f70:	459b      	cmp	fp, r3
10005f72:	bf88      	it	hi
10005f74:	fa5f f488 	uxtbhi.w	r4, r8
    for (uint8_t i = _CYHAL_UART_OVERSAMPLE_MIN; i < _CYHAL_UART_OVERSAMPLE_MAX + 1; i++)
10005f78:	f108 0801 	add.w	r8, r8, #1
        if (difference < best_difference)
10005f7c:	bf88      	it	hi
10005f7e:	469b      	movhi	fp, r3
    for (uint8_t i = _CYHAL_UART_OVERSAMPLE_MIN; i < _CYHAL_UART_OVERSAMPLE_MAX + 1; i++)
10005f80:	f1b8 0f11 	cmp.w	r8, #17
10005f84:	44aa      	add	sl, r5
10005f86:	d1dc      	bne.n	10005f42 <cyhal_uart_set_baud+0x4a>
        obj->config.oversample = oversample_value;
10005f88:	65b4      	str	r4, [r6, #88]	; 0x58
10005f8a:	f002 fafe 	bl	1000858a <Cy_SysClk_ClkPeriGetFrequency>
        divider = _cyhal_utils_divider_value(&(obj->resource), baudrate * oversample_value, 0);
10005f8e:	4365      	muls	r5, r4
    return ((_cyhal_utils_get_peripheral_clock_frequency(clocked_item) * (1 << frac_bits)) + (frequency / 2)) / frequency;
10005f90:	eb00 0055 	add.w	r0, r0, r5, lsr #1
10005f94:	fbb0 f5f5 	udiv	r5, r0, r5
        status = cyhal_clock_set_divider(&(obj->clock), divider);
10005f98:	4638      	mov	r0, r7
10005f9a:	4629      	mov	r1, r5
10005f9c:	f002 fe99 	bl	10008cd2 <cyhal_clock_set_divider>
        if(status != CY_RSLT_SUCCESS)
10005fa0:	4680      	mov	r8, r0
10005fa2:	b128      	cbz	r0, 10005fb0 <cyhal_uart_set_baud+0xb8>
            cyhal_clock_set_enabled(&(obj->clock), true, false);
10005fa4:	2200      	movs	r2, #0
10005fa6:	2101      	movs	r1, #1
10005fa8:	4638      	mov	r0, r7
10005faa:	f002 fe84 	bl	10008cb6 <cyhal_clock_set_enabled>
            Cy_SCB_UART_Enable(obj->base);
10005fae:	e7b8      	b.n	10005f22 <cyhal_uart_set_baud+0x2a>
    return Cy_SysClk_ClkPeriGetFrequency();
10005fb0:	f002 faeb 	bl	1000858a <Cy_SysClk_ClkPeriGetFrequency>
        if (actualbaud != NULL)
10005fb4:	f1b9 0f00 	cmp.w	r9, #0
10005fb8:	d004      	beq.n	10005fc4 <cyhal_uart_set_baud+0xcc>
    return _cyhal_utils_get_peripheral_clock_frequency(resource) / (divider * oversample);
10005fba:	4365      	muls	r5, r4
10005fbc:	fbb0 f0f5 	udiv	r0, r0, r5
            *actualbaud = calculated_baud;
10005fc0:	f8c9 0000 	str.w	r0, [r9]
        status = cyhal_clock_set_enabled(&(obj->clock), true, false);
10005fc4:	2200      	movs	r2, #0
10005fc6:	2101      	movs	r1, #1
10005fc8:	4638      	mov	r0, r7
10005fca:	f002 fe74 	bl	10008cb6 <cyhal_clock_set_enabled>
        SCB_CTRL(obj->base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, obj->config.acceptAddrInFifo)     |
10005fce:	f896 1070 	ldrb.w	r1, [r6, #112]	; 0x70
10005fd2:	6832      	ldr	r2, [r6, #0]
                    _VAL2FLD(SCB_CTRL_OVS, oversample_value - 1)                                |
10005fd4:	1e63      	subs	r3, r4, #1
10005fd6:	f003 030f 	and.w	r3, r3, #15
                    _BOOL2FLD(SCB_CTRL_BYTE_MODE, (obj->config.dataWidth <= CY_SCB_BYTE_WIDTH)) |
10005fda:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
10005fde:	6df1      	ldr	r1, [r6, #92]	; 0x5c
10005fe0:	2908      	cmp	r1, #8
10005fe2:	bf8c      	ite	hi
10005fe4:	2100      	movhi	r1, #0
10005fe6:	2101      	movls	r1, #1
10005fe8:	ea43 23c1 	orr.w	r3, r3, r1, lsl #11
                    _VAL2FLD(SCB_CTRL_OVS, oversample_value - 1)                                |
10005fec:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        status = cyhal_clock_set_enabled(&(obj->clock), true, false);
10005ff0:	4680      	mov	r8, r0
        SCB_CTRL(obj->base) = _BOOL2FLD(SCB_CTRL_ADDR_ACCEPT, obj->config.acceptAddrInFifo)     |
10005ff2:	6013      	str	r3, [r2, #0]
10005ff4:	e795      	b.n	10005f22 <cyhal_uart_set_baud+0x2a>
        status = CYHAL_UART_RSLT_CLOCK_ERROR;
10005ff6:	f8df 8004 	ldr.w	r8, [pc, #4]	; 10005ffc <cyhal_uart_set_baud+0x104>
10005ffa:	e797      	b.n	10005f2c <cyhal_uart_set_baud+0x34>
10005ffc:	04021e06 	.word	0x04021e06

10006000 <cyhal_uart_getc>:
    Cy_SCB_UART_Enable(obj->base);
    return CY_RSLT_SUCCESS;
}

cy_rslt_t cyhal_uart_getc(cyhal_uart_t *obj, uint8_t *value, uint32_t timeout)
{
10006000:	b570      	push	{r4, r5, r6, lr}
10006002:	4605      	mov	r5, r0
10006004:	460e      	mov	r6, r1
10006006:	4614      	mov	r4, r2
    if (_cyhal_scb_pm_transition_pending())
10006008:	f000 f912 	bl	10006230 <_cyhal_scb_pm_transition_pending>
1000600c:	b9b8      	cbnz	r0, 1000603e <cyhal_uart_getc+0x3e>
        return CYHAL_SYSPM_RSLT_ERR_PM_PENDING;

    uint32_t read_value = Cy_SCB_UART_Get(obj->base);
1000600e:	682a      	ldr	r2, [r5, #0]
    return (SCB_RX_FIFO_RD(base));
10006010:	f8d2 3340 	ldr.w	r3, [r2, #832]	; 0x340
    uint32_t timeoutTicks = timeout;
    while (read_value == CY_SCB_UART_RX_NO_DATA)
10006014:	1c59      	adds	r1, r3, #1
10006016:	d10b      	bne.n	10006030 <cyhal_uart_getc+0x30>
    {
        if(timeout != 0UL)
10006018:	2c00      	cmp	r4, #0
1000601a:	d0f9      	beq.n	10006010 <cyhal_uart_getc+0x10>
        {
            if(timeoutTicks > 0UL)
            {
                Cy_SysLib_Delay(1);
1000601c:	2001      	movs	r0, #1
1000601e:	f7ff fcc9 	bl	100059b4 <Cy_SysLib_Delay>
            else
            {
                return CY_RSLT_ERR_CSP_UART_GETC_TIMEOUT;
            }
        }
        read_value = Cy_SCB_UART_Get(obj->base);
10006022:	682b      	ldr	r3, [r5, #0]
10006024:	f8d3 3340 	ldr.w	r3, [r3, #832]	; 0x340
    while (read_value == CY_SCB_UART_RX_NO_DATA)
10006028:	1c58      	adds	r0, r3, #1
                timeoutTicks--;
1000602a:	f104 34ff 	add.w	r4, r4, #4294967295
    while (read_value == CY_SCB_UART_RX_NO_DATA)
1000602e:	d002      	beq.n	10006036 <cyhal_uart_getc+0x36>
    }
    *value = (uint8_t)read_value;
10006030:	7033      	strb	r3, [r6, #0]
    return CY_RSLT_SUCCESS;
10006032:	2000      	movs	r0, #0
}
10006034:	bd70      	pop	{r4, r5, r6, pc}
            if(timeoutTicks > 0UL)
10006036:	2c00      	cmp	r4, #0
10006038:	d1f0      	bne.n	1000601c <cyhal_uart_getc+0x1c>
                return CY_RSLT_ERR_CSP_UART_GETC_TIMEOUT;
1000603a:	4802      	ldr	r0, [pc, #8]	; (10006044 <cyhal_uart_getc+0x44>)
1000603c:	e7fa      	b.n	10006034 <cyhal_uart_getc+0x34>
        return CYHAL_SYSPM_RSLT_ERR_PM_PENDING;
1000603e:	4802      	ldr	r0, [pc, #8]	; (10006048 <cyhal_uart_getc+0x48>)
10006040:	e7f8      	b.n	10006034 <cyhal_uart_getc+0x34>
10006042:	bf00      	nop
10006044:	04021e02 	.word	0x04021e02
10006048:	04021903 	.word	0x04021903

1000604c <cyhal_uart_putc>:

cy_rslt_t cyhal_uart_putc(cyhal_uart_t *obj, uint32_t value)
{
1000604c:	b538      	push	{r3, r4, r5, lr}
1000604e:	4604      	mov	r4, r0
10006050:	460d      	mov	r5, r1
    if (_cyhal_scb_pm_transition_pending())
10006052:	f000 f8ed 	bl	10006230 <_cyhal_scb_pm_transition_pending>
10006056:	b938      	cbnz	r0, 10006068 <cyhal_uart_putc+0x1c>
* The number of data elements placed in the TX FIFO: 0 or 1.
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_SCB_UART_Put(CySCB_Type *base, uint32_t data)
{
    return Cy_SCB_Write(base, data);
10006058:	6820      	ldr	r0, [r4, #0]
1000605a:	4629      	mov	r1, r5
1000605c:	f002 f9f9 	bl	10008452 <Cy_SCB_Write>
        return CYHAL_SYSPM_RSLT_ERR_PM_PENDING;

    uint32_t count = 0;
    while (count == 0)
10006060:	2800      	cmp	r0, #0
10006062:	d0f9      	beq.n	10006058 <cyhal_uart_putc+0xc>
    {
        count = Cy_SCB_UART_Put(obj->base, value);
    }

    return CY_RSLT_SUCCESS;
10006064:	2000      	movs	r0, #0
}
10006066:	bd38      	pop	{r3, r4, r5, pc}
        return CYHAL_SYSPM_RSLT_ERR_PM_PENDING;
10006068:	4800      	ldr	r0, [pc, #0]	; (1000606c <cyhal_uart_putc+0x20>)
1000606a:	e7fc      	b.n	10006066 <cyhal_uart_putc+0x1a>
1000606c:	04021903 	.word	0x04021903

10006070 <cyhal_uart_enable_flow_control>:

    return CY_RSLT_SUCCESS;
}

cy_rslt_t cyhal_uart_enable_flow_control(cyhal_uart_t *obj, bool enable_cts, bool enable_rts)
{
10006070:	b538      	push	{r3, r4, r5, lr}
10006072:	4604      	mov	r4, r0
    cy_rslt_t result = CY_RSLT_SUCCESS;

    if (obj->pin_cts != NC)
10006074:	7a40      	ldrb	r0, [r0, #9]
10006076:	28ff      	cmp	r0, #255	; 0xff
{
10006078:	4615      	mov	r5, r2
    if (obj->pin_cts != NC)
1000607a:	d015      	beq.n	100060a8 <cyhal_uart_enable_flow_control+0x38>
    {
        if (enable_cts && (false == obj->cts_enabled))
1000607c:	b369      	cbz	r1, 100060da <cyhal_uart_enable_flow_control+0x6a>
1000607e:	7ae3      	ldrb	r3, [r4, #11]
10006080:	b993      	cbnz	r3, 100060a8 <cyhal_uart_enable_flow_control+0x38>
        {
            const cyhal_resource_pin_mapping_t *cts_map = _CYHAL_SCB_FIND_MAP_BLOCK(obj->pin_cts, cyhal_pin_map_scb_uart_cts, &obj->resource);
10006082:	4927      	ldr	r1, [pc, #156]	; (10006120 <cyhal_uart_enable_flow_control+0xb0>)
10006084:	1d23      	adds	r3, r4, #4
10006086:	2212      	movs	r2, #18
10006088:	f002 fbc0 	bl	1000880c <_cyhal_scb_find_map>
            if (false == obj->dc_configured)
1000608c:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
            {
                result = _cyhal_utils_reserve_and_connect(cts_map, CYHAL_PIN_MAP_DRIVE_MODE_SCB_UART_CTS);
10006090:	2108      	movs	r1, #8
            if (false == obj->dc_configured)
10006092:	b9fb      	cbnz	r3, 100060d4 <cyhal_uart_enable_flow_control+0x64>
                result = _cyhal_utils_reserve_and_connect(cts_map, CYHAL_PIN_MAP_DRIVE_MODE_SCB_UART_CTS);
10006094:	f002 fe8f 	bl	10008db6 <_cyhal_utils_reserve_and_connect>
            }
            else
            {
                result = cyhal_connect_pin(cts_map, CYHAL_PIN_MAP_DRIVE_MODE_SCB_UART_CTS);
            }
            if (CY_RSLT_SUCCESS == result)
10006098:	bb78      	cbnz	r0, 100060fa <cyhal_uart_enable_flow_control+0x8a>
            {
                Cy_SCB_UART_EnableCts(obj->base);
1000609a:	6822      	ldr	r2, [r4, #0]
    SCB_UART_FLOW_CTRL(base) |= SCB_UART_FLOW_CTRL_CTS_ENABLED_Msk;
1000609c:	6d13      	ldr	r3, [r2, #80]	; 0x50
1000609e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
100060a2:	6513      	str	r3, [r2, #80]	; 0x50
                obj->cts_enabled = true;
100060a4:	2301      	movs	r3, #1
                result = cyhal_disconnect_pin(obj->pin_cts);
            }
            if (CY_RSLT_SUCCESS == result)
            {
                Cy_SCB_UART_DisableCts(obj->base);
                obj->cts_enabled = false;
100060a6:	72e3      	strb	r3, [r4, #11]
            }
        }
    }

    if ((CY_RSLT_SUCCESS == result) && (obj->pin_rts != NC))
100060a8:	7aa0      	ldrb	r0, [r4, #10]
100060aa:	28ff      	cmp	r0, #255	; 0xff
100060ac:	d030      	beq.n	10006110 <cyhal_uart_enable_flow_control+0xa0>
    {
        if (enable_rts && (false == obj->rts_enabled))
100060ae:	b345      	cbz	r5, 10006102 <cyhal_uart_enable_flow_control+0x92>
100060b0:	7b23      	ldrb	r3, [r4, #12]
100060b2:	bb6b      	cbnz	r3, 10006110 <cyhal_uart_enable_flow_control+0xa0>
        {
            const cyhal_resource_pin_mapping_t *rts_map = _CYHAL_SCB_FIND_MAP_BLOCK(obj->pin_rts, cyhal_pin_map_scb_uart_rts, &obj->resource);
100060b4:	491b      	ldr	r1, [pc, #108]	; (10006124 <cyhal_uart_enable_flow_control+0xb4>)
100060b6:	1d23      	adds	r3, r4, #4
100060b8:	2212      	movs	r2, #18
100060ba:	f002 fba7 	bl	1000880c <_cyhal_scb_find_map>
            if (false == obj->dc_configured)
100060be:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
            {
                result = _cyhal_utils_reserve_and_connect(rts_map, CYHAL_PIN_MAP_DRIVE_MODE_SCB_UART_RTS);
100060c2:	2106      	movs	r1, #6
            if (false == obj->dc_configured)
100060c4:	b9d3      	cbnz	r3, 100060fc <cyhal_uart_enable_flow_control+0x8c>
                result = _cyhal_utils_reserve_and_connect(rts_map, CYHAL_PIN_MAP_DRIVE_MODE_SCB_UART_RTS);
100060c6:	f002 fe76 	bl	10008db6 <_cyhal_utils_reserve_and_connect>
            }
            else
            {
                result = cyhal_connect_pin(rts_map, CYHAL_PIN_MAP_DRIVE_MODE_SCB_UART_RTS);
            }
            obj->rts_enabled = (CY_RSLT_SUCCESS == result);
100060ca:	fab0 f380 	clz	r3, r0
100060ce:	095b      	lsrs	r3, r3, #5
100060d0:	7323      	strb	r3, [r4, #12]
        {
100060d2:	e012      	b.n	100060fa <cyhal_uart_enable_flow_control+0x8a>
                result = cyhal_connect_pin(cts_map, CYHAL_PIN_MAP_DRIVE_MODE_SCB_UART_CTS);
100060d4:	f000 ffca 	bl	1000706c <cyhal_connect_pin>
100060d8:	e7de      	b.n	10006098 <cyhal_uart_enable_flow_control+0x28>
            if (false == obj->dc_configured)
100060da:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
100060de:	b943      	cbnz	r3, 100060f2 <cyhal_uart_enable_flow_control+0x82>
                _cyhal_utils_disconnect_and_free(obj->pin_cts);
100060e0:	f002 fe88 	bl	10008df4 <_cyhal_utils_disconnect_and_free>
                Cy_SCB_UART_DisableCts(obj->base);
100060e4:	6822      	ldr	r2, [r4, #0]
    SCB_UART_FLOW_CTRL(base) &= (uint32_t) ~SCB_UART_FLOW_CTRL_CTS_ENABLED_Msk;
100060e6:	6d13      	ldr	r3, [r2, #80]	; 0x50
100060e8:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
100060ec:	6513      	str	r3, [r2, #80]	; 0x50
                obj->cts_enabled = false;
100060ee:	2300      	movs	r3, #0
100060f0:	e7d9      	b.n	100060a6 <cyhal_uart_enable_flow_control+0x36>
                result = cyhal_disconnect_pin(obj->pin_cts);
100060f2:	f000 ffe3 	bl	100070bc <cyhal_disconnect_pin>
            if (CY_RSLT_SUCCESS == result)
100060f6:	2800      	cmp	r0, #0
100060f8:	d0f4      	beq.n	100060e4 <cyhal_uart_enable_flow_control+0x74>
            }
        }
    }

    return result;
}
100060fa:	bd38      	pop	{r3, r4, r5, pc}
                result = cyhal_connect_pin(rts_map, CYHAL_PIN_MAP_DRIVE_MODE_SCB_UART_RTS);
100060fc:	f000 ffb6 	bl	1000706c <cyhal_connect_pin>
10006100:	e7e3      	b.n	100060ca <cyhal_uart_enable_flow_control+0x5a>
            if (false == obj->dc_configured)
10006102:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
10006106:	b92b      	cbnz	r3, 10006114 <cyhal_uart_enable_flow_control+0xa4>
                _cyhal_utils_disconnect_and_free(obj->pin_rts);
10006108:	f002 fe74 	bl	10008df4 <_cyhal_utils_disconnect_and_free>
                obj->rts_enabled = false;
1000610c:	2300      	movs	r3, #0
1000610e:	7323      	strb	r3, [r4, #12]
{
10006110:	2000      	movs	r0, #0
    return result;
10006112:	e7f2      	b.n	100060fa <cyhal_uart_enable_flow_control+0x8a>
                result = cyhal_disconnect_pin(obj->pin_rts);
10006114:	f000 ffd2 	bl	100070bc <cyhal_disconnect_pin>
            if (CY_RSLT_SUCCESS == result)
10006118:	2800      	cmp	r0, #0
1000611a:	d1ee      	bne.n	100060fa <cyhal_uart_enable_flow_control+0x8a>
1000611c:	e7f6      	b.n	1000610c <cyhal_uart_enable_flow_control+0x9c>
1000611e:	bf00      	nop
10006120:	10009a69 	.word	0x10009a69
10006124:	10009a21 	.word	0x10009a21

10006128 <_cyhal_scb_pm_callback_index>:
{
    return __cyhal_scb_pm_transition_pending_value;
}

static bool _cyhal_scb_pm_callback_index(uint8_t index, cyhal_syspm_callback_state_t state, cy_en_syspm_callback_mode_t pdl_mode)
{
10006128:	b410      	push	{r4}
1000612a:	4603      	mov	r3, r0
    void *obj = _cyhal_scb_config_structs[index];
1000612c:	4806      	ldr	r0, [pc, #24]	; (10006148 <_cyhal_scb_pm_callback_index+0x20>)
1000612e:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
    cyhal_scb_instance_pm_callback callback = _cyhal_scb_config_pm_callback[index];
    return ((NULL != obj) && (callback != NULL)) ? callback(obj, state, pdl_mode) : true;
10006132:	b128      	cbz	r0, 10006140 <_cyhal_scb_pm_callback_index+0x18>
    cyhal_scb_instance_pm_callback callback = _cyhal_scb_config_pm_callback[index];
10006134:	4c05      	ldr	r4, [pc, #20]	; (1000614c <_cyhal_scb_pm_callback_index+0x24>)
10006136:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    return ((NULL != obj) && (callback != NULL)) ? callback(obj, state, pdl_mode) : true;
1000613a:	b10b      	cbz	r3, 10006140 <_cyhal_scb_pm_callback_index+0x18>
}
1000613c:	bc10      	pop	{r4}
    return ((NULL != obj) && (callback != NULL)) ? callback(obj, state, pdl_mode) : true;
1000613e:	4718      	bx	r3
}
10006140:	2001      	movs	r0, #1
10006142:	bc10      	pop	{r4}
10006144:	4770      	bx	lr
10006146:	bf00      	nop
10006148:	0800372c 	.word	0x0800372c
1000614c:	080036f8 	.word	0x080036f8

10006150 <_cyhal_scb_pm_callback_common>:

static bool _cyhal_scb_pm_callback_common(cyhal_syspm_callback_state_t state, cyhal_syspm_callback_mode_t mode, void* callback_arg)
{
10006150:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
10006154:	4606      	mov	r6, r0
    CY_UNUSED_PARAMETER(callback_arg);
    bool allow = true;
    cy_en_syspm_callback_mode_t pdl_mode = _cyhal_utils_convert_haltopdl_pm_mode(mode);
10006156:	4608      	mov	r0, r1
{
10006158:	460c      	mov	r4, r1
    cy_en_syspm_callback_mode_t pdl_mode = _cyhal_utils_convert_haltopdl_pm_mode(mode);
1000615a:	f002 fe60 	bl	10008e1e <_cyhal_utils_convert_haltopdl_pm_mode>
1000615e:	2500      	movs	r5, #0
10006160:	4607      	mov	r7, r0
    for (uint8_t instance_idx = 0; instance_idx < _SCB_ARRAY_SIZE; instance_idx++)
10006162:	fa5f f885 	uxtb.w	r8, r5
    {
        allow = _cyhal_scb_pm_callback_index(instance_idx, state, pdl_mode);
10006166:	463a      	mov	r2, r7
10006168:	4631      	mov	r1, r6
1000616a:	4640      	mov	r0, r8
1000616c:	f7ff ffdc 	bl	10006128 <_cyhal_scb_pm_callback_index>
10006170:	4603      	mov	r3, r0

        if (!allow && mode == CYHAL_SYSPM_CHECK_READY)
10006172:	b968      	cbnz	r0, 10006190 <_cyhal_scb_pm_callback_common+0x40>
10006174:	2c01      	cmp	r4, #1
10006176:	d10b      	bne.n	10006190 <_cyhal_scb_pm_callback_common+0x40>
10006178:	4604      	mov	r4, r0
1000617a:	e004      	b.n	10006186 <_cyhal_scb_pm_callback_common+0x36>
        {
            for (uint8_t revert_idx = 0; revert_idx < instance_idx; revert_idx++)
            {
                _cyhal_scb_pm_callback_index(revert_idx, state, CY_SYSPM_CHECK_FAIL);
1000617c:	2202      	movs	r2, #2
1000617e:	4631      	mov	r1, r6
10006180:	f7ff ffd2 	bl	10006128 <_cyhal_scb_pm_callback_index>
            for (uint8_t revert_idx = 0; revert_idx < instance_idx; revert_idx++)
10006184:	3401      	adds	r4, #1
10006186:	b2e0      	uxtb	r0, r4
10006188:	4580      	cmp	r8, r0
1000618a:	d8f7      	bhi.n	1000617c <_cyhal_scb_pm_callback_common+0x2c>
        allow = _cyhal_scb_pm_callback_index(instance_idx, state, pdl_mode);
1000618c:	2000      	movs	r0, #0
1000618e:	e009      	b.n	100061a4 <_cyhal_scb_pm_callback_common+0x54>
    for (uint8_t instance_idx = 0; instance_idx < _SCB_ARRAY_SIZE; instance_idx++)
10006190:	3501      	adds	r5, #1
10006192:	2d0d      	cmp	r5, #13
10006194:	d1e5      	bne.n	10006162 <_cyhal_scb_pm_callback_common+0x12>
            }
            break;
        }
    }

    if (mode == CYHAL_SYSPM_CHECK_FAIL || mode == CYHAL_SYSPM_AFTER_TRANSITION)
10006196:	2c02      	cmp	r4, #2
10006198:	d001      	beq.n	1000619e <_cyhal_scb_pm_callback_common+0x4e>
1000619a:	2c08      	cmp	r4, #8
1000619c:	d104      	bne.n	100061a8 <_cyhal_scb_pm_callback_common+0x58>
    {
        __cyhal_scb_pm_transition_pending_value = false;
1000619e:	4b06      	ldr	r3, [pc, #24]	; (100061b8 <_cyhal_scb_pm_callback_common+0x68>)
100061a0:	2200      	movs	r2, #0
100061a2:	701a      	strb	r2, [r3, #0]
    else if (mode == CYHAL_SYSPM_CHECK_READY && allow)
    {
        __cyhal_scb_pm_transition_pending_value = true;
    }
    return allow;
}
100061a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if (mode == CYHAL_SYSPM_CHECK_READY && allow)
100061a8:	2c01      	cmp	r4, #1
100061aa:	d1fb      	bne.n	100061a4 <_cyhal_scb_pm_callback_common+0x54>
100061ac:	2b00      	cmp	r3, #0
100061ae:	d0ed      	beq.n	1000618c <_cyhal_scb_pm_callback_common+0x3c>
        __cyhal_scb_pm_transition_pending_value = true;
100061b0:	4b01      	ldr	r3, [pc, #4]	; (100061b8 <_cyhal_scb_pm_callback_common+0x68>)
100061b2:	701c      	strb	r4, [r3, #0]
100061b4:	e7f6      	b.n	100061a4 <_cyhal_scb_pm_callback_common+0x54>
100061b6:	bf00      	nop
100061b8:	080037de 	.word	0x080037de

100061bc <_cyhal_scb_get_irq_obj>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
100061bc:	f3ef 8305 	mrs	r3, IPSR
    IRQn_Type irqn = _CYHAL_UTILS_GET_CURRENT_IRQN();
100061c0:	3b10      	subs	r3, #16
    switch (irqn)
100061c2:	b29b      	uxth	r3, r3
100061c4:	3b12      	subs	r3, #18
100061c6:	2b20      	cmp	r3, #32
100061c8:	d82b      	bhi.n	10006222 <_cyhal_scb_get_irq_obj+0x66>
100061ca:	e8df f003 	tbb	[pc, r3]
100061ce:	2a20      	.short	0x2a20
100061d0:	2a2a2a2a 	.word	0x2a2a2a2a
100061d4:	2a2a2a2a 	.word	0x2a2a2a2a
100061d8:	2a2a2a2a 	.word	0x2a2a2a2a
100061dc:	2a2a2a2a 	.word	0x2a2a2a2a
100061e0:	2b2a2a2a 	.word	0x2b2a2a2a
100061e4:	1816112d 	.word	0x1816112d
100061e8:	221e1c1a 	.word	0x221e1c1a
100061ec:	2624      	.short	0x2624
100061ee:	28          	.byte	0x28
100061ef:	00          	.byte	0x00
    case scb_2_interrupt_IRQn: return 2;
100061f0:	2302      	movs	r3, #2
}
100061f2:	4a0e      	ldr	r2, [pc, #56]	; (1000622c <_cyhal_scb_get_irq_obj+0x70>)
100061f4:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
100061f8:	4770      	bx	lr
    case scb_3_interrupt_IRQn: return 3;
100061fa:	2303      	movs	r3, #3
100061fc:	e7f9      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_4_interrupt_IRQn: return 4;
100061fe:	2304      	movs	r3, #4
10006200:	e7f7      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_5_interrupt_IRQn: return 5;
10006202:	2305      	movs	r3, #5
10006204:	e7f5      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_6_interrupt_IRQn: return 6;
10006206:	2306      	movs	r3, #6
10006208:	e7f3      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_7_interrupt_IRQn: return 7;
1000620a:	2307      	movs	r3, #7
1000620c:	e7f1      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_8_interrupt_IRQn: return 8;
1000620e:	2308      	movs	r3, #8
10006210:	e7ef      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_9_interrupt_IRQn: return 9;
10006212:	2309      	movs	r3, #9
10006214:	e7ed      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_10_interrupt_IRQn: return 10;
10006216:	230a      	movs	r3, #10
10006218:	e7eb      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_11_interrupt_IRQn: return 11;
1000621a:	230b      	movs	r3, #11
1000621c:	e7e9      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_12_interrupt_IRQn: return 12;
1000621e:	230c      	movs	r3, #12
10006220:	e7e7      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
10006222:	be01      	bkpt	0x0001
    case scb_0_interrupt_IRQn: return 0;
10006224:	2300      	movs	r3, #0
10006226:	e7e4      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
    case scb_1_interrupt_IRQn: return 1;
10006228:	2301      	movs	r3, #1
1000622a:	e7e2      	b.n	100061f2 <_cyhal_scb_get_irq_obj+0x36>
1000622c:	0800372c 	.word	0x0800372c

10006230 <_cyhal_scb_pm_transition_pending>:
}
10006230:	4b01      	ldr	r3, [pc, #4]	; (10006238 <_cyhal_scb_pm_transition_pending+0x8>)
10006232:	7818      	ldrb	r0, [r3, #0]
10006234:	4770      	bx	lr
10006236:	bf00      	nop
10006238:	080037de 	.word	0x080037de

1000623c <_cyhal_scb_update_instance_data>:
    .next = NULL,
    .ignore_modes = (cyhal_syspm_callback_mode_t)0,
};

void _cyhal_scb_update_instance_data(uint8_t block_num, void *obj, cyhal_scb_instance_pm_callback pm_callback)
{
1000623c:	b410      	push	{r4}
    _cyhal_scb_config_structs[block_num] = obj;
1000623e:	4b10      	ldr	r3, [pc, #64]	; (10006280 <_cyhal_scb_update_instance_data+0x44>)
    _cyhal_scb_config_pm_callback[block_num] = pm_callback;
10006240:	4c10      	ldr	r4, [pc, #64]	; (10006284 <_cyhal_scb_update_instance_data+0x48>)
    _cyhal_scb_config_structs[block_num] = obj;
10006242:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
    _cyhal_scb_config_pm_callback[block_num] = pm_callback;
10006246:	f844 2020 	str.w	r2, [r4, r0, lsl #2]

    int count = 0;
    for (uint8_t i = 0; i < _SCB_ARRAY_SIZE; i++)
1000624a:	461a      	mov	r2, r3
    int count = 0;
1000624c:	2000      	movs	r0, #0
    _cyhal_scb_config_pm_callback[block_num] = pm_callback;
1000624e:	230d      	movs	r3, #13
    {
        if (_cyhal_scb_config_structs[i])
10006250:	f852 4b04 	ldr.w	r4, [r2], #4
10006254:	b10c      	cbz	r4, 1000625a <_cyhal_scb_update_instance_data+0x1e>
        {
            if (count == 1)
10006256:	b980      	cbnz	r0, 1000627a <_cyhal_scb_update_instance_data+0x3e>
            {
                return;
            }
            count++;
10006258:	2001      	movs	r0, #1
    for (uint8_t i = 0; i < _SCB_ARRAY_SIZE; i++)
1000625a:	3b01      	subs	r3, #1
1000625c:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
10006260:	d1f6      	bne.n	10006250 <_cyhal_scb_update_instance_data+0x14>
        }
    }

    if (count == 0)
10006262:	b928      	cbnz	r0, 10006270 <_cyhal_scb_update_instance_data+0x34>
    {
        CY_ASSERT(obj == NULL);
10006264:	b101      	cbz	r1, 10006268 <_cyhal_scb_update_instance_data+0x2c>
10006266:	be01      	bkpt	0x0001
        _cyhal_syspm_unregister_peripheral_callback(&_cyhal_scb_pm_callback_data);
10006268:	4807      	ldr	r0, [pc, #28]	; (10006288 <_cyhal_scb_update_instance_data+0x4c>)
    }
    else if (count == 1 && obj != NULL)
    {
        _cyhal_syspm_register_peripheral_callback(&_cyhal_scb_pm_callback_data);
    }
}
1000626a:	bc10      	pop	{r4}
        _cyhal_syspm_unregister_peripheral_callback(&_cyhal_scb_pm_callback_data);
1000626c:	f000 bf50 	b.w	10007110 <_cyhal_syspm_unregister_peripheral_callback>
    else if (count == 1 && obj != NULL)
10006270:	b119      	cbz	r1, 1000627a <_cyhal_scb_update_instance_data+0x3e>
        _cyhal_syspm_register_peripheral_callback(&_cyhal_scb_pm_callback_data);
10006272:	4805      	ldr	r0, [pc, #20]	; (10006288 <_cyhal_scb_update_instance_data+0x4c>)
}
10006274:	bc10      	pop	{r4}
        _cyhal_syspm_register_peripheral_callback(&_cyhal_scb_pm_callback_data);
10006276:	f000 bf39 	b.w	100070ec <_cyhal_syspm_register_peripheral_callback>
}
1000627a:	bc10      	pop	{r4}
1000627c:	4770      	bx	lr
1000627e:	bf00      	nop
10006280:	0800372c 	.word	0x0800372c
10006284:	080036f8 	.word	0x080036f8
10006288:	080028f0 	.word	0x080028f0

1000628c <_cyhal_clock_set_enabled_unsupported>:
1000628c:	be01      	bkpt	0x0001
    CY_UNUSED_PARAMETER(clock);
    CY_UNUSED_PARAMETER(enabled);
    CY_UNUSED_PARAMETER(wait_for_lock);
    CY_ASSERT(false); // Unhandled clock
    return CYHAL_CLOCK_RSLT_ERR_NOT_SUPPORTED;
}
1000628e:	4801      	ldr	r0, [pc, #4]	; (10006294 <_cyhal_clock_set_enabled_unsupported+0x8>)
10006290:	4770      	bx	lr
10006292:	bf00      	nop
10006294:	04020202 	.word	0x04020202

10006298 <_cyhal_clock_set_frequency_unsupported>:
10006298:	be01      	bkpt	0x0001
    CY_UNUSED_PARAMETER(clock);
    CY_UNUSED_PARAMETER(hz);
    CY_UNUSED_PARAMETER(tolerance);
    CY_ASSERT(false); // Unhandled clock
    return CYHAL_CLOCK_RSLT_ERR_NOT_SUPPORTED;
}
1000629a:	4801      	ldr	r0, [pc, #4]	; (100062a0 <_cyhal_clock_set_frequency_unsupported+0x8>)
1000629c:	4770      	bx	lr
1000629e:	bf00      	nop
100062a0:	04020202 	.word	0x04020202

100062a4 <_cyhal_clock_set_divider_unsupported>:
100062a4:	be01      	bkpt	0x0001
{
    CY_UNUSED_PARAMETER(clock);
    CY_UNUSED_PARAMETER(divider);
    CY_ASSERT(false); // Unhandled clock
    return CYHAL_CLOCK_RSLT_ERR_NOT_SUPPORTED;
}
100062a6:	4801      	ldr	r0, [pc, #4]	; (100062ac <_cyhal_clock_set_divider_unsupported+0x8>)
100062a8:	4770      	bx	lr
100062aa:	bf00      	nop
100062ac:	04020202 	.word	0x04020202

100062b0 <_cyhal_clock_set_source_unsupported>:
100062b0:	be01      	bkpt	0x0001
{
    CY_UNUSED_PARAMETER(clock);
    CY_UNUSED_PARAMETER(source);
    CY_ASSERT(false); // Unhandled clock
    return CYHAL_CLOCK_RSLT_ERR_NOT_SUPPORTED;
}
100062b2:	4801      	ldr	r0, [pc, #4]	; (100062b8 <_cyhal_clock_set_source_unsupported+0x8>)
100062b4:	4770      	bx	lr
100062b6:	bf00      	nop
100062b8:	04020202 	.word	0x04020202

100062bc <_cyhal_clock_get_frequency_imo>:
// IMO
static uint32_t _cyhal_clock_get_frequency_imo(const cyhal_clock_t *clock)
{
    CY_UNUSED_PARAMETER(clock);
    return CY_SYSCLK_IMO_FREQ;
}
100062bc:	4800      	ldr	r0, [pc, #0]	; (100062c0 <_cyhal_clock_get_frequency_imo+0x4>)
100062be:	4770      	bx	lr
100062c0:	007a1200 	.word	0x007a1200

100062c4 <_cyhal_clock_is_enabled_eco>:
// ECO
#if SRSS_ECO_PRESENT
static bool _cyhal_clock_is_enabled_eco(const cyhal_clock_t *clock)
{
    CY_UNUSED_PARAMETER(clock);
    return 0u != (SRSS_CLK_ECO_CONFIG & SRSS_CLK_ECO_CONFIG_ECO_EN_Msk);
100062c4:	4b02      	ldr	r3, [pc, #8]	; (100062d0 <_cyhal_clock_is_enabled_eco+0xc>)
100062c6:	f8d3 052c 	ldr.w	r0, [r3, #1324]	; 0x52c
}
100062ca:	0fc0      	lsrs	r0, r0, #31
100062cc:	4770      	bx	lr
100062ce:	bf00      	nop
100062d0:	40260000 	.word	0x40260000

100062d4 <_cyhal_clock_is_enabled_wco>:
{
    CY_UNUSED_PARAMETER(clock);
#if defined(CY_IP_MXS28SRSS)
    return 0u != (BACKUP_CTL & BACKUP_WCO_CTL_WCO_EN_Msk);
#else
    return 0u != (BACKUP_CTL & BACKUP_CTL_WCO_EN_Msk);
100062d4:	4b02      	ldr	r3, [pc, #8]	; (100062e0 <_cyhal_clock_is_enabled_wco+0xc>)
100062d6:	6818      	ldr	r0, [r3, #0]
#endif
}
100062d8:	f3c0 00c0 	ubfx	r0, r0, #3, #1
100062dc:	4770      	bx	lr
100062de:	bf00      	nop
100062e0:	40270000 	.word	0x40270000

100062e4 <_cyhal_clock_get_sources_pathmux>:
    #if SRSS_ALTLF_PRESENT
        &CYHAL_CLOCK_RSC_ALTLF,
    #endif
    };

    *sources = _CYHAL_CLOCK_SOURCE_PATHMUX;
100062e4:	4b02      	ldr	r3, [pc, #8]	; (100062f0 <_cyhal_clock_get_sources_pathmux+0xc>)
100062e6:	600b      	str	r3, [r1, #0]
    *count = sizeof(_CYHAL_CLOCK_SOURCE_PATHMUX) / sizeof(_CYHAL_CLOCK_SOURCE_PATHMUX[0]);
100062e8:	2305      	movs	r3, #5
100062ea:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
100062ec:	2000      	movs	r0, #0
100062ee:	4770      	bx	lr
100062f0:	0800293c 	.word	0x0800293c

100062f4 <_cyhal_clock_get_sources_fll>:
    return rslt;
}
static cy_rslt_t _cyhal_clock_get_sources_fll(const cyhal_clock_t *clock, const cyhal_resource_inst_t **sources[], uint32_t *count)
{
    CY_UNUSED_PARAMETER(clock);
    *sources = &(_CYHAL_CLOCK_SOURCE_HF[1 + SRSS_NUM_PLL]);
100062f4:	4b02      	ldr	r3, [pc, #8]	; (10006300 <_cyhal_clock_get_sources_fll+0xc>)
100062f6:	600b      	str	r3, [r1, #0]
    *count = 1;
100062f8:	2301      	movs	r3, #1
100062fa:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
100062fc:	2000      	movs	r0, #0
100062fe:	4770      	bx	lr
10006300:	0800295c 	.word	0x0800295c

10006304 <_cyhal_clock_get_sources_pll>:
}
static cy_rslt_t _cyhal_clock_get_sources_pll(const cyhal_clock_t *clock, const cyhal_resource_inst_t **sources[], uint32_t *count)
{
    // _CYHAL_CLOCK_SOURCE_HF has entries for FLL, PLL[n], PathMux[m]
#if defined(COMPONENT_CAT1A) || (SRSS_FLL_PRESENT)
    *sources = &(_CYHAL_CLOCK_SOURCE_HF[2 + SRSS_NUM_PLL + clock->channel]); /* PATHMUX[n] entry is after the FLL (+1), PLLs (+num) and FLL path mux (+1) */
10006304:	7840      	ldrb	r0, [r0, #1]
10006306:	4b04      	ldr	r3, [pc, #16]	; (10006318 <_cyhal_clock_get_sources_pll+0x14>)
10006308:	3004      	adds	r0, #4
1000630a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
1000630e:	600b      	str	r3, [r1, #0]
#else
    *sources = &(_CYHAL_CLOCK_SOURCE_HF[SRSS_NUM_PLL + clock->channel]); /* PATHMUX[n] entry is after the PLLs (+num) */
#endif
    *count = 1;
10006310:	2301      	movs	r3, #1
10006312:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
10006314:	2000      	movs	r0, #0
10006316:	4770      	bx	lr
10006318:	08002950 	.word	0x08002950

1000631c <_cyhal_clock_get_sources_hf>:
    return rslt;
}
static cy_rslt_t _cyhal_clock_get_sources_hf(const cyhal_clock_t *clock, const cyhal_resource_inst_t **sources[], uint32_t *count)
{
    CY_UNUSED_PARAMETER(clock);
    *sources = _CYHAL_CLOCK_SOURCE_HF;
1000631c:	4b02      	ldr	r3, [pc, #8]	; (10006328 <_cyhal_clock_get_sources_hf+0xc>)
1000631e:	600b      	str	r3, [r1, #0]
    *count = sizeof(_CYHAL_CLOCK_SOURCE_HF) / sizeof(_CYHAL_CLOCK_SOURCE_HF[0]);
10006320:	2309      	movs	r3, #9
10006322:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
10006324:	2000      	movs	r0, #0
10006326:	4770      	bx	lr
10006328:	08002950 	.word	0x08002950

1000632c <_cyhal_clock_get_sources_lf>:
        &CYHAL_CLOCK_RSC_LPECO_PRESCALER,
#endif
#endif
    };

    *sources = _CYHAL_CLOCK_SOURCE_LF;
1000632c:	4b02      	ldr	r3, [pc, #8]	; (10006338 <_cyhal_clock_get_sources_lf+0xc>)
1000632e:	600b      	str	r3, [r1, #0]
    *count = sizeof(_CYHAL_CLOCK_SOURCE_LF) / sizeof(_CYHAL_CLOCK_SOURCE_LF[0]);
10006330:	2302      	movs	r3, #2
10006332:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
10006334:	2000      	movs	r0, #0
10006336:	4770      	bx	lr
10006338:	08002934 	.word	0x08002934

1000633c <_cyhal_clock_get_sources_fast>:
    static const cyhal_resource_inst_t *_CYHAL_CLOCK_SOURCE_FAST[] =
    {
        &CYHAL_CLOCK_RSC_HF[0],
    };

    *sources = _CYHAL_CLOCK_SOURCE_FAST;
1000633c:	4b02      	ldr	r3, [pc, #8]	; (10006348 <_cyhal_clock_get_sources_fast+0xc>)
1000633e:	600b      	str	r3, [r1, #0]
    *count = sizeof(_CYHAL_CLOCK_SOURCE_FAST) / sizeof(_CYHAL_CLOCK_SOURCE_FAST[0]);
10006340:	2301      	movs	r3, #1
10006342:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
10006344:	2000      	movs	r0, #0
10006346:	4770      	bx	lr
10006348:	08002910 	.word	0x08002910

1000634c <_cyhal_clock_get_sources_slow>:
    static const cyhal_resource_inst_t *_CYHAL_CLOCK_SOURCE_SLOW[] =
    {
        &CYHAL_CLOCK_RSC_PERI,
    };

    *sources = _CYHAL_CLOCK_SOURCE_SLOW;
1000634c:	4b02      	ldr	r3, [pc, #8]	; (10006358 <_cyhal_clock_get_sources_slow+0xc>)
1000634e:	600b      	str	r3, [r1, #0]
    *count = sizeof(_CYHAL_CLOCK_SOURCE_SLOW) / sizeof(_CYHAL_CLOCK_SOURCE_SLOW[0]);
10006350:	2301      	movs	r3, #1
10006352:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
10006354:	2000      	movs	r0, #0
10006356:	4770      	bx	lr
10006358:	08002900 	.word	0x08002900

1000635c <_cyhal_clock_get_sources_peri>:
    static const cyhal_resource_inst_t *_CYHAL_CLOCK_SOURCE_PERI[] =
    {
        &CYHAL_CLOCK_RSC_HF[0],
    };

    *sources = _CYHAL_CLOCK_SOURCE_PERI;
1000635c:	4b02      	ldr	r3, [pc, #8]	; (10006368 <_cyhal_clock_get_sources_peri+0xc>)
1000635e:	600b      	str	r3, [r1, #0]
    *count = 1;
10006360:	2301      	movs	r3, #1
10006362:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
#elif defined (COMPONENT_CAT1B)
    uint8_t hfclk = _cyhal_utils_get_hfclk_for_peri_group(clock->channel);
    return _cyhal_clock_get_sources_peri_peripheral(hfclk, sources, count);
#endif
}
10006364:	2000      	movs	r0, #0
10006366:	4770      	bx	lr
10006368:	0800290c 	.word	0x0800290c

1000636c <_cyhal_clock_get_sources_timer>:
    {
        &CYHAL_CLOCK_RSC_IMO,
        &CYHAL_CLOCK_RSC_HF[0],
    };

    *sources = _CYHAL_CLOCK_SOURCE_TIMER;
1000636c:	4b02      	ldr	r3, [pc, #8]	; (10006378 <_cyhal_clock_get_sources_timer+0xc>)
1000636e:	600b      	str	r3, [r1, #0]
    *count = sizeof(_CYHAL_CLOCK_SOURCE_TIMER) / sizeof(_CYHAL_CLOCK_SOURCE_TIMER[0]);
10006370:	2302      	movs	r3, #2
10006372:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
10006374:	2000      	movs	r0, #0
10006376:	4770      	bx	lr
10006378:	08002904 	.word	0x08002904

1000637c <_cyhal_clock_get_sources_bak>:
    #if SRSS_BACKUP_PRESENT
        &CYHAL_CLOCK_RSC_WCO,
    #endif
    };

    *sources = _CYHAL_CLOCK_SOURCE_BAK;
1000637c:	4b02      	ldr	r3, [pc, #8]	; (10006388 <_cyhal_clock_get_sources_bak+0xc>)
1000637e:	600b      	str	r3, [r1, #0]
    *count = sizeof(_CYHAL_CLOCK_SOURCE_BAK) / sizeof(_CYHAL_CLOCK_SOURCE_BAK[0]);
10006380:	2302      	movs	r3, #2
10006382:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
10006384:	2000      	movs	r0, #0
10006386:	4770      	bx	lr
10006388:	0800292c 	.word	0x0800292c

1000638c <_cyhal_clock_get_sources_alt_sys_tick>:
#elif defined(COMPONENT_CAT1B)
        &CYHAL_CLOCK_RSC_HF[0], /* CPU clock */
#endif
    };

    *sources = _CYHAL_CLOCK_SOURCE_ALT_SYS_TICK;
1000638c:	4b02      	ldr	r3, [pc, #8]	; (10006398 <_cyhal_clock_get_sources_alt_sys_tick+0xc>)
1000638e:	600b      	str	r3, [r1, #0]
    *count = sizeof(_CYHAL_CLOCK_SOURCE_ALT_SYS_TICK) / sizeof(_CYHAL_CLOCK_SOURCE_ALT_SYS_TICK[0]);
10006390:	2306      	movs	r3, #6
10006392:	6013      	str	r3, [r2, #0]
    return CY_RSLT_SUCCESS;
}
10006394:	2000      	movs	r0, #0
10006396:	4770      	bx	lr
10006398:	08002914 	.word	0x08002914

1000639c <_cyhal_clock_update_system_state>:
    if ((before_change == (bool)(new_sysclk_freq_hz > old_sysclk_freq_hz)) ||
1000639c:	428a      	cmp	r2, r1
{
1000639e:	b538      	push	{r3, r4, r5, lr}
    if ((before_change == (bool)(new_sysclk_freq_hz > old_sysclk_freq_hz)) ||
100063a0:	bf94      	ite	ls
100063a2:	2300      	movls	r3, #0
100063a4:	2301      	movhi	r3, #1
100063a6:	4283      	cmp	r3, r0
{
100063a8:	4604      	mov	r4, r0
100063aa:	4615      	mov	r5, r2
    if ((before_change == (bool)(new_sysclk_freq_hz > old_sysclk_freq_hz)) ||
100063ac:	d007      	beq.n	100063be <_cyhal_clock_update_system_state+0x22>
100063ae:	428a      	cmp	r2, r1
100063b0:	bf2c      	ite	cs
100063b2:	2100      	movcs	r1, #0
100063b4:	2101      	movcc	r1, #1
100063b6:	f080 0301 	eor.w	r3, r0, #1
100063ba:	4299      	cmp	r1, r3
100063bc:	d106      	bne.n	100063cc <_cyhal_clock_update_system_state+0x30>
        bool is_ulp = Cy_SysPm_IsSystemUlp();
100063be:	f002 f948 	bl	10008652 <Cy_SysPm_IsSystemUlp>
        Cy_SysLib_SetWaitStates(is_ulp, new_sysclk_freq_hz / 1000000);
100063c2:	4905      	ldr	r1, [pc, #20]	; (100063d8 <_cyhal_clock_update_system_state+0x3c>)
100063c4:	fbb5 f1f1 	udiv	r1, r5, r1
100063c8:	f7ff fb14 	bl	100059f4 <Cy_SysLib_SetWaitStates>
    if (!before_change)
100063cc:	b91c      	cbnz	r4, 100063d6 <_cyhal_clock_update_system_state+0x3a>
}
100063ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        SystemCoreClockUpdate();
100063d2:	f7fd be19 	b.w	10004008 <SystemCoreClockUpdate>
}
100063d6:	bd38      	pop	{r3, r4, r5, pc}
100063d8:	000f4240 	.word	0x000f4240

100063dc <_cyhal_clock_set_source_pathmux>:
{
100063dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    switch (source->block)
100063e0:	780b      	ldrb	r3, [r1, #0]
100063e2:	3b04      	subs	r3, #4
{
100063e4:	4607      	mov	r7, r0
    switch (source->block)
100063e6:	2b07      	cmp	r3, #7
100063e8:	d828      	bhi.n	1000643c <_cyhal_clock_set_source_pathmux+0x60>
100063ea:	e8df f003 	tbb	[pc, r3]
100063ee:	222c      	.short	0x222c
100063f0:	2f272709 	.word	0x2f272709
100063f4:	0427      	.short	0x0427
            clkpath_src = CY_SYSCLK_CLKPATH_IN_WCO;
100063f6:	f240 1511 	movw	r5, #273	; 0x111
    switch (source->block)
100063fa:	f44f 4400 	mov.w	r4, #32768	; 0x8000
100063fe:	e003      	b.n	10006408 <_cyhal_clock_set_source_pathmux+0x2c>
            new_freq = Cy_SysClk_ExtClkGetFrequency();
10006400:	f7fe fe6c 	bl	100050dc <Cy_SysClk_ExtClkGetFrequency>
            clkpath_src = CY_SYSCLK_CLKPATH_IN_EXT;
10006404:	2501      	movs	r5, #1
            new_freq = Cy_SysClk_ExtClkGetFrequency();
10006406:	4604      	mov	r4, r0
    uint32_t old_hf_freq = Cy_SysClk_ClkHfGetFrequency(0);
10006408:	2000      	movs	r0, #0
1000640a:	f002 f8ae 	bl	1000856a <Cy_SysClk_ClkHfGetFrequency>
1000640e:	4606      	mov	r6, r0
    uint32_t new_hf_freq = new_freq >> ((uint8_t)Cy_SysClk_ClkHfGetDivider(0));
10006410:	2000      	movs	r0, #0
10006412:	f7fe fdf7 	bl	10005004 <Cy_SysClk_ClkHfGetDivider>
10006416:	4680      	mov	r8, r0
    bool is_sysclk_path = (clock->channel == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
10006418:	2000      	movs	r0, #0
1000641a:	f897 9001 	ldrb.w	r9, [r7, #1]
1000641e:	f7fe fdc1 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
    if (is_sysclk_path)
10006422:	4581      	cmp	r9, r0
10006424:	d015      	beq.n	10006452 <_cyhal_clock_set_source_pathmux+0x76>
    cy_rslt_t rslt = Cy_SysClk_ClkPathSetSource(clock->channel, clkpath_src);
10006426:	7878      	ldrb	r0, [r7, #1]
10006428:	4629      	mov	r1, r5
}
1000642a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    cy_rslt_t rslt = Cy_SysClk_ClkPathSetSource(clock->channel, clkpath_src);
1000642e:	f7fe beb1 	b.w	10005194 <Cy_SysClk_ClkPathSetSource>
            new_freq = Cy_SysClk_EcoGetFrequency();
10006432:	f7fe fea3 	bl	1000517c <Cy_SysClk_EcoGetFrequency>
            clkpath_src = CY_SYSCLK_CLKPATH_IN_ECO;
10006436:	2502      	movs	r5, #2
            new_freq = Cy_SysClk_EcoGetFrequency();
10006438:	4604      	mov	r4, r0
            break;
1000643a:	e7e5      	b.n	10006408 <_cyhal_clock_set_source_pathmux+0x2c>
1000643c:	be01      	bkpt	0x0001
            return CYHAL_CLOCK_RSLT_ERR_SOURCE;
1000643e:	4d10      	ldr	r5, [pc, #64]	; (10006480 <_cyhal_clock_set_source_pathmux+0xa4>)
}
10006440:	4628      	mov	r0, r5
10006442:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            new_freq = CY_SYSCLK_IMO_FREQ;
10006446:	4c0f      	ldr	r4, [pc, #60]	; (10006484 <_cyhal_clock_set_source_pathmux+0xa8>)
            clkpath_src = CY_SYSCLK_CLKPATH_IN_IMO;
10006448:	2500      	movs	r5, #0
1000644a:	e7dd      	b.n	10006408 <_cyhal_clock_set_source_pathmux+0x2c>
    switch (source->block)
1000644c:	f44f 7588 	mov.w	r5, #272	; 0x110
10006450:	e7d3      	b.n	100063fa <_cyhal_clock_set_source_pathmux+0x1e>
    uint32_t new_hf_freq = new_freq >> ((uint8_t)Cy_SysClk_ClkHfGetDivider(0));
10006452:	fa24 f408 	lsr.w	r4, r4, r8
        _cyhal_clock_update_system_state(true, old_hf_freq, new_hf_freq);
10006456:	4622      	mov	r2, r4
10006458:	4631      	mov	r1, r6
1000645a:	2001      	movs	r0, #1
1000645c:	f7ff ff9e 	bl	1000639c <_cyhal_clock_update_system_state>
    cy_rslt_t rslt = Cy_SysClk_ClkPathSetSource(clock->channel, clkpath_src);
10006460:	4629      	mov	r1, r5
10006462:	7878      	ldrb	r0, [r7, #1]
10006464:	f7fe fe96 	bl	10005194 <Cy_SysClk_ClkPathSetSource>
        if (CY_RSLT_SUCCESS == rslt)
10006468:	4605      	mov	r5, r0
1000646a:	b920      	cbnz	r0, 10006476 <_cyhal_clock_set_source_pathmux+0x9a>
            _cyhal_clock_update_system_state(false, old_hf_freq, new_hf_freq);
1000646c:	4622      	mov	r2, r4
1000646e:	4631      	mov	r1, r6
            _cyhal_clock_update_system_state(false, new_hf_freq, old_hf_freq);
10006470:	f7ff ff94 	bl	1000639c <_cyhal_clock_update_system_state>
10006474:	e7e4      	b.n	10006440 <_cyhal_clock_set_source_pathmux+0x64>
10006476:	4632      	mov	r2, r6
10006478:	4621      	mov	r1, r4
1000647a:	2000      	movs	r0, #0
1000647c:	e7f8      	b.n	10006470 <_cyhal_clock_set_source_pathmux+0x94>
1000647e:	bf00      	nop
10006480:	04020201 	.word	0x04020201
10006484:	007a1200 	.word	0x007a1200

10006488 <_cyhal_clock_set_source_lf>:
{
10006488:	b508      	push	{r3, lr}
    switch (source->block)
1000648a:	780b      	ldrb	r3, [r1, #0]
1000648c:	2b09      	cmp	r3, #9
1000648e:	d004      	beq.n	1000649a <_cyhal_clock_set_source_lf+0x12>
10006490:	2b0b      	cmp	r3, #11
10006492:	d007      	beq.n	100064a4 <_cyhal_clock_set_source_lf+0x1c>
10006494:	be01      	bkpt	0x0001
            return CYHAL_CLOCK_RSLT_ERR_SOURCE;
10006496:	4804      	ldr	r0, [pc, #16]	; (100064a8 <_cyhal_clock_set_source_lf+0x20>)
10006498:	e003      	b.n	100064a2 <_cyhal_clock_set_source_lf+0x1a>
            Cy_SysClk_ClkLfSetSource(CY_SYSCLK_CLKLF_IN_ILO);
1000649a:	2000      	movs	r0, #0
            Cy_SysClk_ClkLfSetSource(CY_SYSCLK_CLKLF_IN_WCO);
1000649c:	f7fe fcd6 	bl	10004e4c <Cy_SysClk_ClkLfSetSource>
            return CY_RSLT_SUCCESS;
100064a0:	2000      	movs	r0, #0
}
100064a2:	bd08      	pop	{r3, pc}
            Cy_SysClk_ClkLfSetSource(CY_SYSCLK_CLKLF_IN_WCO);
100064a4:	2001      	movs	r0, #1
100064a6:	e7f9      	b.n	1000649c <_cyhal_clock_set_source_lf+0x14>
100064a8:	04020201 	.word	0x04020201

100064ac <_cyhal_clock_set_source_pump>:
{
100064ac:	b508      	push	{r3, lr}
    if (source->block == CYHAL_CLOCK_BLOCK_PATHMUX || source->block == CYHAL_CLOCK_BLOCK_FLL)
100064ae:	780b      	ldrb	r3, [r1, #0]
100064b0:	f1a3 020d 	sub.w	r2, r3, #13
100064b4:	2a01      	cmp	r2, #1
100064b6:	d804      	bhi.n	100064c2 <_cyhal_clock_set_source_pump+0x16>
        Cy_SysClk_ClkPumpSetSource((cy_en_clkpump_in_sources_t)source->channel);
100064b8:	7848      	ldrb	r0, [r1, #1]
        Cy_SysClk_ClkPumpSetSource((cy_en_clkpump_in_sources_t)(source->channel + 1));
100064ba:	f7fe fc21 	bl	10004d00 <Cy_SysClk_ClkPumpSetSource>
        return CY_RSLT_SUCCESS;
100064be:	2000      	movs	r0, #0
}
100064c0:	bd08      	pop	{r3, pc}
    else if (source->block == CYHAL_CLOCK_BLOCK_PLL)
100064c2:	2b0f      	cmp	r3, #15
100064c4:	d103      	bne.n	100064ce <_cyhal_clock_set_source_pump+0x22>
        Cy_SysClk_ClkPumpSetSource((cy_en_clkpump_in_sources_t)(source->channel + 1));
100064c6:	7848      	ldrb	r0, [r1, #1]
100064c8:	3001      	adds	r0, #1
100064ca:	b2c0      	uxtb	r0, r0
100064cc:	e7f5      	b.n	100064ba <_cyhal_clock_set_source_pump+0xe>
        return CYHAL_CLOCK_RSLT_ERR_SOURCE;
100064ce:	4801      	ldr	r0, [pc, #4]	; (100064d4 <_cyhal_clock_set_source_pump+0x28>)
100064d0:	e7f6      	b.n	100064c0 <_cyhal_clock_set_source_pump+0x14>
100064d2:	bf00      	nop
100064d4:	04020201 	.word	0x04020201

100064d8 <_cyhal_clock_set_divider_pump>:
    switch (divider)
100064d8:	2908      	cmp	r1, #8
{
100064da:	b508      	push	{r3, lr}
    switch (divider)
100064dc:	d80e      	bhi.n	100064fc <_cyhal_clock_set_divider_pump+0x24>
100064de:	b179      	cbz	r1, 10006500 <_cyhal_clock_set_divider_pump+0x28>
100064e0:	3901      	subs	r1, #1
100064e2:	2907      	cmp	r1, #7
100064e4:	d80c      	bhi.n	10006500 <_cyhal_clock_set_divider_pump+0x28>
100064e6:	e8df f001 	tbb	[pc, r1]
100064ea:	1104      	.short	0x1104
100064ec:	0b0b0d0b 	.word	0x0b0b0d0b
100064f0:	0f0b      	.short	0x0f0b
            divVal = CY_SYSCLK_PUMP_NO_DIV;
100064f2:	2000      	movs	r0, #0
    Cy_SysClk_ClkPumpSetDivider(divVal);
100064f4:	f7fe fc1e 	bl	10004d34 <Cy_SysClk_ClkPumpSetDivider>
    return CY_RSLT_SUCCESS;
100064f8:	2000      	movs	r0, #0
}
100064fa:	bd08      	pop	{r3, pc}
    switch (divider)
100064fc:	2910      	cmp	r1, #16
100064fe:	d007      	beq.n	10006510 <_cyhal_clock_set_divider_pump+0x38>
10006500:	4804      	ldr	r0, [pc, #16]	; (10006514 <_cyhal_clock_set_divider_pump+0x3c>)
10006502:	e7fa      	b.n	100064fa <_cyhal_clock_set_divider_pump+0x22>
            divVal = CY_SYSCLK_PUMP_DIV_4;
10006504:	2002      	movs	r0, #2
            break;
10006506:	e7f5      	b.n	100064f4 <_cyhal_clock_set_divider_pump+0x1c>
            divVal = CY_SYSCLK_PUMP_DIV_8;
10006508:	2003      	movs	r0, #3
            break;
1000650a:	e7f3      	b.n	100064f4 <_cyhal_clock_set_divider_pump+0x1c>
    switch (divider)
1000650c:	2001      	movs	r0, #1
1000650e:	e7f1      	b.n	100064f4 <_cyhal_clock_set_divider_pump+0x1c>
            divVal = CY_SYSCLK_PUMP_DIV_16;
10006510:	2004      	movs	r0, #4
10006512:	e7ef      	b.n	100064f4 <_cyhal_clock_set_divider_pump+0x1c>
10006514:	04020200 	.word	0x04020200

10006518 <_cyhal_clock_set_source_bak>:
{
10006518:	b508      	push	{r3, lr}
    switch (source->block)
1000651a:	780b      	ldrb	r3, [r1, #0]
1000651c:	2b0b      	cmp	r3, #11
1000651e:	d004      	beq.n	1000652a <_cyhal_clock_set_source_bak+0x12>
10006520:	2b10      	cmp	r3, #16
10006522:	d007      	beq.n	10006534 <_cyhal_clock_set_source_bak+0x1c>
10006524:	be01      	bkpt	0x0001
            return CYHAL_CLOCK_RSLT_ERR_SOURCE;
10006526:	4804      	ldr	r0, [pc, #16]	; (10006538 <_cyhal_clock_set_source_bak+0x20>)
10006528:	e003      	b.n	10006532 <_cyhal_clock_set_source_bak+0x1a>
            Cy_SysClk_ClkBakSetSource(CY_SYSCLK_BAK_IN_WCO);
1000652a:	2000      	movs	r0, #0
            Cy_SysClk_ClkBakSetSource(CY_SYSCLK_BAK_IN_CLKLF);
1000652c:	f7fe fc38 	bl	10004da0 <Cy_SysClk_ClkBakSetSource>
            return CY_RSLT_SUCCESS;
10006530:	2000      	movs	r0, #0
}
10006532:	bd08      	pop	{r3, pc}
            Cy_SysClk_ClkBakSetSource(CY_SYSCLK_BAK_IN_CLKLF);
10006534:	2001      	movs	r0, #1
10006536:	e7f9      	b.n	1000652c <_cyhal_clock_set_source_bak+0x14>
10006538:	04020201 	.word	0x04020201

1000653c <_cyhal_clock_set_source_alt_sys_tick>:
static cy_rslt_t _cyhal_clock_set_source_alt_sys_tick(cyhal_clock_t *clock, const cyhal_clock_t *source)
{
1000653c:	b508      	push	{r3, lr}
    CY_UNUSED_PARAMETER(clock);

    switch (source->block)
1000653e:	780b      	ldrb	r3, [r1, #0]
10006540:	2b19      	cmp	r3, #25
10006542:	d805      	bhi.n	10006550 <_cyhal_clock_set_source_alt_sys_tick+0x14>
10006544:	2b0f      	cmp	r3, #15
10006546:	d806      	bhi.n	10006556 <_cyhal_clock_set_source_alt_sys_tick+0x1a>
10006548:	2b04      	cmp	r3, #4
1000654a:	d024      	beq.n	10006596 <_cyhal_clock_set_source_alt_sys_tick+0x5a>
1000654c:	2b05      	cmp	r3, #5
1000654e:	d024      	beq.n	1000659a <_cyhal_clock_set_source_alt_sys_tick+0x5e>
10006550:	be01      	bkpt	0x0001
            Cy_SysTick_SetClockSource(CY_SYSTICK_CLOCK_SOURCE_CLK_CPU);
            return CY_RSLT_SUCCESS;
#endif
        default:
            CY_ASSERT(false); //Unhandled clock
            return CYHAL_CLOCK_RSLT_ERR_SOURCE;
10006552:	4815      	ldr	r0, [pc, #84]	; (100065a8 <_cyhal_clock_set_source_alt_sys_tick+0x6c>)
10006554:	e01e      	b.n	10006594 <_cyhal_clock_set_source_alt_sys_tick+0x58>
    switch (source->block)
10006556:	3b10      	subs	r3, #16
10006558:	2b09      	cmp	r3, #9
1000655a:	d8f9      	bhi.n	10006550 <_cyhal_clock_set_source_alt_sys_tick+0x14>
1000655c:	a201      	add	r2, pc, #4	; (adr r2, 10006564 <_cyhal_clock_set_source_alt_sys_tick+0x28>)
1000655e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
10006562:	bf00      	nop
10006564:	1000658d 	.word	0x1000658d
10006568:	10006551 	.word	0x10006551
1000656c:	10006551 	.word	0x10006551
10006570:	10006551 	.word	0x10006551
10006574:	10006551 	.word	0x10006551
10006578:	1000659f 	.word	0x1000659f
1000657c:	10006551 	.word	0x10006551
10006580:	100065a3 	.word	0x100065a3
10006584:	10006551 	.word	0x10006551
10006588:	100065a3 	.word	0x100065a3
            Cy_SysTick_SetClockSource(CY_SYSTICK_CLOCK_SOURCE_CLK_LF);
1000658c:	2000      	movs	r0, #0
            Cy_SysTick_SetClockSource(CY_SYSTICK_CLOCK_SOURCE_CLK_IMO);
1000658e:	f7ff fae5 	bl	10005b5c <Cy_SysTick_SetClockSource>
            return CY_RSLT_SUCCESS;
10006592:	2000      	movs	r0, #0
    }
}
10006594:	bd08      	pop	{r3, pc}
            Cy_SysTick_SetClockSource(CY_SYSTICK_CLOCK_SOURCE_CLK_IMO);
10006596:	2001      	movs	r0, #1
10006598:	e7f9      	b.n	1000658e <_cyhal_clock_set_source_alt_sys_tick+0x52>
            Cy_SysTick_SetClockSource(CY_SYSTICK_CLOCK_SOURCE_CLK_ECO);
1000659a:	2002      	movs	r0, #2
1000659c:	e7f7      	b.n	1000658e <_cyhal_clock_set_source_alt_sys_tick+0x52>
            Cy_SysTick_SetClockSource(CY_SYSTICK_CLOCK_SOURCE_CLK_TIMER);
1000659e:	2003      	movs	r0, #3
100065a0:	e7f5      	b.n	1000658e <_cyhal_clock_set_source_alt_sys_tick+0x52>
            Cy_SysTick_SetClockSource(CY_SYSTICK_CLOCK_SOURCE_CLK_CPU);
100065a2:	2004      	movs	r0, #4
100065a4:	e7f3      	b.n	1000658e <_cyhal_clock_set_source_alt_sys_tick+0x52>
100065a6:	bf00      	nop
100065a8:	04020201 	.word	0x04020201

100065ac <_cyhal_clock_set_source_hf>:
{
100065ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (source->block == CYHAL_CLOCK_BLOCK_PATHMUX || source->block == CYHAL_CLOCK_BLOCK_FLL)
100065ae:	780b      	ldrb	r3, [r1, #0]
100065b0:	f1a3 020d 	sub.w	r2, r3, #13
100065b4:	2a01      	cmp	r2, #1
{
100065b6:	4607      	mov	r7, r0
    if (source->block == CYHAL_CLOCK_BLOCK_PATHMUX || source->block == CYHAL_CLOCK_BLOCK_FLL)
100065b8:	d825      	bhi.n	10006606 <_cyhal_clock_set_source_hf+0x5a>
        new_src = source->channel;
100065ba:	784c      	ldrb	r4, [r1, #1]
    uint32_t div = (uint32_t)Cy_SysClk_ClkHfGetDivider(0);
100065bc:	2000      	movs	r0, #0
100065be:	f7fe fd21 	bl	10005004 <Cy_SysClk_ClkHfGetDivider>
100065c2:	4605      	mov	r5, r0
    uint32_t old_src = (uint32_t)Cy_SysClk_ClkHfGetSource(0);
100065c4:	2000      	movs	r0, #0
100065c6:	f7fe fced 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
    uint32_t old_freq = Cy_SysClk_ClkPathGetFrequency(old_src) >> div;
100065ca:	f7ff f999 	bl	10005900 <Cy_SysClk_ClkPathGetFrequency>
100065ce:	fa20 f605 	lsr.w	r6, r0, r5
    uint32_t new_freq = Cy_SysClk_ClkPathGetFrequency(new_src) >> div;
100065d2:	4620      	mov	r0, r4
100065d4:	f7ff f994 	bl	10005900 <Cy_SysClk_ClkPathGetFrequency>
    if (0 == clock->channel)
100065d8:	787b      	ldrb	r3, [r7, #1]
    uint32_t new_freq = Cy_SysClk_ClkPathGetFrequency(new_src) >> div;
100065da:	fa20 f505 	lsr.w	r5, r0, r5
    if (0 == clock->channel)
100065de:	b923      	cbnz	r3, 100065ea <_cyhal_clock_set_source_hf+0x3e>
        _cyhal_clock_update_system_state(true, old_freq, new_freq);
100065e0:	462a      	mov	r2, r5
100065e2:	4631      	mov	r1, r6
100065e4:	2001      	movs	r0, #1
100065e6:	f7ff fed9 	bl	1000639c <_cyhal_clock_update_system_state>
    cy_rslt_t rslt = Cy_SysClk_ClkHfSetSource(clock->channel, (cy_en_clkhf_in_sources_t)new_src);
100065ea:	b2e1      	uxtb	r1, r4
100065ec:	7878      	ldrb	r0, [r7, #1]
100065ee:	f7fe fcbd 	bl	10004f6c <Cy_SysClk_ClkHfSetSource>
    if (0 == clock->channel)
100065f2:	787b      	ldrb	r3, [r7, #1]
    cy_rslt_t rslt = Cy_SysClk_ClkHfSetSource(clock->channel, (cy_en_clkhf_in_sources_t)new_src);
100065f4:	4604      	mov	r4, r0
    if (0 == clock->channel)
100065f6:	b923      	cbnz	r3, 10006602 <_cyhal_clock_set_source_hf+0x56>
        if (CY_RSLT_SUCCESS == rslt)
100065f8:	b950      	cbnz	r0, 10006610 <_cyhal_clock_set_source_hf+0x64>
            _cyhal_clock_update_system_state(false, old_freq, new_freq);
100065fa:	462a      	mov	r2, r5
100065fc:	4631      	mov	r1, r6
            _cyhal_clock_update_system_state(false, new_freq, old_freq);
100065fe:	f7ff fecd 	bl	1000639c <_cyhal_clock_update_system_state>
}
10006602:	4620      	mov	r0, r4
10006604:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if (source->block == CYHAL_CLOCK_BLOCK_PLL)
10006606:	2b0f      	cmp	r3, #15
10006608:	d106      	bne.n	10006618 <_cyhal_clock_set_source_hf+0x6c>
        new_src = source->channel + 1;
1000660a:	784c      	ldrb	r4, [r1, #1]
1000660c:	3401      	adds	r4, #1
1000660e:	e7d5      	b.n	100065bc <_cyhal_clock_set_source_hf+0x10>
            _cyhal_clock_update_system_state(false, new_freq, old_freq);
10006610:	4632      	mov	r2, r6
10006612:	4629      	mov	r1, r5
10006614:	4618      	mov	r0, r3
10006616:	e7f2      	b.n	100065fe <_cyhal_clock_set_source_hf+0x52>
        return CYHAL_CLOCK_RSLT_ERR_SOURCE;
10006618:	4c00      	ldr	r4, [pc, #0]	; (1000661c <_cyhal_clock_set_source_hf+0x70>)
1000661a:	e7f2      	b.n	10006602 <_cyhal_clock_set_source_hf+0x56>
1000661c:	04020201 	.word	0x04020201

10006620 <_cyhal_clock_set_divider_hf>:
    switch (divider)
10006620:	3901      	subs	r1, #1
{
10006622:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10006624:	4607      	mov	r7, r0
    switch (divider)
10006626:	2907      	cmp	r1, #7
10006628:	d832      	bhi.n	10006690 <_cyhal_clock_set_divider_hf+0x70>
1000662a:	e8df f001 	tbb	[pc, r1]
1000662e:	2b04      	.short	0x2b04
10006630:	31312731 	.word	0x31312731
10006634:	2931      	.short	0x2931
            new_div = CY_SYSCLK_CLKHF_NO_DIVIDE;
10006636:	2600      	movs	r6, #0
    uint32_t old_div = (uint32_t)Cy_SysClk_ClkHfGetDivider(0);
10006638:	2000      	movs	r0, #0
1000663a:	f7fe fce3 	bl	10005004 <Cy_SysClk_ClkHfGetDivider>
1000663e:	4605      	mov	r5, r0
    uint32_t src = (uint32_t)Cy_SysClk_ClkHfGetSource(0);
10006640:	2000      	movs	r0, #0
10006642:	f7fe fcaf 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
    uint32_t path_freq = Cy_SysClk_ClkPathGetFrequency(src);
10006646:	f7ff f95b 	bl	10005900 <Cy_SysClk_ClkPathGetFrequency>
    if (0 == clock->channel)
1000664a:	787b      	ldrb	r3, [r7, #1]
    uint32_t path_freq = Cy_SysClk_ClkPathGetFrequency(src);
1000664c:	4604      	mov	r4, r0
    uint32_t old_freq = path_freq >> old_div;
1000664e:	fa20 f505 	lsr.w	r5, r0, r5
    uint32_t new_freq = path_freq >> ((uint32_t)new_div);
10006652:	40f4      	lsrs	r4, r6
    if (0 == clock->channel)
10006654:	b923      	cbnz	r3, 10006660 <_cyhal_clock_set_divider_hf+0x40>
        _cyhal_clock_update_system_state(true, old_freq, new_freq);
10006656:	4622      	mov	r2, r4
10006658:	4629      	mov	r1, r5
1000665a:	2001      	movs	r0, #1
1000665c:	f7ff fe9e 	bl	1000639c <_cyhal_clock_update_system_state>
    cy_rslt_t rslt = (cy_rslt_t)Cy_SysClk_ClkHfSetDivider(clock->channel, new_div);
10006660:	4631      	mov	r1, r6
10006662:	7878      	ldrb	r0, [r7, #1]
10006664:	f7fe fcb0 	bl	10004fc8 <Cy_SysClk_ClkHfSetDivider>
    if (0 == clock->channel)
10006668:	787b      	ldrb	r3, [r7, #1]
    cy_rslt_t rslt = (cy_rslt_t)Cy_SysClk_ClkHfSetDivider(clock->channel, new_div);
1000666a:	4606      	mov	r6, r0
    if (0 == clock->channel)
1000666c:	b923      	cbnz	r3, 10006678 <_cyhal_clock_set_divider_hf+0x58>
        if (CY_RSLT_SUCCESS == rslt)
1000666e:	b958      	cbnz	r0, 10006688 <_cyhal_clock_set_divider_hf+0x68>
            _cyhal_clock_update_system_state(false, old_freq, new_freq);
10006670:	4622      	mov	r2, r4
10006672:	4629      	mov	r1, r5
            _cyhal_clock_update_system_state(false, new_freq, old_freq);
10006674:	f7ff fe92 	bl	1000639c <_cyhal_clock_update_system_state>
}
10006678:	4630      	mov	r0, r6
1000667a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            new_div = CY_SYSCLK_CLKHF_DIVIDE_BY_4;
1000667c:	2602      	movs	r6, #2
            break;
1000667e:	e7db      	b.n	10006638 <_cyhal_clock_set_divider_hf+0x18>
            new_div = CY_SYSCLK_CLKHF_DIVIDE_BY_8;
10006680:	2603      	movs	r6, #3
            break;
10006682:	e7d9      	b.n	10006638 <_cyhal_clock_set_divider_hf+0x18>
    switch (divider)
10006684:	2601      	movs	r6, #1
10006686:	e7d7      	b.n	10006638 <_cyhal_clock_set_divider_hf+0x18>
            _cyhal_clock_update_system_state(false, new_freq, old_freq);
10006688:	462a      	mov	r2, r5
1000668a:	4621      	mov	r1, r4
1000668c:	4618      	mov	r0, r3
1000668e:	e7f1      	b.n	10006674 <_cyhal_clock_set_divider_hf+0x54>
    switch (divider)
10006690:	4e00      	ldr	r6, [pc, #0]	; (10006694 <_cyhal_clock_set_divider_hf+0x74>)
10006692:	e7f1      	b.n	10006678 <_cyhal_clock_set_divider_hf+0x58>
10006694:	04020200 	.word	0x04020200

10006698 <_cyhal_clock_set_frequency_fll>:
{
10006698:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
1000669c:	b087      	sub	sp, #28
    Cy_SysClk_FllGetConfiguration(&cfg);
1000669e:	a801      	add	r0, sp, #4
{
100066a0:	4689      	mov	r9, r1
    Cy_SysClk_FllGetConfiguration(&cfg);
100066a2:	f7fe fe93 	bl	100053cc <Cy_SysClk_FllGetConfiguration>
    uint32_t src_freq = Cy_SysClk_ClkPathMuxGetFrequency(0);
100066a6:	2000      	movs	r0, #0
100066a8:	f7fe fdb8 	bl	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>
    if (0 == src_freq)
100066ac:	4607      	mov	r7, r0
100066ae:	2800      	cmp	r0, #0
100066b0:	d04d      	beq.n	1000674e <_cyhal_clock_set_frequency_fll+0xb6>
        uint32_t old_freq = CY_SYSLIB_DIV_ROUND((uint64_t)src_freq * (uint64_t)cfg.fllMult, (uint32_t)cfg.refDiv * ((cfg.enableOutputDiv) ? 2UL : 1UL));
100066b2:	f89d 300b 	ldrb.w	r3, [sp, #11]
100066b6:	f8bd 2008 	ldrh.w	r2, [sp, #8]
100066ba:	9d01      	ldr	r5, [sp, #4]
100066bc:	fb03 2202 	mla	r2, r3, r2, r2
100066c0:	2400      	movs	r4, #0
100066c2:	0850      	lsrs	r0, r2, #1
100066c4:	4621      	mov	r1, r4
100066c6:	4623      	mov	r3, r4
100066c8:	fbe7 0105 	umlal	r0, r1, r7, r5
100066cc:	f7fb fe68 	bl	100023a0 <__aeabi_uldivmod>
100066d0:	4606      	mov	r6, r0
        uint32_t div = (uint32_t)Cy_SysClk_ClkHfGetDivider(0);
100066d2:	4620      	mov	r0, r4
100066d4:	f7fe fc96 	bl	10005004 <Cy_SysClk_ClkHfGetDivider>
        uint32_t old_hf_freq = old_freq >> div;
100066d8:	40c6      	lsrs	r6, r0
        uint32_t new_hf_freq = hz /*new_freq*/ >> div;
100066da:	fa29 f500 	lsr.w	r5, r9, r0
        bool fll_sources_hf0 = (0 == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
100066de:	4620      	mov	r0, r4
100066e0:	f7fe fc60 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
        if (fll_sources_hf0)
100066e4:	4680      	mov	r8, r0
100066e6:	b920      	cbnz	r0, 100066f2 <_cyhal_clock_set_frequency_fll+0x5a>
            _cyhal_clock_update_system_state(true, old_hf_freq, new_hf_freq);
100066e8:	462a      	mov	r2, r5
100066ea:	4631      	mov	r1, r6
100066ec:	2001      	movs	r0, #1
100066ee:	f7ff fe55 	bl	1000639c <_cyhal_clock_update_system_state>
        bool enabled = Cy_SysClk_FllIsEnabled();
100066f2:	f7fe fdd1 	bl	10005298 <Cy_SysClk_FllIsEnabled>
        if (enabled)
100066f6:	4602      	mov	r2, r0
100066f8:	b1b8      	cbz	r0, 1000672a <_cyhal_clock_set_frequency_fll+0x92>
            rslt = Cy_SysClk_FllDisable();
100066fa:	f7fe fdd5 	bl	100052a8 <Cy_SysClk_FllDisable>
        if (CY_RSLT_SUCCESS == rslt)
100066fe:	4604      	mov	r4, r0
10006700:	b130      	cbz	r0, 10006710 <_cyhal_clock_set_frequency_fll+0x78>
        if (fll_sources_hf0)
10006702:	f1b8 0f00 	cmp.w	r8, #0
10006706:	d01f      	beq.n	10006748 <_cyhal_clock_set_frequency_fll+0xb0>
}
10006708:	4620      	mov	r0, r4
1000670a:	b007      	add	sp, #28
1000670c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            rslt = Cy_SysClk_FllConfigure(src_freq, hz/*new_freq*/, CY_SYSCLK_FLLPLL_OUTPUT_AUTO);
10006710:	4602      	mov	r2, r0
10006712:	4649      	mov	r1, r9
10006714:	4638      	mov	r0, r7
10006716:	f7fb ffaf 	bl	10002678 <Cy_SysClk_FllConfigure>
1000671a:	4607      	mov	r7, r0
                cy_rslt_t rslt2 = Cy_SysClk_FllEnable(_CYHAL_CLOCK_FLL_LOCK_TIME);
1000671c:	480d      	ldr	r0, [pc, #52]	; (10006754 <_cyhal_clock_set_frequency_fll+0xbc>)
1000671e:	f7fe fe81 	bl	10005424 <Cy_SysClk_FllEnable>
10006722:	4604      	mov	r4, r0
                if (CY_RSLT_SUCCESS == rslt)
10006724:	b137      	cbz	r7, 10006734 <_cyhal_clock_set_frequency_fll+0x9c>
            rslt = Cy_SysClk_FllConfigure(src_freq, hz/*new_freq*/, CY_SYSCLK_FLLPLL_OUTPUT_AUTO);
10006726:	463c      	mov	r4, r7
10006728:	e7eb      	b.n	10006702 <_cyhal_clock_set_frequency_fll+0x6a>
1000672a:	4649      	mov	r1, r9
1000672c:	4638      	mov	r0, r7
1000672e:	f7fb ffa3 	bl	10002678 <Cy_SysClk_FllConfigure>
10006732:	4604      	mov	r4, r0
        if (fll_sources_hf0)
10006734:	f1b8 0f00 	cmp.w	r8, #0
10006738:	d1e6      	bne.n	10006708 <_cyhal_clock_set_frequency_fll+0x70>
            if (CY_RSLT_SUCCESS == rslt)
1000673a:	b92c      	cbnz	r4, 10006748 <_cyhal_clock_set_frequency_fll+0xb0>
                _cyhal_clock_update_system_state(false, old_hf_freq, new_hf_freq);
1000673c:	462a      	mov	r2, r5
1000673e:	4631      	mov	r1, r6
                _cyhal_clock_update_system_state(false, new_hf_freq, old_hf_freq);
10006740:	2000      	movs	r0, #0
10006742:	f7ff fe2b 	bl	1000639c <_cyhal_clock_update_system_state>
10006746:	e7df      	b.n	10006708 <_cyhal_clock_set_frequency_fll+0x70>
10006748:	4632      	mov	r2, r6
1000674a:	4629      	mov	r1, r5
1000674c:	e7f8      	b.n	10006740 <_cyhal_clock_set_frequency_fll+0xa8>
        rslt = CYHAL_CLOCK_RSLT_ERR_SOURCE;
1000674e:	4c02      	ldr	r4, [pc, #8]	; (10006758 <_cyhal_clock_set_frequency_fll+0xc0>)
    return rslt;
10006750:	e7da      	b.n	10006708 <_cyhal_clock_set_frequency_fll+0x70>
10006752:	bf00      	nop
10006754:	00030d40 	.word	0x00030d40
10006758:	04020201 	.word	0x04020201

1000675c <_cyhal_clock_set_enabled_fll>:
{
1000675c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
10006760:	b087      	sub	sp, #28
    Cy_SysClk_FllGetConfiguration(&cfg);
10006762:	a801      	add	r0, sp, #4
{
10006764:	460f      	mov	r7, r1
10006766:	4614      	mov	r4, r2
    Cy_SysClk_FllGetConfiguration(&cfg);
10006768:	f7fe fe30 	bl	100053cc <Cy_SysClk_FllGetConfiguration>
    uint32_t div = (uint32_t)Cy_SysClk_ClkHfGetDivider(0);
1000676c:	2000      	movs	r0, #0
1000676e:	f7fe fc49 	bl	10005004 <Cy_SysClk_ClkHfGetDivider>
10006772:	4606      	mov	r6, r0
    uint32_t src_freq = Cy_SysClk_ClkPathMuxGetFrequency(0);
10006774:	2000      	movs	r0, #0
10006776:	f7fe fd51 	bl	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>
    uint32_t fll_freq = CY_SYSLIB_DIV_ROUND((uint64_t)src_freq * (uint64_t)cfg.fllMult, (uint32_t)cfg.refDiv * ((cfg.enableOutputDiv) ? 2UL : 1UL));
1000677a:	f89d 300b 	ldrb.w	r3, [sp, #11]
1000677e:	f8bd 2008 	ldrh.w	r2, [sp, #8]
10006782:	9d01      	ldr	r5, [sp, #4]
10006784:	fb03 2202 	mla	r2, r3, r2, r2
10006788:	f04f 0900 	mov.w	r9, #0
    uint32_t src_freq = Cy_SysClk_ClkPathMuxGetFrequency(0);
1000678c:	4680      	mov	r8, r0
    uint32_t fll_freq = CY_SYSLIB_DIV_ROUND((uint64_t)src_freq * (uint64_t)cfg.fllMult, (uint32_t)cfg.refDiv * ((cfg.enableOutputDiv) ? 2UL : 1UL));
1000678e:	4649      	mov	r1, r9
10006790:	0850      	lsrs	r0, r2, #1
10006792:	fbe8 0105 	umlal	r0, r1, r8, r5
10006796:	464b      	mov	r3, r9
10006798:	f7fb fe02 	bl	100023a0 <__aeabi_uldivmod>
1000679c:	4605      	mov	r5, r0
    if (enabled)
1000679e:	b1b7      	cbz	r7, 100067ce <_cyhal_clock_set_enabled_fll+0x72>
        new_freq = fll_freq >> div;
100067a0:	fa20 f706 	lsr.w	r7, r0, r6
    bool fll_sources_hf0 = (0 == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
100067a4:	4648      	mov	r0, r9
100067a6:	f7fe fbfd 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
        old_freq = src_freq >> div;
100067aa:	fa28 f506 	lsr.w	r5, r8, r6
    if (fll_sources_hf0)
100067ae:	4606      	mov	r6, r0
100067b0:	b920      	cbnz	r0, 100067bc <_cyhal_clock_set_enabled_fll+0x60>
        _cyhal_clock_update_system_state(true, old_freq, new_freq);
100067b2:	463a      	mov	r2, r7
100067b4:	4629      	mov	r1, r5
100067b6:	2001      	movs	r0, #1
100067b8:	f7ff fdf0 	bl	1000639c <_cyhal_clock_update_system_state>
        ? Cy_SysClk_FllEnable(wait_for_lock ? _CYHAL_CLOCK_FLL_LOCK_TIME : 0UL)
100067bc:	2c00      	cmp	r4, #0
100067be:	4814      	ldr	r0, [pc, #80]	; (10006810 <_cyhal_clock_set_enabled_fll+0xb4>)
100067c0:	bf08      	it	eq
100067c2:	2000      	moveq	r0, #0
100067c4:	f7fe fe2e 	bl	10005424 <Cy_SysClk_FllEnable>
100067c8:	4604      	mov	r4, r0
    if (fll_sources_hf0)
100067ca:	b9ce      	cbnz	r6, 10006800 <_cyhal_clock_set_enabled_fll+0xa4>
100067cc:	e00e      	b.n	100067ec <_cyhal_clock_set_enabled_fll+0x90>
    bool fll_sources_hf0 = (0 == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
100067ce:	4638      	mov	r0, r7
100067d0:	f7fe fbe8 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
    if (fll_sources_hf0)
100067d4:	b988      	cbnz	r0, 100067fa <_cyhal_clock_set_enabled_fll+0x9e>
        new_freq = src_freq >> div;
100067d6:	fa28 f706 	lsr.w	r7, r8, r6
        old_freq = fll_freq >> div;
100067da:	40f5      	lsrs	r5, r6
        _cyhal_clock_update_system_state(true, old_freq, new_freq);
100067dc:	463a      	mov	r2, r7
100067de:	4629      	mov	r1, r5
100067e0:	2001      	movs	r0, #1
100067e2:	f7ff fddb 	bl	1000639c <_cyhal_clock_update_system_state>
        : Cy_SysClk_FllDisable();
100067e6:	f7fe fd5f 	bl	100052a8 <Cy_SysClk_FllDisable>
100067ea:	4604      	mov	r4, r0
        if (CY_RSLT_SUCCESS == rslt)
100067ec:	b964      	cbnz	r4, 10006808 <_cyhal_clock_set_enabled_fll+0xac>
            _cyhal_clock_update_system_state(false, old_freq, new_freq);
100067ee:	463a      	mov	r2, r7
100067f0:	4629      	mov	r1, r5
            _cyhal_clock_update_system_state(false, new_freq, old_freq);
100067f2:	2000      	movs	r0, #0
100067f4:	f7ff fdd2 	bl	1000639c <_cyhal_clock_update_system_state>
    return rslt;
100067f8:	e002      	b.n	10006800 <_cyhal_clock_set_enabled_fll+0xa4>
        : Cy_SysClk_FllDisable();
100067fa:	f7fe fd55 	bl	100052a8 <Cy_SysClk_FllDisable>
100067fe:	4604      	mov	r4, r0
}
10006800:	4620      	mov	r0, r4
10006802:	b007      	add	sp, #28
10006804:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            _cyhal_clock_update_system_state(false, new_freq, old_freq);
10006808:	462a      	mov	r2, r5
1000680a:	4639      	mov	r1, r7
1000680c:	e7f1      	b.n	100067f2 <_cyhal_clock_set_enabled_fll+0x96>
1000680e:	bf00      	nop
10006810:	00030d40 	.word	0x00030d40

10006814 <_cyhal_clock_compute_div>:
{
10006814:	b538      	push	{r3, r4, r5, lr}
    uint32_t max_div = (1 << divider_bits);
10006816:	2501      	movs	r5, #1
10006818:	4095      	lsls	r5, r2
    *div = (input_hz + (desired_hz / 2)) / desired_hz;
1000681a:	eb00 0451 	add.w	r4, r0, r1, lsr #1
1000681e:	fbb4 f4f1 	udiv	r4, r4, r1
10006822:	42a5      	cmp	r5, r4
10006824:	bf28      	it	cs
10006826:	4625      	movcs	r5, r4
10006828:	9c04      	ldr	r4, [sp, #16]
1000682a:	6025      	str	r5, [r4, #0]
        : 0;
1000682c:	461c      	mov	r4, r3
1000682e:	b153      	cbz	r3, 10006846 <_cyhal_clock_compute_div+0x32>
        ? (uint32_t)abs(_cyhal_utils_calculate_tolerance(tolerance->type, desired_hz, input_hz / *div))
10006830:	fbb0 f2f5 	udiv	r2, r0, r5
10006834:	7818      	ldrb	r0, [r3, #0]
10006836:	f000 fc73 	bl	10007120 <_cyhal_utils_calculate_tolerance>
    return ((tolerance != NULL) && (diff > tolerance->value))
1000683a:	6863      	ldr	r3, [r4, #4]
1000683c:	2800      	cmp	r0, #0
1000683e:	bfb8      	it	lt
10006840:	4240      	neglt	r0, r0
10006842:	4283      	cmp	r3, r0
10006844:	d301      	bcc.n	1000684a <_cyhal_clock_compute_div+0x36>
        : CY_RSLT_SUCCESS;
10006846:	2000      	movs	r0, #0
}
10006848:	bd38      	pop	{r3, r4, r5, pc}
        : CY_RSLT_SUCCESS;
1000684a:	4801      	ldr	r0, [pc, #4]	; (10006850 <_cyhal_clock_compute_div+0x3c>)
1000684c:	e7fc      	b.n	10006848 <_cyhal_clock_compute_div+0x34>
1000684e:	bf00      	nop
10006850:	04020200 	.word	0x04020200

10006854 <_cyhal_clock_set_source_timer>:
{
10006854:	b508      	push	{r3, lr}
    if (source->block == CYHAL_CLOCK_BLOCK_IMO)
10006856:	780b      	ldrb	r3, [r1, #0]
10006858:	2b04      	cmp	r3, #4
1000685a:	d104      	bne.n	10006866 <_cyhal_clock_set_source_timer+0x12>
        Cy_SysClk_ClkTimerSetSource(CY_SYSCLK_CLKTIMER_IN_IMO);
1000685c:	2000      	movs	r0, #0
        Cy_SysClk_ClkTimerSetSource(CY_SYSCLK_CLKTIMER_IN_HF0_NODIV);
1000685e:	f7fe fab7 	bl	10004dd0 <Cy_SysClk_ClkTimerSetSource>
        return CY_RSLT_SUCCESS;
10006862:	2000      	movs	r0, #0
}
10006864:	bd08      	pop	{r3, pc}
    else if (source->block == CYHAL_CLOCK_BLOCK_HF && source->channel == 0)
10006866:	880b      	ldrh	r3, [r1, #0]
10006868:	2b12      	cmp	r3, #18
1000686a:	d101      	bne.n	10006870 <_cyhal_clock_set_source_timer+0x1c>
        Cy_SysClk_ClkTimerSetSource(CY_SYSCLK_CLKTIMER_IN_HF0_NODIV);
1000686c:	2001      	movs	r0, #1
1000686e:	e7f6      	b.n	1000685e <_cyhal_clock_set_source_timer+0xa>
    return CYHAL_CLOCK_RSLT_ERR_SOURCE;
10006870:	4800      	ldr	r0, [pc, #0]	; (10006874 <_cyhal_clock_set_source_timer+0x20>)
10006872:	e7f7      	b.n	10006864 <_cyhal_clock_set_source_timer+0x10>
10006874:	04020201 	.word	0x04020201

10006878 <_cyhal_clock_set_divider_timer>:
    if (divider <= 256)
10006878:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
{
1000687c:	b508      	push	{r3, lr}
    if (divider <= 256)
1000687e:	d805      	bhi.n	1000688c <_cyhal_clock_set_divider_timer+0x14>
        uint32_t divVal = divider - 1;
10006880:	3901      	subs	r1, #1
        Cy_SysClk_ClkTimerSetDivider((uint8_t)divVal);
10006882:	b2c8      	uxtb	r0, r1
10006884:	f7fe faba 	bl	10004dfc <Cy_SysClk_ClkTimerSetDivider>
        return CY_RSLT_SUCCESS;
10006888:	2000      	movs	r0, #0
}
1000688a:	bd08      	pop	{r3, pc}
    return CYHAL_CLOCK_RSLT_ERR_FREQ;
1000688c:	4800      	ldr	r0, [pc, #0]	; (10006890 <_cyhal_clock_set_divider_timer+0x18>)
1000688e:	e7fc      	b.n	1000688a <_cyhal_clock_set_divider_timer+0x12>
10006890:	04020200 	.word	0x04020200

10006894 <_cyhal_clock_set_enabled_eco>:
{
10006894:	b510      	push	{r4, lr}
    if (enabled)
10006896:	b309      	cbz	r1, 100068dc <_cyhal_clock_set_enabled_eco+0x48>
        if (0u != (SRSS_CLK_ECO_CONFIG & SRSS_CLK_ECO_CONFIG_ECO_EN_Msk))
10006898:	4b12      	ldr	r3, [pc, #72]	; (100068e4 <_cyhal_clock_set_enabled_eco+0x50>)
1000689a:	f8d3 352c 	ldr.w	r3, [r3, #1324]	; 0x52c
1000689e:	2b00      	cmp	r3, #0
100068a0:	da13      	bge.n	100068ca <_cyhal_clock_set_enabled_eco+0x36>
            if (wait_for_lock)
100068a2:	b90a      	cbnz	r2, 100068a8 <_cyhal_clock_set_enabled_eco+0x14>
            return CY_RSLT_SUCCESS;
100068a4:	2000      	movs	r0, #0
100068a6:	e00f      	b.n	100068c8 <_cyhal_clock_set_enabled_eco+0x34>
100068a8:	2403      	movs	r4, #3
                for (int t = 0; t < 3 && Cy_SysClk_EcoGetStatus() != CY_SYSCLK_ECOSTAT_STABLE; ++t)
100068aa:	f7fe fc27 	bl	100050fc <Cy_SysClk_EcoGetStatus>
100068ae:	2802      	cmp	r0, #2
100068b0:	d005      	beq.n	100068be <_cyhal_clock_set_enabled_eco+0x2a>
                    cyhal_system_delay_us(1000UL);
100068b2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
100068b6:	f7ff f895 	bl	100059e4 <Cy_SysLib_DelayUs>
                for (int t = 0; t < 3 && Cy_SysClk_EcoGetStatus() != CY_SYSCLK_ECOSTAT_STABLE; ++t)
100068ba:	3c01      	subs	r4, #1
100068bc:	d1f5      	bne.n	100068aa <_cyhal_clock_set_enabled_eco+0x16>
                return Cy_SysClk_EcoGetStatus() == CY_SYSCLK_ECOSTAT_STABLE
100068be:	f7fe fc1d 	bl	100050fc <Cy_SysClk_EcoGetStatus>
                    : CY_SYSCLK_TIMEOUT;
100068c2:	2802      	cmp	r0, #2
100068c4:	d0ee      	beq.n	100068a4 <_cyhal_clock_set_enabled_eco+0x10>
100068c6:	4808      	ldr	r0, [pc, #32]	; (100068e8 <_cyhal_clock_set_enabled_eco+0x54>)
}
100068c8:	bd10      	pop	{r4, pc}
            return Cy_SysClk_EcoEnable(wait_for_lock ? 3000UL : 0UL);
100068ca:	2a00      	cmp	r2, #0
100068cc:	f640 30b8 	movw	r0, #3000	; 0xbb8
}
100068d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            return Cy_SysClk_EcoEnable(wait_for_lock ? 3000UL : 0UL);
100068d4:	bf08      	it	eq
100068d6:	2000      	moveq	r0, #0
100068d8:	f7fe bc20 	b.w	1000511c <Cy_SysClk_EcoEnable>
        Cy_SysClk_EcoDisable();
100068dc:	f7fe fc04 	bl	100050e8 <Cy_SysClk_EcoDisable>
        return CY_RSLT_SUCCESS;
100068e0:	e7e0      	b.n	100068a4 <_cyhal_clock_set_enabled_eco+0x10>
100068e2:	bf00      	nop
100068e4:	40260000 	.word	0x40260000
100068e8:	004a0002 	.word	0x004a0002

100068ec <_cyhal_clock_set_enabled_wco>:
{
100068ec:	b508      	push	{r3, lr}
100068ee:	4610      	mov	r0, r2
    if (enabled)
100068f0:	b149      	cbz	r1, 10006906 <_cyhal_clock_set_enabled_wco+0x1a>
        cy_rslt_t rslt = Cy_SysClk_WcoEnable(wait_for_lock ? 1000000UL : 0UL);
100068f2:	b122      	cbz	r2, 100068fe <_cyhal_clock_set_enabled_wco+0x12>
}
100068f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        cy_rslt_t rslt = Cy_SysClk_WcoEnable(wait_for_lock ? 1000000UL : 0UL);
100068f8:	4804      	ldr	r0, [pc, #16]	; (1000690c <_cyhal_clock_set_enabled_wco+0x20>)
100068fa:	f7fe bb9d 	b.w	10005038 <Cy_SysClk_WcoEnable>
100068fe:	f7fe fb9b 	bl	10005038 <Cy_SysClk_WcoEnable>
}
10006902:	2000      	movs	r0, #0
10006904:	bd08      	pop	{r3, pc}
        Cy_SysClk_WcoDisable();
10006906:	f7fe fbb3 	bl	10005070 <Cy_SysClk_WcoDisable>
        return CY_RSLT_SUCCESS;
1000690a:	e7fa      	b.n	10006902 <_cyhal_clock_set_enabled_wco+0x16>
1000690c:	000f4240 	.word	0x000f4240

10006910 <_cyhal_clock_set_divider_fast>:
    if (divider <= 256)
10006910:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
{
10006914:	b508      	push	{r3, lr}
    if (divider <= 256)
10006916:	d807      	bhi.n	10006928 <_cyhal_clock_set_divider_fast+0x18>
        uint32_t divVal = divider - 1;
10006918:	3901      	subs	r1, #1
        Cy_SysClk_ClkFastSetDivider((uint8_t)divVal);
1000691a:	b2c8      	uxtb	r0, r1
1000691c:	f7fe fac6 	bl	10004eac <Cy_SysClk_ClkFastSetDivider>
        SystemCoreClockUpdate();
10006920:	f7fd fb72 	bl	10004008 <SystemCoreClockUpdate>
10006924:	2000      	movs	r0, #0
}
10006926:	bd08      	pop	{r3, pc}
    return CYHAL_CLOCK_RSLT_ERR_FREQ;
10006928:	4800      	ldr	r0, [pc, #0]	; (1000692c <_cyhal_clock_set_divider_fast+0x1c>)
1000692a:	e7fc      	b.n	10006926 <_cyhal_clock_set_divider_fast+0x16>
1000692c:	04020200 	.word	0x04020200

10006930 <_cyhal_clock_set_divider_peri>:
    if (divider <= 256)
10006930:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
{
10006934:	b508      	push	{r3, lr}
    if (divider <= 256)
10006936:	d807      	bhi.n	10006948 <_cyhal_clock_set_divider_peri+0x18>
        uint32_t divVal = divider - 1;
10006938:	3901      	subs	r1, #1
        Cy_SysClk_ClkPeriSetDivider((uint8_t)divVal);
1000693a:	b2c8      	uxtb	r0, r1
1000693c:	f7fe fa9e 	bl	10004e7c <Cy_SysClk_ClkPeriSetDivider>
        SystemCoreClockUpdate();
10006940:	f7fd fb62 	bl	10004008 <SystemCoreClockUpdate>
10006944:	2000      	movs	r0, #0
}
10006946:	bd08      	pop	{r3, pc}
    return CYHAL_CLOCK_RSLT_ERR_FREQ;
10006948:	4800      	ldr	r0, [pc, #0]	; (1000694c <_cyhal_clock_set_divider_peri+0x1c>)
1000694a:	e7fc      	b.n	10006946 <_cyhal_clock_set_divider_peri+0x16>
1000694c:	04020200 	.word	0x04020200

10006950 <_cyhal_clock_set_divider_slow>:
    if (divider <= 256)
10006950:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
{
10006954:	b508      	push	{r3, lr}
    if (divider <= 256)
10006956:	d807      	bhi.n	10006968 <_cyhal_clock_set_divider_slow+0x18>
        uint32_t divVal = divider - 1;
10006958:	3901      	subs	r1, #1
        Cy_SysClk_ClkSlowSetDivider((uint8_t)divVal);
1000695a:	b2c8      	uxtb	r0, r1
1000695c:	f7fe f9b6 	bl	10004ccc <Cy_SysClk_ClkSlowSetDivider>
        SystemCoreClockUpdate();
10006960:	f7fd fb52 	bl	10004008 <SystemCoreClockUpdate>
10006964:	2000      	movs	r0, #0
}
10006966:	bd08      	pop	{r3, pc}
    return CYHAL_CLOCK_RSLT_ERR_FREQ;
10006968:	4800      	ldr	r0, [pc, #0]	; (1000696c <_cyhal_clock_set_divider_slow+0x1c>)
1000696a:	e7fc      	b.n	10006966 <_cyhal_clock_set_divider_slow+0x16>
1000696c:	04020200 	.word	0x04020200

10006970 <_cyhal_clock_get_sources_peripheral>:
    // blocks 0b00 & 0b01 are integer, 0b10 & 0b11 are fractional
    return ((clock->block & 0x02) == 0)
        ? _cyhal_utils_peri_pclk_set_divider(_CYHAL_CLOCK_GET_PCLK_GR_NUM(clock->block), clock, divider - 1)
        : _cyhal_utils_peri_pclk_set_frac_divider(_CYHAL_CLOCK_GET_PCLK_GR_NUM(clock->block), clock, divider - 1, 0);
}
static cy_rslt_t _cyhal_clock_get_sources_peripheral(const cyhal_clock_t *clock, const cyhal_resource_inst_t **sources[], uint32_t *count)
10006970:	4b02      	ldr	r3, [pc, #8]	; (1000697c <_cyhal_clock_get_sources_peripheral+0xc>)
10006972:	600b      	str	r3, [r1, #0]
10006974:	2301      	movs	r3, #1
10006976:	6013      	str	r3, [r2, #0]
10006978:	2000      	movs	r0, #0
1000697a:	4770      	bx	lr
1000697c:	08002900 	.word	0x08002900

10006980 <_cyhal_clock_get_funcs_peripheral>:
#endif
// HF and peripheral functions are called directly from the public APIs and do not go through
// the struct lookup. This allows them to get optimized out based on what the user calls. We
// return FUNCS_EMPTY here so as to avoid unnecessarily pulling in all functions for those clocks.
const void* _cyhal_clock_get_funcs_hf(void) { return &FUNCS_EMPTY/*FUNCS_HF*/; }
const void* _cyhal_clock_get_funcs_peripheral(void) { return &FUNCS_EMPTY/*FUNCS_PERIPHERAL*/; }
10006980:	4800      	ldr	r0, [pc, #0]	; (10006984 <_cyhal_clock_get_funcs_peripheral+0x4>)
10006982:	4770      	bx	lr
10006984:	1000952c 	.word	0x1000952c

10006988 <_cyhal_clock_allocate_channel>:
/******************************************************************************
 **************************** Public API (clocks) *****************************
 *****************************************************************************/

cy_rslt_t _cyhal_clock_allocate_channel(cyhal_clock_t *clock, cyhal_clock_block_t block, const void* funcs)
{
10006988:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
1000698c:	4604      	mov	r4, r0
    uint8_t maxChannels = (uint8_t)_cyhal_utils_get_clock_count(block);
1000698e:	4608      	mov	r0, r1
{
10006990:	460d      	mov	r5, r1
10006992:	4690      	mov	r8, r2
    uint8_t maxChannels = (uint8_t)_cyhal_utils_get_clock_count(block);
10006994:	f000 fbe6 	bl	10007164 <_cyhal_utils_get_clock_count>
    for (uint8_t i = 0; i < maxChannels; i++)
10006998:	f04f 0900 	mov.w	r9, #0
    uint8_t maxChannels = (uint8_t)_cyhal_utils_get_clock_count(block);
1000699c:	b2c7      	uxtb	r7, r0
    {
        cyhal_resource_inst_t clock_resource = { CYHAL_RSC_CLOCK, block, i };
1000699e:	f04f 0a05 	mov.w	sl, #5
100069a2:	fa5f f689 	uxtb.w	r6, r9
    for (uint8_t i = 0; i < maxChannels; i++)
100069a6:	42b7      	cmp	r7, r6
100069a8:	d801      	bhi.n	100069ae <_cyhal_clock_allocate_channel+0x26>
            clock->reserved = true;
            clock->funcs = funcs;
            return CY_RSLT_SUCCESS;
        }
    }
    return CYHAL_HWMGR_RSLT_ERR_NONE_FREE;
100069aa:	480c      	ldr	r0, [pc, #48]	; (100069dc <_cyhal_clock_allocate_channel+0x54>)
100069ac:	e012      	b.n	100069d4 <_cyhal_clock_allocate_channel+0x4c>
        if (CY_RSLT_SUCCESS == cyhal_hwmgr_reserve(&clock_resource))
100069ae:	a801      	add	r0, sp, #4
        cyhal_resource_inst_t clock_resource = { CYHAL_RSC_CLOCK, block, i };
100069b0:	f88d a004 	strb.w	sl, [sp, #4]
100069b4:	f88d 5005 	strb.w	r5, [sp, #5]
100069b8:	f88d 6006 	strb.w	r6, [sp, #6]
        if (CY_RSLT_SUCCESS == cyhal_hwmgr_reserve(&clock_resource))
100069bc:	f000 fa40 	bl	10006e40 <cyhal_hwmgr_reserve>
100069c0:	f109 0901 	add.w	r9, r9, #1
100069c4:	2800      	cmp	r0, #0
100069c6:	d1ec      	bne.n	100069a2 <_cyhal_clock_allocate_channel+0x1a>
            clock->reserved = true;
100069c8:	2301      	movs	r3, #1
            clock->block = block;
100069ca:	7025      	strb	r5, [r4, #0]
            clock->channel = i;
100069cc:	7066      	strb	r6, [r4, #1]
            clock->reserved = true;
100069ce:	70a3      	strb	r3, [r4, #2]
            clock->funcs = funcs;
100069d0:	f8c4 8004 	str.w	r8, [r4, #4]
}
100069d4:	b002      	add	sp, #8
100069d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
100069da:	bf00      	nop
100069dc:	04020d02 	.word	0x04020d02

100069e0 <cyhal_clock_get>:

cy_rslt_t cyhal_clock_get(cyhal_clock_t *clock, const cyhal_resource_inst_t *resource)
{
    CY_ASSERT(NULL != clock);
100069e0:	b900      	cbnz	r0, 100069e4 <cyhal_clock_get+0x4>
100069e2:	be01      	bkpt	0x0001
    CY_ASSERT(NULL != resource);
100069e4:	b901      	cbnz	r1, 100069e8 <cyhal_clock_get+0x8>
100069e6:	be01      	bkpt	0x0001
    CY_ASSERT(CYHAL_RSC_CLOCK == resource->type);
100069e8:	780b      	ldrb	r3, [r1, #0]
100069ea:	2b05      	cmp	r3, #5
100069ec:	d000      	beq.n	100069f0 <cyhal_clock_get+0x10>
100069ee:	be01      	bkpt	0x0001

    clock->block = (cyhal_clock_block_t)resource->block_num;
100069f0:	784b      	ldrb	r3, [r1, #1]
100069f2:	7003      	strb	r3, [r0, #0]
    clock->channel = resource->channel_num;
100069f4:	788b      	ldrb	r3, [r1, #2]
100069f6:	7043      	strb	r3, [r0, #1]
    clock->reserved = false;
100069f8:	2300      	movs	r3, #0
100069fa:	7083      	strb	r3, [r0, #2]
	switch (block)
100069fc:	784b      	ldrb	r3, [r1, #1]
100069fe:	3b04      	subs	r3, #4
10006a00:	b2db      	uxtb	r3, r3
10006a02:	2b15      	cmp	r3, #21
10006a04:	bf96      	itet	ls
10006a06:	4a03      	ldrls	r2, [pc, #12]	; (10006a14 <cyhal_clock_get+0x34>)
    clock->funcs = _cyhal_clock_get_funcs_all((cyhal_clock_block_t)resource->block_num);
10006a08:	4b03      	ldrhi	r3, [pc, #12]	; (10006a18 <cyhal_clock_get+0x38>)
10006a0a:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
10006a0e:	6043      	str	r3, [r0, #4]

    return CY_RSLT_SUCCESS;
}
10006a10:	2000      	movs	r0, #0
10006a12:	4770      	bx	lr
10006a14:	10009454 	.word	0x10009454
10006a18:	1000954c 	.word	0x1000954c

10006a1c <cyhal_clock_set_frequency>:
    return 0;
}

cy_rslt_t cyhal_clock_set_frequency(cyhal_clock_t *clock, uint32_t hz, const cyhal_clock_tolerance_t *tolerance)
{
    CY_ASSERT(NULL != clock);
10006a1c:	b900      	cbnz	r0, 10006a20 <cyhal_clock_set_frequency+0x4>
10006a1e:	be01      	bkpt	0x0001

    if (clock->block == CYHAL_CLOCK_BLOCK_HF)
10006a20:	7803      	ldrb	r3, [r0, #0]
10006a22:	2b12      	cmp	r3, #18
10006a24:	d006      	beq.n	10006a34 <cyhal_clock_set_frequency+0x18>
        return _cyhal_clock_set_frequency_unsupported(clock, hz, tolerance);
    else if (clock->block < 4 * _CYHAL_CLOCK_PERI_GROUPS)
10006a26:	2b03      	cmp	r3, #3
10006a28:	d801      	bhi.n	10006a2e <cyhal_clock_set_frequency+0x12>
        return _cyhal_clock_set_frequency_peripheral(clock, hz, tolerance);
10006a2a:	f002 b8ab 	b.w	10008b84 <_cyhal_clock_set_frequency_peripheral>
    else
        return ((cyhal_clock_funcs_t*)clock->funcs)->set_frequency(clock, hz, tolerance);
10006a2e:	6843      	ldr	r3, [r0, #4]
10006a30:	68db      	ldr	r3, [r3, #12]
10006a32:	4718      	bx	r3
10006a34:	be01      	bkpt	0x0001
}
10006a36:	4801      	ldr	r0, [pc, #4]	; (10006a3c <cyhal_clock_set_frequency+0x20>)
10006a38:	4770      	bx	lr
10006a3a:	bf00      	nop
10006a3c:	04020202 	.word	0x04020202

10006a40 <cyhal_clock_set_source>:
        return ((cyhal_clock_funcs_t*)clock->funcs)->get_sources(clock, sources, count);
}

cy_rslt_t cyhal_clock_set_source(cyhal_clock_t *clock, const cyhal_clock_t *source)
{
    CY_ASSERT(NULL != clock && NULL != source);
10006a40:	b100      	cbz	r0, 10006a44 <cyhal_clock_set_source+0x4>
10006a42:	b901      	cbnz	r1, 10006a46 <cyhal_clock_set_source+0x6>
10006a44:	be01      	bkpt	0x0001

    if (clock->block == CYHAL_CLOCK_BLOCK_HF)
10006a46:	7803      	ldrb	r3, [r0, #0]
10006a48:	2b12      	cmp	r3, #18
10006a4a:	d101      	bne.n	10006a50 <cyhal_clock_set_source+0x10>
        return _cyhal_clock_set_source_hf(clock, source);
10006a4c:	f7ff bdae 	b.w	100065ac <_cyhal_clock_set_source_hf>
    else if (clock->block < 4 * _CYHAL_CLOCK_PERI_GROUPS)
10006a50:	2b03      	cmp	r3, #3
10006a52:	d902      	bls.n	10006a5a <cyhal_clock_set_source+0x1a>
        return _cyhal_clock_set_source_unsupported(clock, source);
    else
        return ((cyhal_clock_funcs_t*)clock->funcs)->set_source(clock, source);
10006a54:	6843      	ldr	r3, [r0, #4]
10006a56:	699b      	ldr	r3, [r3, #24]
10006a58:	4718      	bx	r3
10006a5a:	be01      	bkpt	0x0001
}
10006a5c:	4800      	ldr	r0, [pc, #0]	; (10006a60 <cyhal_clock_set_source+0x20>)
10006a5e:	4770      	bx	lr
10006a60:	04020202 	.word	0x04020202

10006a64 <Cy_GPIO_PortToAddr>:
10006a64:	4a04      	ldr	r2, [pc, #16]	; (10006a78 <Cy_GPIO_PortToAddr+0x14>)
10006a66:	6812      	ldr	r2, [r2, #0]
{
10006a68:	4603      	mov	r3, r0
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
10006a6a:	6990      	ldr	r0, [r2, #24]
    if(portNum < (uint32_t)IOSS_GPIO_GPIO_PORT_NR)
10006a6c:	2b0e      	cmp	r3, #14
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
10006a6e:	bf98      	it	ls
10006a70:	eb00 10c3 	addls.w	r0, r0, r3, lsl #7
        /* Error: Return default base address */
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE);
    }

    return (portBase);
}
10006a74:	4770      	bx	lr
10006a76:	bf00      	nop
10006a78:	08003550 	.word	0x08003550

10006a7c <_cyhal_gpio_irq_handler>:
/*******************************************************************************
*       Internal Interrupt Service Routine
*******************************************************************************/

static void _cyhal_gpio_irq_handler(void)
{
10006a7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
10006a80:	f3ef 8505 	mrs	r5, IPSR
    IRQn_Type irqn = _CYHAL_UTILS_GET_CURRENT_IRQN();
10006a84:	3d10      	subs	r5, #16
    uint32_t port = (uint32_t)(irqn - ioss_interrupts_gpio_0_IRQn);
10006a86:	b22d      	sxth	r5, r5
    uint32_t intr_cause = 1 << port;
10006a88:	f04f 0801 	mov.w	r8, #1

    while(intr_cause != 0)
    {
        uint32_t curr_port = (uint32_t) (31U - __CLZ(intr_cause));
        GPIO_PRT_Type *portAddr = Cy_GPIO_PortToAddr(curr_port);
        cyhal_gpio_callback_data_t* cb_data = _cyhal_gpio_callbacks[curr_port];
10006a8c:	f8df 9078 	ldr.w	r9, [pc, #120]	; 10006b08 <_cyhal_gpio_irq_handler+0x8c>
    uint32_t intr_cause = 1 << port;
10006a90:	fa08 f505 	lsl.w	r5, r8, r5
    while(intr_cause != 0)
10006a94:	b90d      	cbnz	r5, 10006a9a <_cyhal_gpio_irq_handler+0x1e>
        {
            Cy_GPIO_ClearInterrupt(portAddr, i);
        }
        intr_cause &= ~(1 << curr_port);
    }
}
10006a96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  return __builtin_clz(value);
10006a9a:	fab5 f685 	clz	r6, r5
        uint32_t curr_port = (uint32_t) (31U - __CLZ(intr_cause));
10006a9e:	f1c6 061f 	rsb	r6, r6, #31
        GPIO_PRT_Type *portAddr = Cy_GPIO_PortToAddr(curr_port);
10006aa2:	4630      	mov	r0, r6
10006aa4:	f7ff ffde 	bl	10006a64 <Cy_GPIO_PortToAddr>
        cyhal_gpio_callback_data_t* cb_data = _cyhal_gpio_callbacks[curr_port];
10006aa8:	f859 4026 	ldr.w	r4, [r9, r6, lsl #2]
        GPIO_PRT_Type *portAddr = Cy_GPIO_PortToAddr(curr_port);
10006aac:	4607      	mov	r7, r0
        while (NULL != cb_data)
10006aae:	b95c      	cbnz	r4, 10006ac8 <_cyhal_gpio_irq_handler+0x4c>
            Cy_GPIO_ClearInterrupt(portAddr, i);
10006ab0:	4621      	mov	r1, r4
10006ab2:	4638      	mov	r0, r7
        for (uint8_t i = 0; i < CY_GPIO_PINS_MAX; i++)
10006ab4:	3401      	adds	r4, #1
            Cy_GPIO_ClearInterrupt(portAddr, i);
10006ab6:	f001 fd26 	bl	10008506 <Cy_GPIO_ClearInterrupt>
        for (uint8_t i = 0; i < CY_GPIO_PINS_MAX; i++)
10006aba:	2c08      	cmp	r4, #8
10006abc:	d1f8      	bne.n	10006ab0 <_cyhal_gpio_irq_handler+0x34>
        intr_cause &= ~(1 << curr_port);
10006abe:	fa08 f606 	lsl.w	r6, r8, r6
10006ac2:	ea25 0506 	bic.w	r5, r5, r6
10006ac6:	e7e5      	b.n	10006a94 <_cyhal_gpio_irq_handler+0x18>
            uint8_t pin = CYHAL_GET_PIN(cb_data->pin);
10006ac8:	f894 a00c 	ldrb.w	sl, [r4, #12]
            if (Cy_GPIO_GetInterruptStatusMasked(portAddr, pin))
10006acc:	f00a 0a07 	and.w	sl, sl, #7
10006ad0:	4651      	mov	r1, sl
10006ad2:	4638      	mov	r0, r7
10006ad4:	f001 fd33 	bl	1000853e <Cy_GPIO_GetInterruptStatusMasked>
10006ad8:	b158      	cbz	r0, 10006af2 <_cyhal_gpio_irq_handler+0x76>
                cyhal_gpio_event_t event, edge = (cyhal_gpio_event_t)Cy_GPIO_GetInterruptEdge(portAddr, pin);
10006ada:	4651      	mov	r1, sl
10006adc:	4638      	mov	r0, r7
10006ade:	f7fd fd41 	bl	10004564 <Cy_GPIO_GetInterruptEdge>
                switch (edge)
10006ae2:	b2c3      	uxtb	r3, r0
10006ae4:	1e5a      	subs	r2, r3, #1
10006ae6:	2a01      	cmp	r2, #1
10006ae8:	d805      	bhi.n	10006af6 <_cyhal_gpio_irq_handler+0x7a>
                cyhal_gpio_event_t event, edge = (cyhal_gpio_event_t)Cy_GPIO_GetInterruptEdge(portAddr, pin);
10006aea:	4619      	mov	r1, r3
                cb_data->callback(cb_data->callback_arg, event);
10006aec:	e9d4 2000 	ldrd	r2, r0, [r4]
10006af0:	4790      	blx	r2
            cb_data = cb_data->next;
10006af2:	68a4      	ldr	r4, [r4, #8]
10006af4:	e7db      	b.n	10006aae <_cyhal_gpio_irq_handler+0x32>
                        event = (Cy_GPIO_Read(portAddr, pin) != 0) ? CYHAL_GPIO_IRQ_RISE : CYHAL_GPIO_IRQ_FALL;
10006af6:	4651      	mov	r1, sl
10006af8:	4638      	mov	r0, r7
10006afa:	f001 fce6 	bl	100084ca <Cy_GPIO_Read>
10006afe:	2800      	cmp	r0, #0
10006b00:	bf0c      	ite	eq
10006b02:	2102      	moveq	r1, #2
10006b04:	2101      	movne	r1, #1
10006b06:	e7f1      	b.n	10006aec <_cyhal_gpio_irq_handler+0x70>
10006b08:	08003760 	.word	0x08003760

10006b0c <cyhal_gpio_register_callback>:

    return CY_RSLT_SUCCESS;
}

void cyhal_gpio_register_callback(cyhal_gpio_t pin, cyhal_gpio_callback_data_t* callback_data)
{
10006b0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10006b0e:	4605      	mov	r5, r0
10006b10:	460c      	mov	r4, r1
    uint32_t savedIntrStatus = cyhal_system_critical_section_enter();
10006b12:	f7fb fbee 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>

    // Remove if already registered;
    cyhal_gpio_callback_data_t** ptr = &(_cyhal_gpio_callbacks[CYHAL_GET_PORT(pin)]);
10006b16:	4a0f      	ldr	r2, [pc, #60]	; (10006b54 <cyhal_gpio_register_callback+0x48>)
10006b18:	08e9      	lsrs	r1, r5, #3
10006b1a:	eb02 0681 	add.w	r6, r2, r1, lsl #2
10006b1e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    while (NULL != *ptr)
10006b22:	b12b      	cbz	r3, 10006b30 <cyhal_gpio_register_callback+0x24>
    {
        if ((*ptr)->pin == pin)
10006b24:	f893 c00c 	ldrb.w	ip, [r3, #12]
        {
            *ptr = (*ptr)->next;
10006b28:	689f      	ldr	r7, [r3, #8]
        if ((*ptr)->pin == pin)
10006b2a:	45ac      	cmp	ip, r5
10006b2c:	d10e      	bne.n	10006b4c <cyhal_gpio_register_callback+0x40>
            *ptr = (*ptr)->next;
10006b2e:	6037      	str	r7, [r6, #0]
            break;
        }
        ptr = &((*ptr)->next);
    }
    // Add if requested
    if (NULL != callback_data)
10006b30:	b144      	cbz	r4, 10006b44 <cyhal_gpio_register_callback+0x38>
    {
        CY_ASSERT(NULL != callback_data->callback);
10006b32:	6823      	ldr	r3, [r4, #0]
10006b34:	b903      	cbnz	r3, 10006b38 <cyhal_gpio_register_callback+0x2c>
10006b36:	be01      	bkpt	0x0001
        callback_data->pin = pin;
10006b38:	7325      	strb	r5, [r4, #12]
        callback_data->next = _cyhal_gpio_callbacks[CYHAL_GET_PORT(pin)];
10006b3a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
10006b3e:	60a3      	str	r3, [r4, #8]
        _cyhal_gpio_callbacks[CYHAL_GET_PORT(pin)] = callback_data;
10006b40:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
    }

    cyhal_system_critical_section_exit(savedIntrStatus);
}
10006b44:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    cyhal_system_critical_section_exit(savedIntrStatus);
10006b48:	f7fb bbd7 	b.w	100022fa <Cy_SysLib_ExitCriticalSection>
        ptr = &((*ptr)->next);
10006b4c:	f103 0608 	add.w	r6, r3, #8
            *ptr = (*ptr)->next;
10006b50:	463b      	mov	r3, r7
10006b52:	e7e6      	b.n	10006b22 <cyhal_gpio_register_callback+0x16>
10006b54:	08003760 	.word	0x08003760

10006b58 <cyhal_gpio_enable_event>:

void cyhal_gpio_enable_event(cyhal_gpio_t pin, cyhal_gpio_event_t event, uint8_t intr_priority, bool enable)
{
10006b58:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    Cy_GPIO_ClearInterrupt(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin));
10006b5c:	08c6      	lsrs	r6, r0, #3
{
10006b5e:	4605      	mov	r5, r0
    Cy_GPIO_ClearInterrupt(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin));
10006b60:	f005 0507 	and.w	r5, r5, #7
10006b64:	4630      	mov	r0, r6
{
10006b66:	461f      	mov	r7, r3
10006b68:	4614      	mov	r4, r2
10006b6a:	4688      	mov	r8, r1
    Cy_GPIO_ClearInterrupt(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin));
10006b6c:	f7ff ff7a 	bl	10006a64 <Cy_GPIO_PortToAddr>
10006b70:	4629      	mov	r1, r5
10006b72:	f001 fcc8 	bl	10008506 <Cy_GPIO_ClearInterrupt>
#if defined(COMPONENT_CAT1A) || defined(COMPONENT_CAT1B)
    Cy_GPIO_SetInterruptEdge(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin), (uint32_t)event);
10006b76:	4630      	mov	r0, r6
10006b78:	f7ff ff74 	bl	10006a64 <Cy_GPIO_PortToAddr>
10006b7c:	4629      	mov	r1, r5
10006b7e:	4642      	mov	r2, r8
10006b80:	f7fd fcd6 	bl	10004530 <Cy_GPIO_SetInterruptEdge>
    Cy_GPIO_SetInterruptMask(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin), (uint32_t)enable);
10006b84:	4629      	mov	r1, r5
10006b86:	4630      	mov	r0, r6
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
10006b88:	4d0e      	ldr	r5, [pc, #56]	; (10006bc4 <cyhal_gpio_enable_event+0x6c>)
10006b8a:	f7ff ff6b 	bl	10006a64 <Cy_GPIO_PortToAddr>
10006b8e:	463a      	mov	r2, r7
10006b90:	f001 fcc2 	bl	10008518 <Cy_GPIO_SetInterruptMask>
10006b94:	682b      	ldr	r3, [r5, #0]
10006b96:	40f3      	lsrs	r3, r6
    IRQn_Type irqn = ((ioss_interrupts_gpio_0_IRQn + CYHAL_GET_PORT(pin)) < ioss_interrupt_gpio_IRQn)
                    ? (IRQn_Type)(ioss_interrupts_gpio_0_IRQn + CYHAL_GET_PORT(pin))
                    : (IRQn_Type)(ioss_interrupt_gpio_IRQn);
#endif
    /* Only enable if it's not already enabled */
    if (NVIC_GetEnableIRQ(irqn) == 0)
10006b98:	07db      	lsls	r3, r3, #31
10006b9a:	d40c      	bmi.n	10006bb6 <cyhal_gpio_enable_event+0x5e>
    {
        cy_stc_sysint_t irqCfg = {irqn, intr_priority};

        Cy_SysInt_Init(&irqCfg, _cyhal_gpio_irq_handler);
10006b9c:	490a      	ldr	r1, [pc, #40]	; (10006bc8 <cyhal_gpio_enable_event+0x70>)
    IRQn_Type irqn = (IRQn_Type)(ioss_interrupts_gpio_0_IRQn + CYHAL_GET_PORT(pin));
10006b9e:	f8ad 6000 	strh.w	r6, [sp]
        Cy_SysInt_Init(&irqCfg, _cyhal_gpio_irq_handler);
10006ba2:	4668      	mov	r0, sp
        cy_stc_sysint_t irqCfg = {irqn, intr_priority};
10006ba4:	9401      	str	r4, [sp, #4]
        Cy_SysInt_Init(&irqCfg, _cyhal_gpio_irq_handler);
10006ba6:	f001 f987 	bl	10007eb8 <Cy_SysInt_Init>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
10006baa:	2301      	movs	r3, #1
10006bac:	40b3      	lsls	r3, r6
10006bae:	602b      	str	r3, [r5, #0]
    }
    else
    {
        NVIC_SetPriority(irqn, intr_priority);
    }
}
10006bb0:	b002      	add	sp, #8
10006bb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
10006bb6:	0164      	lsls	r4, r4, #5
10006bb8:	4435      	add	r5, r6
10006bba:	b2e4      	uxtb	r4, r4
10006bbc:	f885 4300 	strb.w	r4, [r5, #768]	; 0x300
10006bc0:	e7f6      	b.n	10006bb0 <cyhal_gpio_enable_event+0x58>
10006bc2:	bf00      	nop
10006bc4:	e000e100 	.word	0xe000e100
10006bc8:	10006a7d 	.word	0x10006a7d

10006bcc <cyhal_gpio_disconnect_digital>:

    return CYHAL_GPIO_RSLT_ERR_NO_OUTPUT_SIGNAL;
}

cy_rslt_t cyhal_gpio_disconnect_digital(cyhal_gpio_t pin, cyhal_source_t source)
{
10006bcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    for(uint8_t i = 0; i < (uint8_t)(sizeof(cyhal_pin_map_peri_tr_io_output)/sizeof(cyhal_resource_pin_mapping_t)); i++)
    {
        cyhal_resource_pin_mapping_t mapping = cyhal_pin_map_peri_tr_io_output[i];
10006bce:	4b12      	ldr	r3, [pc, #72]	; (10006c18 <cyhal_gpio_disconnect_digital+0x4c>)
{
10006bd0:	4605      	mov	r5, r0
10006bd2:	460e      	mov	r6, r1
10006bd4:	2400      	movs	r4, #0
        if(mapping.pin == pin)
10006bd6:	f813 1024 	ldrb.w	r1, [r3, r4, lsl #2]
10006bda:	42a9      	cmp	r1, r5
        cyhal_resource_pin_mapping_t mapping = cyhal_pin_map_peri_tr_io_output[i];
10006bdc:	ea4f 0284 	mov.w	r2, r4, lsl #2
        if(mapping.pin == pin)
10006be0:	d115      	bne.n	10006c0e <cyhal_gpio_disconnect_digital+0x42>
        cyhal_resource_pin_mapping_t mapping = cyhal_pin_map_peri_tr_io_output[i];
10006be2:	4b0e      	ldr	r3, [pc, #56]	; (10006c1c <cyhal_gpio_disconnect_digital+0x50>)
10006be4:	4413      	add	r3, r2
        {
            Cy_GPIO_SetHSIOM(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin), HSIOM_SEL_GPIO);
10006be6:	08e8      	lsrs	r0, r5, #3
        cyhal_resource_pin_mapping_t mapping = cyhal_pin_map_peri_tr_io_output[i];
10006be8:	785f      	ldrb	r7, [r3, #1]
            Cy_GPIO_SetHSIOM(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin), HSIOM_SEL_GPIO);
10006bea:	f005 0107 	and.w	r1, r5, #7
10006bee:	f7ff ff39 	bl	10006a64 <Cy_GPIO_PortToAddr>
10006bf2:	2200      	movs	r2, #0
10006bf4:	f7fd fc14 	bl	10004420 <Cy_GPIO_SetHSIOM>

#if defined(COMPONENT_CAT1A)
            cyhal_dest_t dest = (cyhal_dest_t)(CYHAL_TRIGGER_PERI_TR_IO_OUTPUT0 + mapping.channel_num);
10006bf8:	f107 0143 	add.w	r1, r7, #67	; 0x43
#elif defined(COMPONENT_CAT1B)
            cyhal_dest_t dest = (cyhal_dest_t)(CYHAL_TRIGGER_IOSS_PERI_TR_IO_OUTPUT_OUT0 + mapping.channel_num);
#endif

            cy_rslt_t rslt = _cyhal_disconnect_signal(source, dest);
10006bfc:	b2c9      	uxtb	r1, r1
10006bfe:	4630      	mov	r0, r6
10006c00:	f002 f8bf 	bl	10008d82 <_cyhal_disconnect_signal>
            if (CY_RSLT_SUCCESS == rslt)
10006c04:	b910      	cbnz	r0, 10006c0c <cyhal_gpio_disconnect_digital+0x40>
            {
                _cyhal_gpio_source_signals[i] = CYHAL_TRIGGER_CPUSS_ZERO;
10006c06:	4b06      	ldr	r3, [pc, #24]	; (10006c20 <cyhal_gpio_disconnect_digital+0x54>)
10006c08:	f823 0014 	strh.w	r0, [r3, r4, lsl #1]
            return rslt;
        }
    }

    return CYHAL_GPIO_RSLT_ERR_NO_INPUT_SIGNAL;
}
10006c0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    for(uint8_t i = 0; i < (uint8_t)(sizeof(cyhal_pin_map_peri_tr_io_output)/sizeof(cyhal_resource_pin_mapping_t)); i++)
10006c0e:	3401      	adds	r4, #1
10006c10:	2c06      	cmp	r4, #6
10006c12:	d1e0      	bne.n	10006bd6 <cyhal_gpio_disconnect_digital+0xa>
    return CYHAL_GPIO_RSLT_ERR_NO_INPUT_SIGNAL;
10006c14:	4803      	ldr	r0, [pc, #12]	; (10006c24 <cyhal_gpio_disconnect_digital+0x58>)
10006c16:	e7f9      	b.n	10006c0c <cyhal_gpio_disconnect_digital+0x40>
10006c18:	10009ab3 	.word	0x10009ab3
10006c1c:	10009ab1 	.word	0x10009ab1
10006c20:	080037d0 	.word	0x080037d0
10006c24:	04020900 	.word	0x04020900

10006c28 <cyhal_gpio_disable_output>:

cy_rslt_t cyhal_gpio_disable_output(cyhal_gpio_t pin)
{
    for(uint8_t i = 0; i < (uint8_t)(sizeof(cyhal_pin_map_peri_tr_io_input)/sizeof(cyhal_resource_pin_mapping_t)); i++)
    {
        cyhal_resource_pin_mapping_t mapping = cyhal_pin_map_peri_tr_io_input[i];
10006c28:	4a0b      	ldr	r2, [pc, #44]	; (10006c58 <cyhal_gpio_disable_output+0x30>)
{
10006c2a:	b508      	push	{r3, lr}
10006c2c:	4601      	mov	r1, r0
10006c2e:	2300      	movs	r3, #0
        if(mapping.pin == pin)
10006c30:	f812 0023 	ldrb.w	r0, [r2, r3, lsl #2]
10006c34:	4288      	cmp	r0, r1
10006c36:	d109      	bne.n	10006c4c <cyhal_gpio_disable_output+0x24>
        {
            Cy_GPIO_SetHSIOM(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin), HSIOM_SEL_GPIO);
10006c38:	08c8      	lsrs	r0, r1, #3
10006c3a:	f7ff ff13 	bl	10006a64 <Cy_GPIO_PortToAddr>
10006c3e:	f001 0107 	and.w	r1, r1, #7
10006c42:	2200      	movs	r2, #0
10006c44:	f7fd fbec 	bl	10004420 <Cy_GPIO_SetHSIOM>
10006c48:	2000      	movs	r0, #0
            return CY_RSLT_SUCCESS;
        }
    }

    return CYHAL_GPIO_RSLT_ERR_NO_OUTPUT_SIGNAL;
}
10006c4a:	bd08      	pop	{r3, pc}
    for(uint8_t i = 0; i < (uint8_t)(sizeof(cyhal_pin_map_peri_tr_io_input)/sizeof(cyhal_resource_pin_mapping_t)); i++)
10006c4c:	3301      	adds	r3, #1
10006c4e:	2b1c      	cmp	r3, #28
10006c50:	d1ee      	bne.n	10006c30 <cyhal_gpio_disable_output+0x8>
    return CYHAL_GPIO_RSLT_ERR_NO_OUTPUT_SIGNAL;
10006c52:	4802      	ldr	r0, [pc, #8]	; (10006c5c <cyhal_gpio_disable_output+0x34>)
10006c54:	e7f9      	b.n	10006c4a <cyhal_gpio_disable_output+0x22>
10006c56:	bf00      	nop
10006c58:	10009acb 	.word	0x10009acb
10006c5c:	04020901 	.word	0x04020901

10006c60 <cyhal_gpio_free>:
{
10006c60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (pin != CYHAL_NC_PIN_VALUE)
10006c64:	28ff      	cmp	r0, #255	; 0xff
{
10006c66:	b085      	sub	sp, #20
10006c68:	4604      	mov	r4, r0
    if (pin != CYHAL_NC_PIN_VALUE)
10006c6a:	d035      	beq.n	10006cd8 <cyhal_gpio_free+0x78>
        Cy_GPIO_SetInterruptMask(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin), 0);
10006c6c:	08c7      	lsrs	r7, r0, #3
10006c6e:	4638      	mov	r0, r7
10006c70:	f004 0607 	and.w	r6, r4, #7
10006c74:	f7ff fef6 	bl	10006a64 <Cy_GPIO_PortToAddr>
10006c78:	4631      	mov	r1, r6
10006c7a:	2200      	movs	r2, #0
10006c7c:	f001 fc4c 	bl	10008518 <Cy_GPIO_SetInterruptMask>
        cyhal_gpio_register_callback(pin, NULL);
10006c80:	2100      	movs	r1, #0
10006c82:	4620      	mov	r0, r4
10006c84:	f7ff ff42 	bl	10006b0c <cyhal_gpio_register_callback>
        (void)cyhal_gpio_disable_output(pin);
10006c88:	4620      	mov	r0, r4
10006c8a:	f7ff ffcd 	bl	10006c28 <cyhal_gpio_disable_output>
            cyhal_resource_pin_mapping_t mapping = cyhal_pin_map_peri_tr_io_output[i];
10006c8e:	f8df 8050 	ldr.w	r8, [pc, #80]	; 10006ce0 <cyhal_gpio_free+0x80>
                if (CYHAL_TRIGGER_CPUSS_ZERO != _cyhal_gpio_source_signals[i])
10006c92:	f8df 9050 	ldr.w	r9, [pc, #80]	; 10006ce4 <cyhal_gpio_free+0x84>
        (void)cyhal_gpio_disable_output(pin);
10006c96:	2500      	movs	r5, #0
            if(mapping.pin == pin)
10006c98:	f818 3025 	ldrb.w	r3, [r8, r5, lsl #2]
10006c9c:	42a3      	cmp	r3, r4
10006c9e:	d105      	bne.n	10006cac <cyhal_gpio_free+0x4c>
                if (CYHAL_TRIGGER_CPUSS_ZERO != _cyhal_gpio_source_signals[i])
10006ca0:	f839 1015 	ldrh.w	r1, [r9, r5, lsl #1]
10006ca4:	b111      	cbz	r1, 10006cac <cyhal_gpio_free+0x4c>
                    (void)cyhal_gpio_disconnect_digital(pin, _cyhal_gpio_source_signals[i]);
10006ca6:	4620      	mov	r0, r4
10006ca8:	f7ff ff90 	bl	10006bcc <cyhal_gpio_disconnect_digital>
        for(uint8_t i = 0; i < (uint8_t)(sizeof(cyhal_pin_map_peri_tr_io_output)/sizeof(cyhal_resource_pin_mapping_t)); i++)
10006cac:	3501      	adds	r5, #1
10006cae:	2d06      	cmp	r5, #6
10006cb0:	d1f2      	bne.n	10006c98 <cyhal_gpio_free+0x38>
        Cy_GPIO_Pin_FastInit(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin), CY_GPIO_DM_ANALOG, 0UL, HSIOM_SEL_GPIO);
10006cb2:	4638      	mov	r0, r7
10006cb4:	f7ff fed6 	bl	10006a64 <Cy_GPIO_PortToAddr>
10006cb8:	2300      	movs	r3, #0
10006cba:	9300      	str	r3, [sp, #0]
10006cbc:	461a      	mov	r2, r3
10006cbe:	4631      	mov	r1, r6
10006cc0:	f7fd fbdc 	bl	1000447c <Cy_GPIO_Pin_FastInit>
        cyhal_resource_inst_t pinRsc = _cyhal_utils_get_gpio_resource(pin);
10006cc4:	230b      	movs	r3, #11
        cyhal_hwmgr_free(&pinRsc);
10006cc6:	a803      	add	r0, sp, #12
        cyhal_resource_inst_t pinRsc = _cyhal_utils_get_gpio_resource(pin);
10006cc8:	f88d 300c 	strb.w	r3, [sp, #12]
10006ccc:	f88d 700d 	strb.w	r7, [sp, #13]
10006cd0:	f88d 600e 	strb.w	r6, [sp, #14]
        cyhal_hwmgr_free(&pinRsc);
10006cd4:	f000 f8f4 	bl	10006ec0 <cyhal_hwmgr_free>
}
10006cd8:	b005      	add	sp, #20
10006cda:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
10006cde:	bf00      	nop
10006ce0:	10009ab3 	.word	0x10009ab3
10006ce4:	080037d0 	.word	0x080037d0

10006ce8 <_cyhal_get_block_offsets>:
    return cyhal_resource_offsets[type];
}

static inline const uint8_t* _cyhal_get_block_offsets(cyhal_resource_t type)
{
    switch (type)
10006ce8:	3803      	subs	r0, #3
10006cea:	2818      	cmp	r0, #24
10006cec:	d81e      	bhi.n	10006d2c <_cyhal_get_block_offsets+0x44>
10006cee:	e8df f000 	tbb	[pc, r0]
10006cf2:	1d0d      	.short	0x1d0d
10006cf4:	0f1d1d20 	.word	0x0f1d1d20
10006cf8:	1d151d11 	.word	0x1d151d11
10006cfc:	1d1d1d1d 	.word	0x1d1d1d1d
10006d00:	1d191d17 	.word	0x1d191d17
10006d04:	1d1d1d1d 	.word	0x1d1d1d1d
10006d08:	1b1d      	.short	0x1b1d
10006d0a:	13          	.byte	0x13
10006d0b:	00          	.byte	0x00
    {
        case CYHAL_RSC_CAN:
            return cyhal_block_offsets_can;
10006d0c:	480a      	ldr	r0, [pc, #40]	; (10006d38 <_cyhal_get_block_offsets+0x50>)
10006d0e:	4770      	bx	lr
        case CYHAL_RSC_CLOCK:
            return cyhal_block_offsets_clock;
        case CYHAL_RSC_DMA:
            return cyhal_block_offsets_dma;
10006d10:	480a      	ldr	r0, [pc, #40]	; (10006d3c <_cyhal_get_block_offsets+0x54>)
10006d12:	4770      	bx	lr
#if defined(COMPONENT_CAT1A) || defined(COMPONENT_CAT1B)
        case CYHAL_RSC_DW:
            return cyhal_block_offsets_dw;
10006d14:	480a      	ldr	r0, [pc, #40]	; (10006d40 <_cyhal_get_block_offsets+0x58>)
10006d16:	4770      	bx	lr
        case CYHAL_RSC_TDM:
            return cyhal_block_offsets_tdm;
10006d18:	480a      	ldr	r0, [pc, #40]	; (10006d44 <_cyhal_get_block_offsets+0x5c>)
10006d1a:	4770      	bx	lr
#endif
        case CYHAL_RSC_GPIO:
            return cyhal_block_offsets_gpio;
10006d1c:	480a      	ldr	r0, [pc, #40]	; (10006d48 <_cyhal_get_block_offsets+0x60>)
10006d1e:	4770      	bx	lr
        case CYHAL_RSC_LPCOMP:
            return cyhal_block_offsets_lpcomp;
10006d20:	480a      	ldr	r0, [pc, #40]	; (10006d4c <_cyhal_get_block_offsets+0x64>)
10006d22:	4770      	bx	lr
        case CYHAL_RSC_OPAMP:
            return cyhal_block_offsets_opamp;
10006d24:	480a      	ldr	r0, [pc, #40]	; (10006d50 <_cyhal_get_block_offsets+0x68>)
10006d26:	4770      	bx	lr
        case CYHAL_RSC_TCPWM:
            return cyhal_block_offsets_tcpwm;
10006d28:	480a      	ldr	r0, [pc, #40]	; (10006d54 <_cyhal_get_block_offsets+0x6c>)
10006d2a:	4770      	bx	lr
10006d2c:	be01      	bkpt	0x0001
        default:
            CY_ASSERT(false);
            return NULL;
10006d2e:	2000      	movs	r0, #0
10006d30:	4770      	bx	lr
    switch (type)
10006d32:	4809      	ldr	r0, [pc, #36]	; (10006d58 <_cyhal_get_block_offsets+0x70>)
    }
}
10006d34:	4770      	bx	lr
10006d36:	bf00      	nop
10006d38:	1000a152 	.word	0x1000a152
10006d3c:	1000a166 	.word	0x1000a166
10006d40:	1000a164 	.word	0x1000a164
10006d44:	1000a163 	.word	0x1000a163
10006d48:	1000a153 	.word	0x1000a153
10006d4c:	1000a151 	.word	0x1000a151
10006d50:	1000a150 	.word	0x1000a150
10006d54:	1000a14e 	.word	0x1000a14e
10006d58:	1000a167 	.word	0x1000a167

10006d5c <_cyhal_get_block_offset_length>:

// Gets the number of block offset entries, only valid for blocks which have channels.
static inline uint8_t _cyhal_get_block_offset_length(cyhal_resource_t type)
{
    switch (type)
10006d5c:	281b      	cmp	r0, #27
{
10006d5e:	4603      	mov	r3, r0
    switch (type)
10006d60:	d805      	bhi.n	10006d6e <_cyhal_get_block_offset_length+0x12>
10006d62:	2807      	cmp	r0, #7
10006d64:	d806      	bhi.n	10006d74 <_cyhal_get_block_offset_length+0x18>
10006d66:	2803      	cmp	r0, #3
10006d68:	d011      	beq.n	10006d8e <_cyhal_get_block_offset_length+0x32>
10006d6a:	2805      	cmp	r0, #5
10006d6c:	d011      	beq.n	10006d92 <_cyhal_get_block_offset_length+0x36>
10006d6e:	be01      	bkpt	0x0001
            return sizeof(cyhal_block_offsets_opamp)/sizeof(cyhal_block_offsets_opamp[0]);
        case CYHAL_RSC_TCPWM:
            return sizeof(cyhal_block_offsets_tcpwm)/sizeof(cyhal_block_offsets_tcpwm[0]);
        default:
            CY_ASSERT(false);
            return 0;
10006d70:	2000      	movs	r0, #0
10006d72:	4770      	bx	lr
    switch (type)
10006d74:	4a09      	ldr	r2, [pc, #36]	; (10006d9c <_cyhal_get_block_offset_length+0x40>)
10006d76:	2001      	movs	r0, #1
10006d78:	fa00 f103 	lsl.w	r1, r0, r3
10006d7c:	400a      	ands	r2, r1
10006d7e:	b92a      	cbnz	r2, 10006d8c <_cyhal_get_block_offset_length+0x30>
10006d80:	4a07      	ldr	r2, [pc, #28]	; (10006da0 <_cyhal_get_block_offset_length+0x44>)
10006d82:	400a      	ands	r2, r1
10006d84:	b93a      	cbnz	r2, 10006d96 <_cyhal_get_block_offset_length+0x3a>
10006d86:	2b0b      	cmp	r3, #11
10006d88:	d1f1      	bne.n	10006d6e <_cyhal_get_block_offset_length+0x12>
            return sizeof(cyhal_block_offsets_gpio)/sizeof(cyhal_block_offsets_gpio[0]);
10006d8a:	2010      	movs	r0, #16
    }
}
10006d8c:	4770      	bx	lr
            return sizeof(cyhal_block_offsets_can)/sizeof(cyhal_block_offsets_can[0]);
10006d8e:	2001      	movs	r0, #1
10006d90:	4770      	bx	lr
    switch (type)
10006d92:	201a      	movs	r0, #26
10006d94:	4770      	bx	lr
            return sizeof(cyhal_block_offsets_dw)/sizeof(cyhal_block_offsets_dw[0]);
10006d96:	2002      	movs	r0, #2
10006d98:	4770      	bx	lr
10006d9a:	bf00      	nop
10006d9c:	080a0100 	.word	0x080a0100
10006da0:	04000200 	.word	0x04000200

10006da4 <_cyhal_get_bit_position>:

static cy_rslt_t _cyhal_get_bit_position(cyhal_resource_t type, uint8_t block, uint8_t channel, uint16_t* bitPosition)
{
#if defined(COMPONENT_CAT1A) || defined(COMPONENT_CAT1B)
    /* For backwards compatability. */
    if (type == CYHAL_RSC_CLKPATH)
10006da4:	2804      	cmp	r0, #4
{
10006da6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
10006daa:	460c      	mov	r4, r1
10006dac:	4605      	mov	r5, r0
10006dae:	4921      	ldr	r1, [pc, #132]	; (10006e34 <_cyhal_get_bit_position+0x90>)
10006db0:	4691      	mov	r9, r2
10006db2:	4698      	mov	r8, r3
    if (type == CYHAL_RSC_CLKPATH)
10006db4:	d02e      	beq.n	10006e14 <_cyhal_get_bit_position+0x70>
#endif

    uint16_t offsetRsc = _cyhal_get_resource_offset(type);
    // Offset that is one past the beginning of the next resource (or one past the end of the array).
    // Our offset must be strictly less than that
    uint16_t offsetEndOfRsc = ((1u + type) < _CYHAL_RESOURCES)
10006db6:	1c42      	adds	r2, r0, #1
10006db8:	2a1d      	cmp	r2, #29
    return cyhal_resource_offsets[type];
10006dba:	f831 a010 	ldrh.w	sl, [r1, r0, lsl #1]
10006dbe:	4603      	mov	r3, r0
10006dc0:	d82f      	bhi.n	10006e22 <_cyhal_get_bit_position+0x7e>
        ? _cyhal_get_resource_offset((cyhal_resource_t)(type + 1))
10006dc2:	1c6a      	adds	r2, r5, #1
10006dc4:	b2d2      	uxtb	r2, r2
10006dc6:	f831 6012 	ldrh.w	r6, [r1, r2, lsl #1]
    return (cyhal_has_channels & (1 << type)) > 0;
10006dca:	2201      	movs	r2, #1
10006dcc:	409a      	lsls	r2, r3
        : CY_TOTAL_ALLOCATABLE_ITEMS;

    if (_cyhal_uses_channels(type))
10006dce:	4b1a      	ldr	r3, [pc, #104]	; (10006e38 <_cyhal_get_bit_position+0x94>)
10006dd0:	4013      	ands	r3, r2
10006dd2:	b34b      	cbz	r3, 10006e28 <_cyhal_get_bit_position+0x84>
    {
        const uint8_t* blockOffsets = _cyhal_get_block_offsets(type);
10006dd4:	4628      	mov	r0, r5
10006dd6:	f7ff ff87 	bl	10006ce8 <_cyhal_get_block_offsets>
        *bitPosition = offsetEndOfRsc;
10006dda:	f8a8 6000 	strh.w	r6, [r8]
        if (blockOffsets != NULL)
10006dde:	4607      	mov	r7, r0
10006de0:	b1a8      	cbz	r0, 10006e0e <_cyhal_get_bit_position+0x6a>
        {
            // Offset (from the beginning of the section for this block type) that is one past the end of
            // the requested block index. The channel number must be strictly less than that.
            uint16_t blocks = _cyhal_get_block_offset_length(type);
10006de2:	4628      	mov	r0, r5
10006de4:	f7ff ffba 	bl	10006d5c <_cyhal_get_block_offset_length>
            if (block < blocks)
10006de8:	42a0      	cmp	r0, r4
10006dea:	d90c      	bls.n	10006e06 <_cyhal_get_bit_position+0x62>
            {
                *bitPosition = offsetRsc + blockOffsets[block] + channel;
10006dec:	5d3b      	ldrb	r3, [r7, r4]
10006dee:	eb09 020a 	add.w	r2, r9, sl
10006df2:	4413      	add	r3, r2
10006df4:	f8a8 3000 	strh.w	r3, [r8]
                if ((block + 1) < blocks)
10006df8:	1c63      	adds	r3, r4, #1
10006dfa:	4283      	cmp	r3, r0
10006dfc:	da03      	bge.n	10006e06 <_cyhal_get_bit_position+0x62>
                {
                    offsetEndOfRsc = offsetRsc + blockOffsets[block + 1];
10006dfe:	4427      	add	r7, r4
10006e00:	787e      	ldrb	r6, [r7, #1]
10006e02:	4456      	add	r6, sl
10006e04:	b2b6      	uxth	r6, r6
        *bitPosition = offsetRsc + block;
    }

    return (*bitPosition < offsetEndOfRsc)
        ? CY_RSLT_SUCCESS
        : CYHAL_HWMGR_RSLT_ERR_INVALID;
10006e06:	f8b8 3000 	ldrh.w	r3, [r8]
10006e0a:	42b3      	cmp	r3, r6
10006e0c:	d310      	bcc.n	10006e30 <_cyhal_get_bit_position+0x8c>
10006e0e:	480b      	ldr	r0, [pc, #44]	; (10006e3c <_cyhal_get_bit_position+0x98>)
}
10006e10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return cyhal_resource_offsets[type];
10006e14:	2305      	movs	r3, #5
        channel = block;
10006e16:	46a1      	mov	r9, r4
10006e18:	f04f 0a01 	mov.w	sl, #1
        block = CYHAL_CLOCK_BLOCK_PATHMUX;
10006e1c:	240d      	movs	r4, #13
        type = CYHAL_RSC_CLOCK;
10006e1e:	461d      	mov	r5, r3
10006e20:	e7cf      	b.n	10006dc2 <_cyhal_get_bit_position+0x1e>
    uint16_t offsetEndOfRsc = ((1u + type) < _CYHAL_RESOURCES)
10006e22:	f240 1631 	movw	r6, #305	; 0x131
10006e26:	e7d0      	b.n	10006dca <_cyhal_get_bit_position+0x26>
        *bitPosition = offsetRsc + block;
10006e28:	4454      	add	r4, sl
10006e2a:	f8a8 4000 	strh.w	r4, [r8]
10006e2e:	e7ea      	b.n	10006e06 <_cyhal_get_bit_position+0x62>
        : CYHAL_HWMGR_RSLT_ERR_INVALID;
10006e30:	2000      	movs	r0, #0
10006e32:	e7ed      	b.n	10006e10 <_cyhal_get_bit_position+0x6c>
10006e34:	100097e4 	.word	0x100097e4
10006e38:	0c0a0b28 	.word	0x0c0a0b28
10006e3c:	04020d00 	.word	0x04020d00

10006e40 <cyhal_hwmgr_reserve>:
{
    return CY_RSLT_SUCCESS;
}

cy_rslt_t cyhal_hwmgr_reserve(const cyhal_resource_inst_t* obj)
{
10006e40:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
10006e44:	4605      	mov	r5, r0
    bool isSet;
    uint32_t state = cyhal_system_critical_section_enter();
10006e46:	f7fb fa54 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>
    cy_rslt_t status = _cyhal_get_bit_position(type, block, channel, &bitPosition);
10006e4a:	78aa      	ldrb	r2, [r5, #2]
10006e4c:	7869      	ldrb	r1, [r5, #1]
    uint32_t state = cyhal_system_critical_section_enter();
10006e4e:	4607      	mov	r7, r0
    cy_rslt_t status = _cyhal_get_bit_position(type, block, channel, &bitPosition);
10006e50:	f10d 0306 	add.w	r3, sp, #6
10006e54:	7828      	ldrb	r0, [r5, #0]
10006e56:	f7ff ffa5 	bl	10006da4 <_cyhal_get_bit_position>
    if (status == CY_RSLT_SUCCESS)
10006e5a:	4604      	mov	r4, r0
10006e5c:	bb18      	cbnz	r0, 10006ea6 <cyhal_hwmgr_reserve+0x66>
        uint8_t byte = (uint8_t)(bitPosition >> CY_BYTE_NUM_SHIFT);
10006e5e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        *isSet = (used[byte] & (1 << bit));
10006e62:	f8df 8054 	ldr.w	r8, [pc, #84]	; 10006eb8 <cyhal_hwmgr_reserve+0x78>
10006e66:	f3c3 02c7 	ubfx	r2, r3, #3, #8
10006e6a:	2601      	movs	r6, #1
10006e6c:	f818 2002 	ldrb.w	r2, [r8, r2]
10006e70:	f003 0307 	and.w	r3, r3, #7
10006e74:	fa06 f303 	lsl.w	r3, r6, r3
    cy_rslt_t rslt = _cyhal_is_set(cyhal_used, obj->type, obj->block_num, obj->channel_num, &isSet);
    if (rslt == CY_RSLT_SUCCESS && isSet)
10006e78:	421a      	tst	r2, r3
10006e7a:	d11b      	bne.n	10006eb4 <cyhal_hwmgr_reserve+0x74>
    cy_rslt_t status = _cyhal_get_bit_position(type, block, channel, &bitPosition);
10006e7c:	78aa      	ldrb	r2, [r5, #2]
10006e7e:	7869      	ldrb	r1, [r5, #1]
10006e80:	7828      	ldrb	r0, [r5, #0]
10006e82:	f10d 0306 	add.w	r3, sp, #6
10006e86:	f7ff ff8d 	bl	10006da4 <_cyhal_get_bit_position>
    if (status == CY_RSLT_SUCCESS)
10006e8a:	4604      	mov	r4, r0
10006e8c:	b958      	cbnz	r0, 10006ea6 <cyhal_hwmgr_reserve+0x66>
        uint8_t byte = (uint8_t)(bitPosition >> CY_BYTE_NUM_SHIFT);
10006e8e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        used[byte] |= (1 << bit);
10006e92:	f3c3 02c7 	ubfx	r2, r3, #3, #8
10006e96:	f003 0307 	and.w	r3, r3, #7
10006e9a:	409e      	lsls	r6, r3
10006e9c:	f818 3002 	ldrb.w	r3, [r8, r2]
10006ea0:	431e      	orrs	r6, r3
10006ea2:	f808 6002 	strb.w	r6, [r8, r2]

    if (rslt == CY_RSLT_SUCCESS)
    {
        rslt = _cyhal_set_bit(cyhal_used, obj->type, obj->block_num, obj->channel_num);
    }
    cyhal_system_critical_section_exit(state);
10006ea6:	4638      	mov	r0, r7
10006ea8:	f7fb fa27 	bl	100022fa <Cy_SysLib_ExitCriticalSection>

    return rslt;
}
10006eac:	4620      	mov	r0, r4
10006eae:	b002      	add	sp, #8
10006eb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        rslt = CYHAL_HWMGR_RSLT_ERR_INUSE;
10006eb4:	4c01      	ldr	r4, [pc, #4]	; (10006ebc <cyhal_hwmgr_reserve+0x7c>)
10006eb6:	e7f6      	b.n	10006ea6 <cyhal_hwmgr_reserve+0x66>
10006eb8:	080037df 	.word	0x080037df
10006ebc:	04020d01 	.word	0x04020d01

10006ec0 <cyhal_hwmgr_free>:

void cyhal_hwmgr_free(const cyhal_resource_inst_t* obj)
{
10006ec0:	b537      	push	{r0, r1, r2, r4, r5, lr}
10006ec2:	4604      	mov	r4, r0
    uint32_t state = cyhal_system_critical_section_enter();
10006ec4:	f7fb fa15 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>
    cy_rslt_t status = _cyhal_get_bit_position(type, block, channel, &bitPosition);
10006ec8:	78a2      	ldrb	r2, [r4, #2]
10006eca:	7861      	ldrb	r1, [r4, #1]
    uint32_t state = cyhal_system_critical_section_enter();
10006ecc:	4605      	mov	r5, r0
    cy_rslt_t status = _cyhal_get_bit_position(type, block, channel, &bitPosition);
10006ece:	f10d 0306 	add.w	r3, sp, #6
10006ed2:	7820      	ldrb	r0, [r4, #0]
10006ed4:	f7ff ff66 	bl	10006da4 <_cyhal_get_bit_position>
    if (status == CY_RSLT_SUCCESS)
10006ed8:	b130      	cbz	r0, 10006ee8 <cyhal_hwmgr_free+0x28>
10006eda:	be01      	bkpt	0x0001
    cy_rslt_t rslt = _cyhal_clear_bit(cyhal_used, obj->type, obj->block_num, obj->channel_num);
    CY_UNUSED_PARAMETER(rslt); /* CY_ASSERT only processes in DEBUG, ignores for others */
    CY_ASSERT(CY_RSLT_SUCCESS == rslt);
    cyhal_system_critical_section_exit(state);
10006edc:	4628      	mov	r0, r5
}
10006ede:	b003      	add	sp, #12
10006ee0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    cyhal_system_critical_section_exit(state);
10006ee4:	f7fb ba09 	b.w	100022fa <Cy_SysLib_ExitCriticalSection>
        uint8_t byte = (uint8_t)(bitPosition >> CY_BYTE_NUM_SHIFT);
10006ee8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
        used[byte] &= ~(1 << bit);
10006eec:	4805      	ldr	r0, [pc, #20]	; (10006f04 <cyhal_hwmgr_free+0x44>)
10006eee:	f3c3 01c7 	ubfx	r1, r3, #3, #8
10006ef2:	2201      	movs	r2, #1
10006ef4:	f003 0307 	and.w	r3, r3, #7
10006ef8:	409a      	lsls	r2, r3
10006efa:	5c43      	ldrb	r3, [r0, r1]
10006efc:	ea23 0302 	bic.w	r3, r3, r2
10006f00:	5443      	strb	r3, [r0, r1]
    CY_ASSERT(CY_RSLT_SUCCESS == rslt);
10006f02:	e7eb      	b.n	10006edc <cyhal_hwmgr_free+0x1c>
10006f04:	080037df 	.word	0x080037df

10006f08 <_cyhal_interconnect_check_connection>:
#endif /* #if CY_IP_MXPERI_VERSION == 2u || CY_IP_M0S8PERI_VERSION == 1u */

// Since both connect and disconnect need to derive mux group(s) and trigger
// indices, use this func to avoid duplicate code.
static cy_rslt_t _cyhal_interconnect_check_connection(cyhal_source_t source, cyhal_dest_t dest, cyhal_connect_type_t connect)
{
10006f08:	4b50      	ldr	r3, [pc, #320]	; (1000704c <_cyhal_interconnect_check_connection+0x144>)
10006f0a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
10006f0e:	4686      	mov	lr, r0
    cyhal_internal_source_t internal_src = _CYHAL_TRIGGER_GET_SOURCE_SIGNAL(source);
10006f10:	f3ce 0747 	ubfx	r7, lr, #1, #8
{
10006f14:	4610      	mov	r0, r2
    cyhal_internal_source_t internal_src = _CYHAL_TRIGGER_GET_SOURCE_SIGNAL(source);
10006f16:	2400      	movs	r4, #0
10006f18:	461a      	mov	r2, r3
10006f1a:	4698      	mov	r8, r3
        if(cyhal_is_mux_1to1[idx])
10006f1c:	f812 5b01 	ldrb.w	r5, [r2], #1
10006f20:	b1bd      	cbz	r5, 10006f52 <_cyhal_interconnect_check_connection+0x4a>
            return idx;
10006f22:	b264      	sxtb	r4, r4
    const int8_t mux_group_1to1_offset = _cyhal_get_first_1to1_mux_idx();

    // cyhal_dest_to_mux stores 1to1 triggers with bit 8 set and the lower 7
    // bits as the offset into the 1to1 triggers (so 128 is 1to1 mux index 0)
    // but here we need the actual group offset for all the triggers.
    uint8_t mux_group = cyhal_dest_to_mux[dest];
10006f24:	4a4a      	ldr	r2, [pc, #296]	; (10007050 <_cyhal_interconnect_check_connection+0x148>)
    uint8_t dest_idx = cyhal_mux_dest_index[dest];

    // Search through table of mux input trigger lines
    for (uint16_t source_idx = 0; source_idx < cyhal_sources_per_mux[mux_group]; source_idx++)
    {
        if(cyhal_mux_to_sources[mux_group][source_idx] == internal_src)
10006f26:	f8df a12c 	ldr.w	sl, [pc, #300]	; 10007054 <_cyhal_interconnect_check_connection+0x14c>
    uint8_t mux_group = cyhal_dest_to_mux[dest];
10006f2a:	5c56      	ldrb	r6, [r2, r1]
    if(mux_group & 0x80)
10006f2c:	5652      	ldrsb	r2, [r2, r1]
10006f2e:	2a00      	cmp	r2, #0
        mux_group = mux_group_1to1_offset + (mux_group & ~0x80);
10006f30:	bfbc      	itt	lt
10006f32:	f006 067f 	andlt.w	r6, r6, #127	; 0x7f
10006f36:	1936      	addlt	r6, r6, r4
    for (uint16_t source_idx = 0; source_idx < cyhal_sources_per_mux[mux_group]; source_idx++)
10006f38:	4a47      	ldr	r2, [pc, #284]	; (10007058 <_cyhal_interconnect_check_connection+0x150>)
        mux_group = mux_group_1to1_offset + (mux_group & ~0x80);
10006f3a:	bfb8      	it	lt
10006f3c:	b2f6      	uxtblt	r6, r6
    for (uint16_t source_idx = 0; source_idx < cyhal_sources_per_mux[mux_group]; source_idx++)
10006f3e:	f04f 0c00 	mov.w	ip, #0
10006f42:	f832 9016 	ldrh.w	r9, [r2, r6, lsl #1]
10006f46:	fa1f f58c 	uxth.w	r5, ip
10006f4a:	45a9      	cmp	r9, r5
10006f4c:	d807      	bhi.n	10006f5e <_cyhal_interconnect_check_connection+0x56>
        {
            // 1to1 triggers muxes source and dest indices must match
            if(cyhal_is_mux_1to1[mux_group] && (source_idx != dest_idx))
            {
                return CYHAL_INTERCONNECT_RSLT_INVALID_CONNECTION;
10006f4e:	4843      	ldr	r0, [pc, #268]	; (1000705c <_cyhal_interconnect_check_connection+0x154>)
10006f50:	e021      	b.n	10006f96 <_cyhal_interconnect_check_connection+0x8e>
    for(uint8_t idx = 0; idx < (sizeof(cyhal_is_mux_1to1)/sizeof(cyhal_is_mux_1to1[0])); idx++)
10006f52:	3401      	adds	r4, #1
10006f54:	2c11      	cmp	r4, #17
10006f56:	d1e1      	bne.n	10006f1c <_cyhal_interconnect_check_connection+0x14>
    return -1;
10006f58:	f04f 34ff 	mov.w	r4, #4294967295
10006f5c:	e7e2      	b.n	10006f24 <_cyhal_interconnect_check_connection+0x1c>
        if(cyhal_mux_to_sources[mux_group][source_idx] == internal_src)
10006f5e:	f85a 2026 	ldr.w	r2, [sl, r6, lsl #2]
10006f62:	f812 200c 	ldrb.w	r2, [r2, ip]
10006f66:	42ba      	cmp	r2, r7
10006f68:	f10c 0b01 	add.w	fp, ip, #1
10006f6c:	d16a      	bne.n	10007044 <_cyhal_interconnect_check_connection+0x13c>
    uint8_t dest_idx = cyhal_mux_dest_index[dest];
10006f6e:	4a3c      	ldr	r2, [pc, #240]	; (10007060 <_cyhal_interconnect_check_connection+0x158>)
10006f70:	5c57      	ldrb	r7, [r2, r1]
            if(cyhal_is_mux_1to1[mux_group] && (source_idx != dest_idx))
10006f72:	f818 2006 	ldrb.w	r2, [r8, r6]
10006f76:	b982      	cbnz	r2, 10006f9a <_cyhal_interconnect_check_connection+0x92>
            }

            // Check if the mux is already configured (possibly from a
            // different source)
            if(CYHAL_CONNECT_TYPE_DISCONNECT != connect
10006f78:	2802      	cmp	r0, #2
10006f7a:	d11e      	bne.n	10006fba <_cyhal_interconnect_check_connection+0xb2>
            PERI_TR_GR_TR_CTL(mux_group, dest_idx) = 0;
10006f7c:	4b39      	ldr	r3, [pc, #228]	; (10007064 <_cyhal_interconnect_check_connection+0x15c>)
10006f7e:	6819      	ldr	r1, [r3, #0]
10006f80:	f8b1 3070 	ldrh.w	r3, [r1, #112]	; 0x70
10006f84:	6888      	ldr	r0, [r1, #8]
10006f86:	f8b1 1072 	ldrh.w	r1, [r1, #114]	; 0x72
10006f8a:	4403      	add	r3, r0
10006f8c:	eb03 0387 	add.w	r3, r3, r7, lsl #2
10006f90:	4371      	muls	r1, r6
10006f92:	505a      	str	r2, [r3, r1]
                return CYHAL_INTERCONNECT_RSLT_ALREADY_CONNECTED;
            }

            return (connect == CYHAL_CONNECT_TYPE_VALIDATE)
                ? CY_RSLT_SUCCESS
                : _cyhal_interconnect_change_connection_direct(mux_group, mux_group_1to1_offset, source_idx, dest_idx, type, connect == CYHAL_CONNECT_TYPE_CONNECT);
10006f94:	2000      	movs	r0, #0
        : _cyhal_interconnect_change_connection_indirect(source_mux_group, source_mux_input_idx, source_mux_output_idx,
            dest_mux_group, dest_mux_input_idx, dest_mux_output_idx, type, connect == CYHAL_CONNECT_TYPE_CONNECT);
#else
#error Unrecognized PERI version
#endif
}
10006f96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if(cyhal_is_mux_1to1[mux_group] && (source_idx != dest_idx))
10006f9a:	42af      	cmp	r7, r5
10006f9c:	d1d7      	bne.n	10006f4e <_cyhal_interconnect_check_connection+0x46>
            if(CYHAL_CONNECT_TYPE_DISCONNECT != connect
10006f9e:	2802      	cmp	r0, #2
10006fa0:	d10b      	bne.n	10006fba <_cyhal_interconnect_check_connection+0xb2>
        uint32_t out_trig = CY_SELECT_OUTPUT_LINE(mux_group - mux_group_1to1_offset, dest_idx);
10006fa2:	b2e4      	uxtb	r4, r4
10006fa4:	1b34      	subs	r4, r6, r4
10006fa6:	ea47 2004 	orr.w	r0, r7, r4, lsl #8
            return Cy_TrigMux_Deselect(out_trig);
10006faa:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
}
10006fae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return Cy_TrigMux_Deselect(out_trig);
10006fb2:	f440 5080 	orr.w	r0, r0, #4096	; 0x1000
10006fb6:	f7fe be8b 	b.w	10005cd0 <Cy_TrigMux_Deselect>
            if(CYHAL_CONNECT_TYPE_DISCONNECT != connect
10006fba:	2500      	movs	r5, #0
        if(cyhal_is_mux_1to1[idx])
10006fbc:	f813 1b01 	ldrb.w	r1, [r3], #1
10006fc0:	b331      	cbz	r1, 10007010 <_cyhal_interconnect_check_connection+0x108>
            return idx;
10006fc2:	b26d      	sxtb	r5, r5
            PERI_TR_GR_TR_CTL(mux_group, dest_idx) = 0;
10006fc4:	4927      	ldr	r1, [pc, #156]	; (10007064 <_cyhal_interconnect_check_connection+0x15c>)
    cyhal_signal_type_t type = _CYHAL_TRIGGER_GET_SOURCE_TYPE(source);
10006fc6:	f00e 0301 	and.w	r3, lr, #1
            PERI_TR_GR_TR_CTL(mux_group, dest_idx) = 0;
10006fca:	f8d1 e000 	ldr.w	lr, [r1]
        mux_reg = PERI_TR_GR_TR_CTL(mux_group - MUX_GROUP_1TO1_OFFSET + FIRST_1TO1_MUX_GROUP_IDX, mux_output_idx);
10006fce:	f8be 1070 	ldrh.w	r1, [lr, #112]	; 0x70
10006fd2:	f8de 8008 	ldr.w	r8, [lr, #8]
10006fd6:	f8be e072 	ldrh.w	lr, [lr, #114]	; 0x72
10006fda:	4441      	add	r1, r8
10006fdc:	eb01 0187 	add.w	r1, r1, r7, lsl #2
    if(cyhal_is_mux_1to1[mux_group])
10006fe0:	b1e2      	cbz	r2, 1000701c <_cyhal_interconnect_check_connection+0x114>
        mux_reg = PERI_TR_GR_TR_CTL(mux_group - MUX_GROUP_1TO1_OFFSET + FIRST_1TO1_MUX_GROUP_IDX, mux_output_idx);
10006fe2:	1b75      	subs	r5, r6, r5
10006fe4:	3510      	adds	r5, #16
10006fe6:	fb0e f505 	mul.w	r5, lr, r5
10006fea:	5869      	ldr	r1, [r5, r1]
                && _cyhal_read_mux_input_idx(mux_group, dest_idx) != 0)
10006fec:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
10006ff0:	d12a      	bne.n	10007048 <_cyhal_interconnect_check_connection+0x140>
                : _cyhal_interconnect_change_connection_direct(mux_group, mux_group_1to1_offset, source_idx, dest_idx, type, connect == CYHAL_CONNECT_TYPE_CONNECT);
10006ff2:	2800      	cmp	r0, #0
10006ff4:	d0ce      	beq.n	10006f94 <_cyhal_interconnect_check_connection+0x8c>
        uint32_t out_trig = CY_SELECT_OUTPUT_LINE(mux_group - mux_group_1to1_offset, dest_idx);
10006ff6:	b2e4      	uxtb	r4, r4
10006ff8:	1b34      	subs	r4, r6, r4
10006ffa:	ea47 2004 	orr.w	r0, r7, r4, lsl #8
            return Cy_TrigMux_Select(out_trig, false, (en_trig_type_t)type);
10006ffe:	f040 4080 	orr.w	r0, r0, #1073741824	; 0x40000000
}
10007002:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return Cy_TrigMux_Select(out_trig, false, (en_trig_type_t)type);
10007006:	461a      	mov	r2, r3
10007008:	f440 5080 	orr.w	r0, r0, #4096	; 0x1000
1000700c:	f7fe be14 	b.w	10005c38 <Cy_TrigMux_Select>
    for(uint8_t idx = 0; idx < (sizeof(cyhal_is_mux_1to1)/sizeof(cyhal_is_mux_1to1[0])); idx++)
10007010:	3501      	adds	r5, #1
10007012:	2d11      	cmp	r5, #17
10007014:	d1d2      	bne.n	10006fbc <_cyhal_interconnect_check_connection+0xb4>
    return -1;
10007016:	f04f 35ff 	mov.w	r5, #4294967295
1000701a:	e7d3      	b.n	10006fc4 <_cyhal_interconnect_check_connection+0xbc>
        mux_reg = PERI_TR_GR_TR_CTL(mux_group, mux_output_idx);
1000701c:	fb0e fe06 	mul.w	lr, lr, r6
10007020:	f85e 1001 	ldr.w	r1, [lr, r1]
                && _cyhal_read_mux_input_idx(mux_group, dest_idx) != 0)
10007024:	b2c9      	uxtb	r1, r1
10007026:	b979      	cbnz	r1, 10007048 <_cyhal_interconnect_check_connection+0x140>
                : _cyhal_interconnect_change_connection_direct(mux_group, mux_group_1to1_offset, source_idx, dest_idx, type, connect == CYHAL_CONNECT_TYPE_CONNECT);
10007028:	2800      	cmp	r0, #0
1000702a:	d0b3      	beq.n	10006f94 <_cyhal_interconnect_check_connection+0x8c>
        uint32_t out_trig = CY_TRIGMUX_OUTPUT_LINE(mux_group, dest_idx);
1000702c:	ea47 2106 	orr.w	r1, r7, r6, lsl #8
        uint32_t in_trig = CY_TRIGMUX_INPUT_LINE(mux_group, source_idx);
10007030:	fa5f f08c 	uxtb.w	r0, ip
            return Cy_TrigMux_Connect(in_trig, out_trig, false, (en_trig_type_t)type);
10007034:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
10007038:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
}
1000703c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return Cy_TrigMux_Connect(in_trig, out_trig, false, (en_trig_type_t)type);
10007040:	f7fe bda6 	b.w	10005b90 <Cy_TrigMux_Connect>
10007044:	46dc      	mov	ip, fp
10007046:	e77e      	b.n	10006f46 <_cyhal_interconnect_check_connection+0x3e>
                return CYHAL_INTERCONNECT_RSLT_ALREADY_CONNECTED;
10007048:	4807      	ldr	r0, [pc, #28]	; (10007068 <_cyhal_interconnect_check_connection+0x160>)
1000704a:	e7a4      	b.n	10006f96 <_cyhal_interconnect_check_connection+0x8e>
1000704c:	1000a0f2 	.word	0x1000a0f2
10007050:	10009ba4 	.word	0x10009ba4
10007054:	080028ac 	.word	0x080028ac
10007058:	100097a8 	.word	0x100097a8
1000705c:	04020c01 	.word	0x04020c01
10007060:	10009b39 	.word	0x10009b39
10007064:	08003550 	.word	0x08003550
10007068:	04020c00 	.word	0x04020c00

1000706c <cyhal_connect_pin>:
}

#endif /* CYHAL_DRIVER_AVAILABLE_INTERCONNECT */

cy_rslt_t cyhal_connect_pin(const cyhal_resource_pin_mapping_t *pin_connection, uint8_t drive_mode)
{
1000706c:	b573      	push	{r0, r1, r4, r5, r6, lr}
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
1000706e:	4a12      	ldr	r2, [pc, #72]	; (100070b8 <cyhal_connect_pin+0x4c>)
    cyhal_gpio_t pin = pin_connection->pin;
10007070:	7885      	ldrb	r5, [r0, #2]
10007072:	6812      	ldr	r2, [r2, #0]
10007074:	6994      	ldr	r4, [r2, #24]
    if(portNum < (uint32_t)IOSS_GPIO_GPIO_PORT_NR)
10007076:	2d77      	cmp	r5, #119	; 0x77
    GPIO_PRT_Type *port = Cy_GPIO_PortToAddr(CYHAL_GET_PORT(pin));
10007078:	ea4f 03d5 	mov.w	r3, r5, lsr #3
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
1000707c:	bf98      	it	ls
1000707e:	eb04 14c3 	addls.w	r4, r4, r3, lsl #7
    en_hsiom_sel_t hsiom = pin_connection->hsiom;

    Cy_GPIO_Pin_FastInit(port, CYHAL_GET_PIN(pin), drive_mode, 1, hsiom);
10007082:	f005 0507 	and.w	r5, r5, #7
10007086:	78c3      	ldrb	r3, [r0, #3]
10007088:	9300      	str	r3, [sp, #0]
{
1000708a:	460e      	mov	r6, r1
    Cy_GPIO_Pin_FastInit(port, CYHAL_GET_PIN(pin), drive_mode, 1, hsiom);
1000708c:	460a      	mov	r2, r1
1000708e:	2301      	movs	r3, #1
10007090:	4629      	mov	r1, r5
10007092:	4620      	mov	r0, r4
10007094:	f7fd f9f2 	bl	1000447c <Cy_GPIO_Pin_FastInit>
    // Force output to enable pulls.
    switch (drive_mode)
10007098:	2e0a      	cmp	r6, #10
1000709a:	d004      	beq.n	100070a6 <cyhal_connect_pin+0x3a>
1000709c:	2e0b      	cmp	r6, #11
1000709e:	d008      	beq.n	100070b2 <cyhal_connect_pin+0x46>
            /* do nothing */
            break;
    }

    return CY_RSLT_SUCCESS;
}
100070a0:	2000      	movs	r0, #0
100070a2:	b002      	add	sp, #8
100070a4:	bd70      	pop	{r4, r5, r6, pc}
            Cy_GPIO_Write(port, CYHAL_GET_PIN(pin), 1);
100070a6:	2201      	movs	r2, #1
            Cy_GPIO_Write(port, CYHAL_GET_PIN(pin), 0);
100070a8:	4629      	mov	r1, r5
100070aa:	4620      	mov	r0, r4
100070ac:	f001 fa15 	bl	100084da <Cy_GPIO_Write>
            break;
100070b0:	e7f6      	b.n	100070a0 <cyhal_connect_pin+0x34>
            Cy_GPIO_Write(port, CYHAL_GET_PIN(pin), 0);
100070b2:	2200      	movs	r2, #0
100070b4:	e7f8      	b.n	100070a8 <cyhal_connect_pin+0x3c>
100070b6:	bf00      	nop
100070b8:	08003550 	.word	0x08003550

100070bc <cyhal_disconnect_pin>:

cy_rslt_t cyhal_disconnect_pin(cyhal_gpio_t pin)
{
100070bc:	b513      	push	{r0, r1, r4, lr}
100070be:	4a0a      	ldr	r2, [pc, #40]	; (100070e8 <cyhal_disconnect_pin+0x2c>)
100070c0:	6812      	ldr	r2, [r2, #0]
100070c2:	4601      	mov	r1, r0
    GPIO_PRT_Type *port = Cy_GPIO_PortToAddr(CYHAL_GET_PORT(pin));
100070c4:	08c3      	lsrs	r3, r0, #3
100070c6:	6990      	ldr	r0, [r2, #24]
    if(portNum < (uint32_t)IOSS_GPIO_GPIO_PORT_NR)
100070c8:	2977      	cmp	r1, #119	; 0x77
    Cy_GPIO_Pin_FastInit(port, CYHAL_GET_PIN(pin), CY_GPIO_DM_HIGHZ, 1, HSIOM_SEL_GPIO);
100070ca:	f04f 0400 	mov.w	r4, #0
        portBase = (GPIO_PRT_Type *)(CY_GPIO_BASE + (GPIO_PRT_SECTION_SIZE * portNum));
100070ce:	bf98      	it	ls
100070d0:	eb00 10c3 	addls.w	r0, r0, r3, lsl #7
100070d4:	9400      	str	r4, [sp, #0]
100070d6:	2301      	movs	r3, #1
100070d8:	2208      	movs	r2, #8
100070da:	f001 0107 	and.w	r1, r1, #7
100070de:	f7fd f9cd 	bl	1000447c <Cy_GPIO_Pin_FastInit>
    return CY_RSLT_SUCCESS;
}
100070e2:	4620      	mov	r0, r4
100070e4:	b002      	add	sp, #8
100070e6:	bd10      	pop	{r4, pc}
100070e8:	08003550 	.word	0x08003550

100070ec <_cyhal_syspm_register_peripheral_callback>:
    }
    cyhal_system_critical_section_exit(intr_status);
}

void _cyhal_syspm_register_peripheral_callback(cyhal_syspm_callback_data_t *callback_data)
{
100070ec:	b510      	push	{r4, lr}
    CY_ASSERT(callback_data != NULL);
100070ee:	4604      	mov	r4, r0
100070f0:	b900      	cbnz	r0, 100070f4 <_cyhal_syspm_register_peripheral_callback+0x8>
100070f2:	be01      	bkpt	0x0001
    uint32_t intr_status = cyhal_system_critical_section_enter();
100070f4:	f7fb f8fd 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>
    if(!_cyhal_syspm_is_registered(add))
100070f8:	68e3      	ldr	r3, [r4, #12]
100070fa:	b91b      	cbnz	r3, 10007104 <_cyhal_syspm_register_peripheral_callback+0x18>
        add->next = *list;
100070fc:	4b03      	ldr	r3, [pc, #12]	; (1000710c <_cyhal_syspm_register_peripheral_callback+0x20>)
100070fe:	681a      	ldr	r2, [r3, #0]
10007100:	60e2      	str	r2, [r4, #12]
        *list = add;
10007102:	601c      	str	r4, [r3, #0]
	_cyhal_syspm_add_callback_to_list(&_cyhal_syspm_peripheral_callback_ptr, callback_data);
}
10007104:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cyhal_system_critical_section_exit(intr_status);
10007108:	f7fb b8f7 	b.w	100022fa <Cy_SysLib_ExitCriticalSection>
1000710c:	08002974 	.word	0x08002974

10007110 <_cyhal_syspm_unregister_peripheral_callback>:

void _cyhal_syspm_unregister_peripheral_callback(cyhal_syspm_callback_data_t *callback_data)
{
    CY_ASSERT(callback_data != NULL);
10007110:	4601      	mov	r1, r0
10007112:	b900      	cbnz	r0, 10007116 <_cyhal_syspm_unregister_peripheral_callback+0x6>
10007114:	be01      	bkpt	0x0001
    _cyhal_syspm_remove_callback_from_list(&_cyhal_syspm_peripheral_callback_ptr, callback_data);
10007116:	4801      	ldr	r0, [pc, #4]	; (1000711c <_cyhal_syspm_unregister_peripheral_callback+0xc>)
10007118:	f001 be36 	b.w	10008d88 <_cyhal_syspm_remove_callback_from_list>
1000711c:	08002974 	.word	0x08002974

10007120 <_cyhal_utils_calculate_tolerance>:
    }
}

int32_t _cyhal_utils_calculate_tolerance(cyhal_clock_tolerance_unit_t type, uint32_t desired_hz, uint32_t actual_hz)
{
    switch (type)
10007120:	2801      	cmp	r0, #1
{
10007122:	b570      	push	{r4, r5, r6, lr}
    switch (type)
10007124:	d004      	beq.n	10007130 <_cyhal_utils_calculate_tolerance+0x10>
10007126:	2802      	cmp	r0, #2
10007128:	d008      	beq.n	1000713c <_cyhal_utils_calculate_tolerance+0x1c>
1000712a:	b9a8      	cbnz	r0, 10007158 <_cyhal_utils_calculate_tolerance+0x38>
    {
        case CYHAL_TOLERANCE_HZ:
            return (int32_t)(desired_hz - actual_hz);
1000712c:	1a88      	subs	r0, r1, r2
            return (int32_t)((((int64_t)desired_hz - actual_hz) * 100) / desired_hz);
        default:
            CY_ASSERT(false);
            return 0;
    }
}
1000712e:	bd70      	pop	{r4, r5, r6, pc}
            return (int32_t)(((int64_t)(desired_hz - actual_hz)) * 1000000) / ((int32_t)desired_hz);
10007130:	4b0b      	ldr	r3, [pc, #44]	; (10007160 <_cyhal_utils_calculate_tolerance+0x40>)
10007132:	1a8a      	subs	r2, r1, r2
10007134:	435a      	muls	r2, r3
10007136:	fb92 f0f1 	sdiv	r0, r2, r1
1000713a:	e7f8      	b.n	1000712e <_cyhal_utils_calculate_tolerance+0xe>
            return (int32_t)((((int64_t)desired_hz - actual_hz) * 100) / desired_hz);
1000713c:	1a8a      	subs	r2, r1, r2
1000713e:	f04f 0464 	mov.w	r4, #100	; 0x64
10007142:	fba2 0504 	umull	r0, r5, r2, r4
10007146:	eb66 0606 	sbc.w	r6, r6, r6
1000714a:	460a      	mov	r2, r1
1000714c:	2300      	movs	r3, #0
1000714e:	fb04 5106 	mla	r1, r4, r6, r5
10007152:	f7fb f8d5 	bl	10002300 <__aeabi_ldivmod>
10007156:	e7ea      	b.n	1000712e <_cyhal_utils_calculate_tolerance+0xe>
10007158:	be01      	bkpt	0x0001
            return 0;
1000715a:	2000      	movs	r0, #0
1000715c:	e7e7      	b.n	1000712e <_cyhal_utils_calculate_tolerance+0xe>
1000715e:	bf00      	nop
10007160:	000f4240 	.word	0x000f4240

10007164 <_cyhal_utils_get_clock_count>:
#endif

uint32_t _cyhal_utils_get_clock_count(cyhal_clock_block_t block)
{
    //NOTE: This could potentially reuse the cyhal_hwmgr.c cyhal_block_offsets_clock array
    switch (block)
10007164:	2812      	cmp	r0, #18
10007166:	bf9a      	itte	ls
10007168:	4b01      	ldrls	r3, [pc, #4]	; (10007170 <_cyhal_utils_get_clock_count+0xc>)
1000716a:	5c18      	ldrbls	r0, [r3, r0]
{
1000716c:	2001      	movhi	r0, #1
            return PERI_PCLK_DIV_24_5_NR;
        #endif /* defined(COMPONENT_CAT2) */
        default:
            return 1;
    }
}
1000716e:	4770      	bx	lr
10007170:	1000a181 	.word	0x1000a181

10007174 <_cyhal_utils_allocate_clock>:

#if defined(COMPONENT_CAT1A)
cy_rslt_t _cyhal_utils_allocate_clock(cyhal_clock_t *clock, const cyhal_resource_inst_t *clocked_item, cyhal_clock_block_t div, bool accept_larger)
{
10007174:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
10007178:	4605      	mov	r5, r0
1000717a:	4616      	mov	r6, r2
1000717c:	461f      	mov	r7, r3
    CY_ASSERT(NULL != clocked_item);
1000717e:	b901      	cbnz	r1, 10007182 <_cyhal_utils_allocate_clock+0xe>
10007180:	be01      	bkpt	0x0001

    cyhal_clock_t clock_rsc;
    switch (clocked_item->type)
10007182:	780c      	ldrb	r4, [r1, #0]
10007184:	2c1d      	cmp	r4, #29
10007186:	d805      	bhi.n	10007194 <_cyhal_utils_allocate_clock+0x20>
10007188:	2c13      	cmp	r4, #19
1000718a:	d81e      	bhi.n	100071ca <_cyhal_utils_allocate_clock+0x56>
1000718c:	2c05      	cmp	r4, #5
1000718e:	d051      	beq.n	10007234 <_cyhal_utils_allocate_clock+0xc0>
10007190:	2c0c      	cmp	r4, #12
10007192:	d035      	beq.n	10007200 <_cyhal_utils_allocate_clock+0x8c>
10007194:	4c2a      	ldr	r4, [pc, #168]	; (10007240 <_cyhal_utils_allocate_clock+0xcc>)
    cy_rslt_t result = CYHAL_HWMGR_RSLT_ERR_NONE_FREE;
10007196:	482b      	ldr	r0, [pc, #172]	; (10007244 <_cyhal_utils_allocate_clock+0xd0>)
10007198:	f104 0904 	add.w	r9, r4, #4
    bool found_minimum = false;
1000719c:	2300      	movs	r3, #0
        if(PERI_DIVIDERS[i] == div)
1000719e:	f814 8b01 	ldrb.w	r8, [r4], #1
100071a2:	4546      	cmp	r6, r8
100071a4:	d000      	beq.n	100071a8 <_cyhal_utils_allocate_clock+0x34>
        if(found_minimum)
100071a6:	b16b      	cbz	r3, 100071c4 <_cyhal_utils_allocate_clock+0x50>
        ? CYHAL_CLOCK_RSLT_ERR_NOT_SUPPORTED
        : _cyhal_clock_allocate_channel(clock, block, funcs);
}
static inline cy_rslt_t _cyhal_clock_allocate_peri(cyhal_clock_t *clock, cyhal_clock_block_t block)
{
    CY_ASSERT(NULL != clock);
100071a8:	b905      	cbnz	r5, 100071ac <_cyhal_utils_allocate_clock+0x38>
100071aa:	be01      	bkpt	0x0001

    const void* funcs = _cyhal_clock_get_funcs_peripheral();
100071ac:	f7ff fbe8 	bl	10006980 <_cyhal_clock_get_funcs_peripheral>
    return _cyhal_clock_allocate_channel(clock, block, funcs);
100071b0:	4641      	mov	r1, r8
    const void* funcs = _cyhal_clock_get_funcs_peripheral();
100071b2:	4602      	mov	r2, r0
    return _cyhal_clock_allocate_channel(clock, block, funcs);
100071b4:	4628      	mov	r0, r5
100071b6:	f7ff fbe7 	bl	10006988 <_cyhal_clock_allocate_channel>
            if(CY_RSLT_SUCCESS == result || !accept_larger)
100071ba:	2800      	cmp	r0, #0
100071bc:	d03c      	beq.n	10007238 <_cyhal_utils_allocate_clock+0xc4>
100071be:	2f00      	cmp	r7, #0
100071c0:	d03a      	beq.n	10007238 <_cyhal_utils_allocate_clock+0xc4>
100071c2:	463b      	mov	r3, r7
    for(size_t i = 0; i < sizeof(PERI_DIVIDERS) / sizeof(PERI_DIVIDERS[0]); ++i)
100071c4:	45a1      	cmp	r9, r4
100071c6:	d1ea      	bne.n	1000719e <_cyhal_utils_allocate_clock+0x2a>
100071c8:	e036      	b.n	10007238 <_cyhal_utils_allocate_clock+0xc4>
    switch (clocked_item->type)
100071ca:	3c14      	subs	r4, #20
100071cc:	2c09      	cmp	r4, #9
100071ce:	d8e1      	bhi.n	10007194 <_cyhal_utils_allocate_clock+0x20>
100071d0:	a301      	add	r3, pc, #4	; (adr r3, 100071d8 <_cyhal_utils_allocate_clock+0x64>)
100071d2:	f853 f024 	ldr.w	pc, [r3, r4, lsl #2]
100071d6:	bf00      	nop
100071d8:	10007201 	.word	0x10007201
100071dc:	10007217 	.word	0x10007217
100071e0:	10007195 	.word	0x10007195
100071e4:	10007195 	.word	0x10007195
100071e8:	1000721f 	.word	0x1000721f
100071ec:	10007195 	.word	0x10007195
100071f0:	10007195 	.word	0x10007195
100071f4:	10007195 	.word	0x10007195
100071f8:	10007195 	.word	0x10007195
100071fc:	1000721b 	.word	0x1000721b
    {
        /* High frequency clock assignments are device specific. */
#if defined(CY_DEVICE_PSOC6ABLE2) || defined(CY_DEVICE_PSOC6A2M)
        case CYHAL_RSC_I2S:
        case CYHAL_RSC_PDM:
            clock_rsc = CYHAL_CLOCK_HF[1];
10007200:	4b11      	ldr	r3, [pc, #68]	; (10007248 <_cyhal_utils_allocate_clock+0xd4>)
#if defined(CY_DEVICE_PSOC6ABLE2) || defined(CY_DEVICE_PSOC6A2M) || defined(CY_DEVICE_PSOC6A512K) || defined(CY_DEVICE_PSOC6A256K)
        case CYHAL_RSC_SMIF:
            clock_rsc = CYHAL_CLOCK_HF[2];
            break;
        case CYHAL_RSC_USB:
            clock_rsc = CYHAL_CLOCK_HF[3];
10007202:	e893 0003 	ldmia.w	r3, {r0, r1}
10007206:	ab02      	add	r3, sp, #8
10007208:	e903 0003 	stmdb	r3, {r0, r1}
            CY_ASSERT(false); /* Use APIs provided by the clock driver */
            return CYHAL_CLOCK_RSLT_ERR_NOT_SUPPORTED;
        default:
            return _cyhal_utils_allocate_peri(clock, 0, div, accept_larger);
    }
    return cyhal_clock_reserve(clock, &clock_rsc);
1000720c:	4669      	mov	r1, sp
1000720e:	4628      	mov	r0, r5
10007210:	f001 fd32 	bl	10008c78 <cyhal_clock_reserve>
10007214:	e010      	b.n	10007238 <_cyhal_utils_allocate_clock+0xc4>
            clock_rsc = CYHAL_CLOCK_HF[2];
10007216:	4b0d      	ldr	r3, [pc, #52]	; (1000724c <_cyhal_utils_allocate_clock+0xd8>)
10007218:	e7f3      	b.n	10007202 <_cyhal_utils_allocate_clock+0x8e>
            clock_rsc = CYHAL_CLOCK_HF[3];
1000721a:	4b0d      	ldr	r3, [pc, #52]	; (10007250 <_cyhal_utils_allocate_clock+0xdc>)
1000721c:	e7f1      	b.n	10007202 <_cyhal_utils_allocate_clock+0x8e>
                : CYHAL_CLOCK_HF[2];
1000721e:	784a      	ldrb	r2, [r1, #1]
10007220:	466b      	mov	r3, sp
10007222:	b92a      	cbnz	r2, 10007230 <_cyhal_utils_allocate_clock+0xbc>
            clock_rsc = (clocked_item->block_num == 0)
10007224:	4a0b      	ldr	r2, [pc, #44]	; (10007254 <_cyhal_utils_allocate_clock+0xe0>)
10007226:	e892 0003 	ldmia.w	r2, {r0, r1}
1000722a:	e883 0003 	stmia.w	r3, {r0, r1}
1000722e:	e7ed      	b.n	1000720c <_cyhal_utils_allocate_clock+0x98>
10007230:	4a06      	ldr	r2, [pc, #24]	; (1000724c <_cyhal_utils_allocate_clock+0xd8>)
10007232:	e7f8      	b.n	10007226 <_cyhal_utils_allocate_clock+0xb2>
10007234:	be01      	bkpt	0x0001
            return CYHAL_CLOCK_RSLT_ERR_NOT_SUPPORTED;
10007236:	4808      	ldr	r0, [pc, #32]	; (10007258 <_cyhal_utils_allocate_clock+0xe4>)
}
10007238:	b003      	add	sp, #12
1000723a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
1000723e:	bf00      	nop
10007240:	1000a194 	.word	0x1000a194
10007244:	04020d02 	.word	0x04020d02
10007248:	100094d4 	.word	0x100094d4
1000724c:	100094dc 	.word	0x100094dc
10007250:	100094e4 	.word	0x100094e4
10007254:	100094ec 	.word	0x100094ec
10007258:	04020202 	.word	0x04020202

1000725c <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
1000725c:	4b10      	ldr	r3, [pc, #64]	; (100072a0 <z_sys_init_run_level+0x44>)
{
1000725e:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
10007260:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
10007264:	3001      	adds	r0, #1
10007266:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
1000726a:	42a6      	cmp	r6, r4
1000726c:	d800      	bhi.n	10007270 <z_sys_init_run_level+0x14>
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
1000726e:	bd70      	pop	{r4, r5, r6, pc}
			if (entry->init_fn.dev != NULL) {
10007270:	e9d4 3500 	ldrd	r3, r5, [r4]
		if (dev != NULL) {
10007274:	b195      	cbz	r5, 1000729c <z_sys_init_run_level+0x40>
			if (entry->init_fn.dev != NULL) {
10007276:	b153      	cbz	r3, 1000728e <z_sys_init_run_level+0x32>
				rc = entry->init_fn.dev(dev);
10007278:	4628      	mov	r0, r5
1000727a:	4798      	blx	r3
				if (rc != 0) {
1000727c:	b138      	cbz	r0, 1000728e <z_sys_init_run_level+0x32>
					if (rc < 0) {
1000727e:	2800      	cmp	r0, #0
10007280:	bfb8      	it	lt
10007282:	4240      	neglt	r0, r0
					dev->state->init_res = rc;
10007284:	68eb      	ldr	r3, [r5, #12]
					if (rc > UINT8_MAX) {
10007286:	28ff      	cmp	r0, #255	; 0xff
10007288:	bfa8      	it	ge
1000728a:	20ff      	movge	r0, #255	; 0xff
					dev->state->init_res = rc;
1000728c:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
1000728e:	68ea      	ldr	r2, [r5, #12]
10007290:	7853      	ldrb	r3, [r2, #1]
10007292:	f043 0301 	orr.w	r3, r3, #1
10007296:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
10007298:	3408      	adds	r4, #8
1000729a:	e7e6      	b.n	1000726a <z_sys_init_run_level+0xe>
			(void)entry->init_fn.sys();
1000729c:	4798      	blx	r3
1000729e:	e7fb      	b.n	10007298 <z_sys_init_run_level+0x3c>
100072a0:	10009790 	.word	0x10009790

100072a4 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
100072a4:	b508      	push	{r3, lr}
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
100072a6:	4b0a      	ldr	r3, [pc, #40]	; (100072d0 <bg_thread_main+0x2c>)
100072a8:	2201      	movs	r2, #1

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
100072aa:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
100072ac:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
100072ae:	f7ff ffd5 	bl	1000725c <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
100072b2:	f000 fd69 	bl	10007d88 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
100072b6:	2004      	movs	r0, #4
100072b8:	f7ff ffd0 	bl	1000725c <z_sys_init_run_level>

	z_init_static_threads();
100072bc:	f000 f8fa 	bl	100074b4 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
100072c0:	f7fb fb54 	bl	1000296c <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
100072c4:	4a03      	ldr	r2, [pc, #12]	; (100072d4 <bg_thread_main+0x30>)
100072c6:	7b13      	ldrb	r3, [r2, #12]
100072c8:	f023 0301 	bic.w	r3, r3, #1
100072cc:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
100072ce:	bd08      	pop	{r3, pc}
100072d0:	08003806 	.word	0x08003806
100072d4:	08002f68 	.word	0x08002f68

100072d8 <z_bss_zero>:
{
100072d8:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
100072da:	4803      	ldr	r0, [pc, #12]	; (100072e8 <z_bss_zero+0x10>)
100072dc:	4a03      	ldr	r2, [pc, #12]	; (100072ec <z_bss_zero+0x14>)
100072de:	2100      	movs	r1, #0
100072e0:	1a12      	subs	r2, r2, r0
100072e2:	f001 fddb 	bl	10008e9c <z_early_memset>
}
100072e6:	bd08      	pop	{r3, pc}
100072e8:	08002ed8 	.word	0x08002ed8
100072ec:	08003808 	.word	0x08003808

100072f0 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
100072f0:	b570      	push	{r4, r5, r6, lr}
	z_setup_new_thread(thread, stack,
100072f2:	2300      	movs	r3, #0
{
100072f4:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
100072f6:	2201      	movs	r2, #1
100072f8:	e9cd 2304 	strd	r2, r3, [sp, #16]
	struct k_thread *thread = &z_idle_threads[i];
100072fc:	4e19      	ldr	r6, [pc, #100]	; (10007364 <z_init_cpu+0x74>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
100072fe:	4d1a      	ldr	r5, [pc, #104]	; (10007368 <z_init_cpu+0x78>)
	z_setup_new_thread(thread, stack,
10007300:	9301      	str	r3, [sp, #4]
10007302:	220f      	movs	r2, #15
10007304:	e9cd 3202 	strd	r3, r2, [sp, #8]
10007308:	4918      	ldr	r1, [pc, #96]	; (1000736c <z_init_cpu+0x7c>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
1000730a:	2314      	movs	r3, #20
1000730c:	fb03 5500 	mla	r5, r3, r0, r5
	struct k_thread *thread = &z_idle_threads[i];
10007310:	eb06 16c0 	add.w	r6, r6, r0, lsl #7
{
10007314:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
10007316:	f44f 70c0 	mov.w	r0, #384	; 0x180
1000731a:	4b15      	ldr	r3, [pc, #84]	; (10007370 <z_init_cpu+0x80>)
1000731c:	9500      	str	r5, [sp, #0]
1000731e:	f44f 72a0 	mov.w	r2, #320	; 0x140
10007322:	fb00 1104 	mla	r1, r0, r4, r1
10007326:	4630      	mov	r0, r6
10007328:	f000 f892 	bl	10007450 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
1000732c:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
1000732e:	4a11      	ldr	r2, [pc, #68]	; (10007374 <z_init_cpu+0x84>)
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
10007330:	60ee      	str	r6, [r5, #12]
10007332:	f023 0304 	bic.w	r3, r3, #4
10007336:	7373      	strb	r3, [r6, #13]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
10007338:	f44f 6304 	mov.w	r3, #2112	; 0x840
1000733c:	fb04 3303 	mla	r3, r4, r3, r3
10007340:	4413      	add	r3, r2
	_kernel.cpus[id].irq_stack =
10007342:	606b      	str	r3, [r5, #4]
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
10007344:	4b0c      	ldr	r3, [pc, #48]	; (10007378 <z_init_cpu+0x88>)
	_kernel.cpus[id].id = id;
10007346:	742c      	strb	r4, [r5, #16]
10007348:	f3bf 8f5b 	dmb	ish
1000734c:	e853 1f00 	ldrex	r1, [r3]
10007350:	3101      	adds	r1, #1
10007352:	e843 1200 	strex	r2, r1, [r3]
10007356:	2a00      	cmp	r2, #0
10007358:	d1f8      	bne.n	1000734c <z_init_cpu+0x5c>
1000735a:	f3bf 8f5b 	dmb	ish
	/*
	 * Increment number of CPUs active. The pm subsystem
	 * will keep track of this from here.
	 */
	atomic_inc(&_cpus_active);
}
1000735e:	b006      	add	sp, #24
10007360:	bd70      	pop	{r4, r5, r6, pc}
10007362:	bf00      	nop
10007364:	08002ee8 	.word	0x08002ee8
10007368:	080037a0 	.word	0x080037a0
1000736c:	08004080 	.word	0x08004080
10007370:	10008ea5 	.word	0x10008ea5
10007374:	08003840 	.word	0x08003840
10007378:	0800379c 	.word	0x0800379c

1000737c <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
1000737c:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
1000737e:	2000      	movs	r0, #0
{
10007380:	b0a6      	sub	sp, #152	; 0x98
	z_sys_init_run_level(INIT_LEVEL_EARLY);
10007382:	f7ff ff6b 	bl	1000725c <z_sys_init_run_level>
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
10007386:	4b2b      	ldr	r3, [pc, #172]	; (10007434 <z_cstart+0xb8>)
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
10007388:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
1000738c:	4d2a      	ldr	r5, [pc, #168]	; (10007438 <z_cstart+0xbc>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
1000738e:	4e2b      	ldr	r6, [pc, #172]	; (1000743c <z_cstart+0xc0>)
10007390:	696b      	ldr	r3, [r5, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
10007392:	4f2b      	ldr	r7, [pc, #172]	; (10007440 <z_cstart+0xc4>)
10007394:	f443 7300 	orr.w	r3, r3, #512	; 0x200
10007398:	616b      	str	r3, [r5, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
1000739a:	2400      	movs	r4, #0
1000739c:	23e0      	movs	r3, #224	; 0xe0
1000739e:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
100073a2:	77ec      	strb	r4, [r5, #31]
100073a4:	762c      	strb	r4, [r5, #24]
100073a6:	766c      	strb	r4, [r5, #25]
100073a8:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
100073aa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
100073ac:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
100073b0:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
100073b2:	f7fc f9ab 	bl	1000370c <z_arm_fault_init>
	z_arm_cpu_idle_init();
100073b6:	f7fb ff5d 	bl	10003274 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
100073ba:	f04f 33ff 	mov.w	r3, #4294967295
100073be:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
100073c0:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
100073c2:	f7fc fa85 	bl	100038d0 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
100073c6:	f7fc f9eb 	bl	100037a0 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
100073ca:	f240 1301 	movw	r3, #257	; 0x101
100073ce:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
100073d2:	ab06      	add	r3, sp, #24
100073d4:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
100073d6:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	dummy_thread->resource_pool = NULL;
100073da:	9422      	str	r4, [sp, #136]	; 0x88
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
100073dc:	f001 fd2b 	bl	10008e36 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
100073e0:	2001      	movs	r0, #1
100073e2:	f7ff ff3b 	bl	1000725c <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
100073e6:	2002      	movs	r0, #2
	_kernel.ready_q.cache = &z_main_thread;
100073e8:	4d16      	ldr	r5, [pc, #88]	; (10007444 <z_cstart+0xc8>)
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
100073ea:	f7ff ff37 	bl	1000725c <z_sys_init_run_level>
	z_sched_init();
100073ee:	f000 fa69 	bl	100078c4 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
100073f2:	4b15      	ldr	r3, [pc, #84]	; (10007448 <z_cstart+0xcc>)
	_kernel.ready_q.cache = &z_main_thread;
100073f4:	6175      	str	r5, [r6, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
100073f6:	9305      	str	r3, [sp, #20]
100073f8:	2301      	movs	r3, #1
100073fa:	4914      	ldr	r1, [pc, #80]	; (1000744c <z_cstart+0xd0>)
100073fc:	9400      	str	r4, [sp, #0]
100073fe:	e9cd 4303 	strd	r4, r3, [sp, #12]
10007402:	f44f 6280 	mov.w	r2, #1024	; 0x400
10007406:	463b      	mov	r3, r7
10007408:	e9cd 4401 	strd	r4, r4, [sp, #4]
1000740c:	4628      	mov	r0, r5
1000740e:	f000 f81f 	bl	10007450 <z_setup_new_thread>
10007412:	7b6a      	ldrb	r2, [r5, #13]
10007414:	4606      	mov	r6, r0
10007416:	f022 0204 	bic.w	r2, r2, #4
	z_ready_thread(&z_main_thread);
1000741a:	4628      	mov	r0, r5
1000741c:	736a      	strb	r2, [r5, #13]
1000741e:	f001 fd5f 	bl	10008ee0 <z_ready_thread>
	z_init_cpu(0);
10007422:	4620      	mov	r0, r4
10007424:	f7ff ff64 	bl	100072f0 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
10007428:	463a      	mov	r2, r7
1000742a:	4631      	mov	r1, r6
1000742c:	4628      	mov	r0, r5
1000742e:	f7fb fff7 	bl	10003420 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
10007432:	bf00      	nop
10007434:	08004080 	.word	0x08004080
10007438:	e000ed00 	.word	0xe000ed00
1000743c:	080037a0 	.word	0x080037a0
10007440:	100072a5 	.word	0x100072a5
10007444:	08002f68 	.word	0x08002f68
10007448:	1000a198 	.word	0x1000a198
1000744c:	08004200 	.word	0x08004200

10007450 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
10007450:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
10007454:	9e0e      	ldr	r6, [sp, #56]	; 0x38
10007456:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
10007458:	2604      	movs	r6, #4
1000745a:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
1000745c:	9e0d      	ldr	r6, [sp, #52]	; 0x34
1000745e:	7386      	strb	r6, [r0, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
10007460:	f100 0558 	add.w	r5, r0, #88	; 0x58
{
10007464:	460f      	mov	r7, r1
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
10007466:	1dd6      	adds	r6, r2, #7
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
10007468:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
1000746c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	thread_base->pended_on = NULL;
1000746e:	2500      	movs	r5, #0
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
10007470:	f026 0607 	bic.w	r6, r6, #7

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
10007474:	3740      	adds	r7, #64	; 0x40
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
10007476:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
1000747a:	e9c0 7619 	strd	r7, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
1000747e:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
10007480:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
10007482:	66c5      	str	r5, [r0, #108]	; 0x6c
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
10007484:	f106 0840 	add.w	r8, r6, #64	; 0x40
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
10007488:	9202      	str	r2, [sp, #8]
1000748a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
1000748c:	9201      	str	r2, [sp, #4]
	stack_ptr = (char *)stack + stack_obj_size;
1000748e:	4488      	add	r8, r1
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
10007490:	9a0a      	ldr	r2, [sp, #40]	; 0x28
10007492:	9200      	str	r2, [sp, #0]
10007494:	4642      	mov	r2, r8
{
10007496:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
10007498:	f7fb ff90 	bl	100033bc <arch_new_thread>
	if (!_current) {
1000749c:	4b04      	ldr	r3, [pc, #16]	; (100074b0 <z_setup_new_thread+0x60>)
	new_thread->init_data = NULL;
1000749e:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
100074a0:	689b      	ldr	r3, [r3, #8]
100074a2:	b103      	cbz	r3, 100074a6 <z_setup_new_thread+0x56>
	new_thread->resource_pool = _current->resource_pool;
100074a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
	return stack_ptr;
100074a6:	6723      	str	r3, [r4, #112]	; 0x70
}
100074a8:	4640      	mov	r0, r8
100074aa:	b004      	add	sp, #16
100074ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
100074b0:	080037a0 	.word	0x080037a0

100074b4 <z_init_static_threads>:
{
100074b4:	b5f0      	push	{r4, r5, r6, r7, lr}
100074b6:	4c22      	ldr	r4, [pc, #136]	; (10007540 <z_init_static_threads+0x8c>)
	_FOREACH_STATIC_THREAD(thread_data) {
100074b8:	4d22      	ldr	r5, [pc, #136]	; (10007544 <z_init_static_threads+0x90>)
{
100074ba:	b087      	sub	sp, #28
100074bc:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
100074be:	42ae      	cmp	r6, r5
100074c0:	f104 042c 	add.w	r4, r4, #44	; 0x2c
100074c4:	d30b      	bcc.n	100074de <z_init_static_threads+0x2a>
	k_sched_lock();
100074c6:	f000 f9cd 	bl	10007864 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
100074ca:	4c1d      	ldr	r4, [pc, #116]	; (10007540 <z_init_static_threads+0x8c>)

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
100074cc:	4f1e      	ldr	r7, [pc, #120]	; (10007548 <z_init_static_threads+0x94>)
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
100074ce:	260a      	movs	r6, #10
100074d0:	42ac      	cmp	r4, r5
100074d2:	d320      	bcc.n	10007516 <z_init_static_threads+0x62>
}
100074d4:	b007      	add	sp, #28
100074d6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	k_sched_unlock();
100074da:	f000 b9d7 	b.w	1000788c <k_sched_unlock>
		z_setup_new_thread(
100074de:	f854 3c04 	ldr.w	r3, [r4, #-4]
100074e2:	9305      	str	r3, [sp, #20]
100074e4:	f854 3c0c 	ldr.w	r3, [r4, #-12]
100074e8:	9304      	str	r3, [sp, #16]
100074ea:	f854 3c10 	ldr.w	r3, [r4, #-16]
100074ee:	9303      	str	r3, [sp, #12]
100074f0:	f854 3c14 	ldr.w	r3, [r4, #-20]
100074f4:	9302      	str	r3, [sp, #8]
100074f6:	f854 3c18 	ldr.w	r3, [r4, #-24]
100074fa:	9301      	str	r3, [sp, #4]
100074fc:	f854 3c1c 	ldr.w	r3, [r4, #-28]
10007500:	9300      	str	r3, [sp, #0]
10007502:	e954 2309 	ldrd	r2, r3, [r4, #-36]	; 0x24
10007506:	e954 010b 	ldrd	r0, r1, [r4, #-44]	; 0x2c
1000750a:	f7ff ffa1 	bl	10007450 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
1000750e:	f854 3c2c 	ldr.w	r3, [r4, #-44]
10007512:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
10007514:	e7d2      	b.n	100074bc <z_init_static_threads+0x8>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
10007516:	6a62      	ldr	r2, [r4, #36]	; 0x24
10007518:	1c53      	adds	r3, r2, #1
1000751a:	d009      	beq.n	10007530 <z_init_static_threads+0x7c>
					    K_MSEC(thread_data->init_delay));
1000751c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
10007520:	fb82 2306 	smull	r2, r3, r2, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
10007524:	ea52 0103 	orrs.w	r1, r2, r3
			schedule_new_thread(thread_data->init_thread,
10007528:	6820      	ldr	r0, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
1000752a:	d103      	bne.n	10007534 <z_init_static_threads+0x80>
	z_sched_start(thread);
1000752c:	f000 f94a 	bl	100077c4 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
10007530:	342c      	adds	r4, #44	; 0x2c
10007532:	e7cd      	b.n	100074d0 <z_init_static_threads+0x1c>
10007534:	4639      	mov	r1, r7
10007536:	3018      	adds	r0, #24
10007538:	f000 fb2c 	bl	10007b94 <z_add_timeout>
1000753c:	e7f8      	b.n	10007530 <z_init_static_threads+0x7c>
1000753e:	bf00      	nop
10007540:	100090e4 	.word	0x100090e4
10007544:	100090e4 	.word	0x100090e4
10007548:	10008f45 	.word	0x10008f45

1000754c <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
1000754c:	89c3      	ldrh	r3, [r0, #14]
1000754e:	2b7f      	cmp	r3, #127	; 0x7f
10007550:	d812      	bhi.n	10007578 <sliceable+0x2c>
	int ret = slice_ticks;
10007552:	4b0a      	ldr	r3, [pc, #40]	; (1000757c <sliceable+0x30>)
10007554:	681b      	ldr	r3, [r3, #0]
		&& slice_time(thread) != 0
10007556:	b163      	cbz	r3, 10007572 <sliceable+0x26>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
10007558:	4b09      	ldr	r3, [pc, #36]	; (10007580 <sliceable+0x34>)
1000755a:	f990 200e 	ldrsb.w	r2, [r0, #14]
1000755e:	681b      	ldr	r3, [r3, #0]
10007560:	429a      	cmp	r2, r3
10007562:	db09      	blt.n	10007578 <sliceable+0x2c>
		&& !z_is_thread_prevented_from_running(thread)
10007564:	7b43      	ldrb	r3, [r0, #13]
10007566:	06db      	lsls	r3, r3, #27
10007568:	d106      	bne.n	10007578 <sliceable+0x2c>
		&& !z_is_idle_thread_object(thread);
1000756a:	4b06      	ldr	r3, [pc, #24]	; (10007584 <sliceable+0x38>)
1000756c:	1ac3      	subs	r3, r0, r3
1000756e:	bf18      	it	ne
10007570:	2301      	movne	r3, #1
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
10007572:	f003 0001 	and.w	r0, r3, #1
10007576:	4770      	bx	lr
		&& !z_is_idle_thread_object(thread);
10007578:	2300      	movs	r3, #0
1000757a:	e7fa      	b.n	10007572 <sliceable+0x26>
1000757c:	080037c8 	.word	0x080037c8
10007580:	080037c4 	.word	0x080037c4
10007584:	08002ee8 	.word	0x08002ee8

10007588 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
10007588:	4b04      	ldr	r3, [pc, #16]	; (1000759c <slice_timeout+0x14>)
1000758a:	1ac0      	subs	r0, r0, r3
1000758c:	4b04      	ldr	r3, [pc, #16]	; (100075a0 <slice_timeout+0x18>)
1000758e:	10c0      	asrs	r0, r0, #3
10007590:	4358      	muls	r0, r3

	slice_expired[cpu] = true;
10007592:	4b04      	ldr	r3, [pc, #16]	; (100075a4 <slice_timeout+0x1c>)
10007594:	2201      	movs	r2, #1
10007596:	541a      	strb	r2, [r3, r0]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
10007598:	4770      	bx	lr
1000759a:	bf00      	nop
1000759c:	08002fe8 	.word	0x08002fe8
100075a0:	aaaaaaab 	.word	0xaaaaaaab
100075a4:	08003807 	.word	0x08003807

100075a8 <z_reset_time_slice>:

void z_reset_time_slice(struct k_thread *curr)
{
100075a8:	b570      	push	{r4, r5, r6, lr}
	int cpu = _current_cpu->id;
100075aa:	4b0e      	ldr	r3, [pc, #56]	; (100075e4 <z_reset_time_slice+0x3c>)

	z_abort_timeout(&slice_timeouts[cpu]);
100075ac:	4c0e      	ldr	r4, [pc, #56]	; (100075e8 <z_reset_time_slice+0x40>)
	int cpu = _current_cpu->id;
100075ae:	7c1e      	ldrb	r6, [r3, #16]
	z_abort_timeout(&slice_timeouts[cpu]);
100075b0:	eb06 0346 	add.w	r3, r6, r6, lsl #1
100075b4:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
{
100075b8:	4605      	mov	r5, r0
	z_abort_timeout(&slice_timeouts[cpu]);
100075ba:	4620      	mov	r0, r4
100075bc:	f001 fcdc 	bl	10008f78 <z_abort_timeout>
	slice_expired[cpu] = false;
100075c0:	4b0a      	ldr	r3, [pc, #40]	; (100075ec <z_reset_time_slice+0x44>)
100075c2:	2200      	movs	r2, #0
	if (sliceable(curr)) {
100075c4:	4628      	mov	r0, r5
	slice_expired[cpu] = false;
100075c6:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
100075c8:	f7ff ffc0 	bl	1000754c <sliceable>
100075cc:	b148      	cbz	r0, 100075e2 <z_reset_time_slice+0x3a>
	int ret = slice_ticks;
100075ce:	4b08      	ldr	r3, [pc, #32]	; (100075f0 <z_reset_time_slice+0x48>)
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
100075d0:	4908      	ldr	r1, [pc, #32]	; (100075f4 <z_reset_time_slice+0x4c>)
			      K_TICKS(slice_time(curr) - 1));
100075d2:	681a      	ldr	r2, [r3, #0]
100075d4:	3a01      	subs	r2, #1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
100075d6:	4620      	mov	r0, r4
100075d8:	17d3      	asrs	r3, r2, #31
	}
}
100075da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
100075de:	f000 bad9 	b.w	10007b94 <z_add_timeout>
}
100075e2:	bd70      	pop	{r4, r5, r6, pc}
100075e4:	080037a0 	.word	0x080037a0
100075e8:	08002fe8 	.word	0x08002fe8
100075ec:	08003807 	.word	0x08003807
100075f0:	080037c8 	.word	0x080037c8
100075f4:	10007589 	.word	0x10007589

100075f8 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
100075f8:	b538      	push	{r3, r4, r5, lr}
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
100075fa:	4d0d      	ldr	r5, [pc, #52]	; (10007630 <update_cache+0x38>)
100075fc:	462b      	mov	r3, r5
100075fe:	f853 4f18 	ldr.w	r4, [r3, #24]!
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
10007602:	429c      	cmp	r4, r3
10007604:	d000      	beq.n	10007608 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
10007606:	b904      	cbnz	r4, 1000760a <update_cache+0x12>
10007608:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
1000760a:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
1000760c:	b938      	cbnz	r0, 1000761e <update_cache+0x26>
	if (z_is_thread_prevented_from_running(_current)) {
1000760e:	7b5a      	ldrb	r2, [r3, #13]
10007610:	06d2      	lsls	r2, r2, #27
10007612:	d104      	bne.n	1000761e <update_cache+0x26>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
10007614:	69a2      	ldr	r2, [r4, #24]
10007616:	b912      	cbnz	r2, 1000761e <update_cache+0x26>
	if (is_preempt(_current) || is_metairq(thread)) {
10007618:	89da      	ldrh	r2, [r3, #14]
1000761a:	2a7f      	cmp	r2, #127	; 0x7f
1000761c:	d805      	bhi.n	1000762a <update_cache+0x32>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
1000761e:	429c      	cmp	r4, r3
10007620:	d002      	beq.n	10007628 <update_cache+0x30>
			z_reset_time_slice(thread);
10007622:	4620      	mov	r0, r4
10007624:	f7ff ffc0 	bl	100075a8 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
10007628:	4623      	mov	r3, r4
1000762a:	616b      	str	r3, [r5, #20]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
1000762c:	bd38      	pop	{r3, r4, r5, pc}
1000762e:	bf00      	nop
10007630:	080037a0 	.word	0x080037a0

10007634 <move_thread_to_end_of_prio_q>:
{
10007634:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
10007636:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
1000763a:	7b43      	ldrb	r3, [r0, #13]
1000763c:	2a00      	cmp	r2, #0
{
1000763e:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
10007640:	da04      	bge.n	1000764c <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
10007642:	f003 037f 	and.w	r3, r3, #127	; 0x7f
10007646:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
10007648:	f001 fc38 	bl	10008ebc <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
1000764c:	7b4b      	ldrb	r3, [r1, #13]
	return list->head == list;
1000764e:	4a15      	ldr	r2, [pc, #84]	; (100076a4 <move_thread_to_end_of_prio_q+0x70>)
10007650:	f063 037f 	orn	r3, r3, #127	; 0x7f
10007654:	4610      	mov	r0, r2
10007656:	734b      	strb	r3, [r1, #13]
10007658:	f850 3f18 	ldr.w	r3, [r0, #24]!
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
1000765c:	69d4      	ldr	r4, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
1000765e:	4283      	cmp	r3, r0
10007660:	bf08      	it	eq
10007662:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
10007664:	b923      	cbnz	r3, 10007670 <move_thread_to_end_of_prio_q+0x3c>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
10007666:	e9c1 0400 	strd	r0, r4, [r1]

	tail->next = node;
1000766a:	6021      	str	r1, [r4, #0]
	list->tail = node;
1000766c:	61d1      	str	r1, [r2, #28]
}
1000766e:	e00c      	b.n	1000768a <move_thread_to_end_of_prio_q+0x56>
	int32_t b1 = thread_1->base.prio;
10007670:	f991 500e 	ldrsb.w	r5, [r1, #14]
	int32_t b2 = thread_2->base.prio;
10007674:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
10007678:	42b5      	cmp	r5, r6
1000767a:	d00e      	beq.n	1000769a <move_thread_to_end_of_prio_q+0x66>
		if (z_sched_prio_cmp(thread, t) > 0) {
1000767c:	42ae      	cmp	r6, r5
1000767e:	dd0c      	ble.n	1000769a <move_thread_to_end_of_prio_q+0x66>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
10007680:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
10007682:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
10007686:	6001      	str	r1, [r0, #0]
	successor->prev = node;
10007688:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
1000768a:	6890      	ldr	r0, [r2, #8]
1000768c:	1a43      	subs	r3, r0, r1
1000768e:	4258      	negs	r0, r3
}
10007690:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
10007694:	4158      	adcs	r0, r3
10007696:	f7ff bfaf 	b.w	100075f8 <update_cache>
	return (node == list->tail) ? NULL : node->next;
1000769a:	429c      	cmp	r4, r3
1000769c:	d0e3      	beq.n	10007666 <move_thread_to_end_of_prio_q+0x32>
1000769e:	681b      	ldr	r3, [r3, #0]
100076a0:	e7e0      	b.n	10007664 <move_thread_to_end_of_prio_q+0x30>
100076a2:	bf00      	nop
100076a4:	080037a0 	.word	0x080037a0

100076a8 <ready_thread>:
{
100076a8:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
100076aa:	f990 300d 	ldrsb.w	r3, [r0, #13]
100076ae:	7b42      	ldrb	r2, [r0, #13]
100076b0:	2b00      	cmp	r3, #0
100076b2:	db29      	blt.n	10007708 <ready_thread+0x60>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
100076b4:	06d3      	lsls	r3, r2, #27
100076b6:	d127      	bne.n	10007708 <ready_thread+0x60>
	return node->next != NULL;
100076b8:	6983      	ldr	r3, [r0, #24]
100076ba:	bb2b      	cbnz	r3, 10007708 <ready_thread+0x60>
	return list->head == list;
100076bc:	4913      	ldr	r1, [pc, #76]	; (1000770c <ready_thread+0x64>)
	thread->base.thread_state |= _THREAD_QUEUED;
100076be:	f062 027f 	orn	r2, r2, #127	; 0x7f
100076c2:	7342      	strb	r2, [r0, #13]
100076c4:	460a      	mov	r2, r1
100076c6:	f852 4f18 	ldr.w	r4, [r2, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
100076ca:	4294      	cmp	r4, r2
100076cc:	bf18      	it	ne
100076ce:	4623      	movne	r3, r4
	return (node == list->tail) ? NULL : node->next;
100076d0:	69cc      	ldr	r4, [r1, #28]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
100076d2:	b923      	cbnz	r3, 100076de <ready_thread+0x36>
	node->prev = tail;
100076d4:	e9c0 2400 	strd	r2, r4, [r0]
	tail->next = node;
100076d8:	6020      	str	r0, [r4, #0]
	list->tail = node;
100076da:	61c8      	str	r0, [r1, #28]
}
100076dc:	e00c      	b.n	100076f8 <ready_thread+0x50>
	int32_t b1 = thread_1->base.prio;
100076de:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
100076e2:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
100076e6:	42b5      	cmp	r5, r6
100076e8:	d00a      	beq.n	10007700 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
100076ea:	42ae      	cmp	r6, r5
100076ec:	dd08      	ble.n	10007700 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
100076ee:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
100076f0:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
100076f4:	6010      	str	r0, [r2, #0]
	successor->prev = node;
100076f6:	6058      	str	r0, [r3, #4]
}
100076f8:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
100076fa:	2000      	movs	r0, #0
100076fc:	f7ff bf7c 	b.w	100075f8 <update_cache>
	return (node == list->tail) ? NULL : node->next;
10007700:	42a3      	cmp	r3, r4
10007702:	d0e7      	beq.n	100076d4 <ready_thread+0x2c>
10007704:	681b      	ldr	r3, [r3, #0]
10007706:	e7e4      	b.n	100076d2 <ready_thread+0x2a>
}
10007708:	bc70      	pop	{r4, r5, r6}
1000770a:	4770      	bx	lr
1000770c:	080037a0 	.word	0x080037a0

10007710 <unready_thread>:
{
10007710:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
10007712:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return (thread->base.thread_state & state) != 0U;
10007716:	7b43      	ldrb	r3, [r0, #13]
10007718:	2a00      	cmp	r2, #0
{
1000771a:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
1000771c:	da04      	bge.n	10007728 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
1000771e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
10007722:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
10007724:	f001 fbca 	bl	10008ebc <sys_dlist_remove>
	update_cache(thread == _current);
10007728:	4b04      	ldr	r3, [pc, #16]	; (1000773c <unready_thread+0x2c>)
1000772a:	6898      	ldr	r0, [r3, #8]
1000772c:	1a43      	subs	r3, r0, r1
1000772e:	4258      	negs	r0, r3
10007730:	4158      	adcs	r0, r3
}
10007732:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
10007736:	f7ff bf5f 	b.w	100075f8 <update_cache>
1000773a:	bf00      	nop
1000773c:	080037a0 	.word	0x080037a0

10007740 <z_time_slice>:
{
10007740:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
10007742:	f04f 0320 	mov.w	r3, #32
10007746:	f3ef 8511 	mrs	r5, BASEPRI
1000774a:	f383 8812 	msr	BASEPRI_MAX, r3
1000774e:	f3bf 8f6f 	isb	sy
	struct k_thread *curr = _current;
10007752:	4b10      	ldr	r3, [pc, #64]	; (10007794 <z_time_slice+0x54>)
	if (pending_current == curr) {
10007754:	4a10      	ldr	r2, [pc, #64]	; (10007798 <z_time_slice+0x58>)
	struct k_thread *curr = _current;
10007756:	689c      	ldr	r4, [r3, #8]
	if (pending_current == curr) {
10007758:	6810      	ldr	r0, [r2, #0]
1000775a:	42a0      	cmp	r0, r4
1000775c:	d106      	bne.n	1000776c <z_time_slice+0x2c>
		z_reset_time_slice(curr);
1000775e:	f7ff ff23 	bl	100075a8 <z_reset_time_slice>
	__asm__ volatile(
10007762:	f385 8811 	msr	BASEPRI, r5
10007766:	f3bf 8f6f 	isb	sy
}
1000776a:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
1000776c:	2100      	movs	r1, #0
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
1000776e:	7c1b      	ldrb	r3, [r3, #16]
	pending_current = NULL;
10007770:	6011      	str	r1, [r2, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
10007772:	4a0a      	ldr	r2, [pc, #40]	; (1000779c <z_time_slice+0x5c>)
10007774:	5cd3      	ldrb	r3, [r2, r3]
10007776:	2b00      	cmp	r3, #0
10007778:	d0f3      	beq.n	10007762 <z_time_slice+0x22>
1000777a:	4620      	mov	r0, r4
1000777c:	f7ff fee6 	bl	1000754c <sliceable>
10007780:	2800      	cmp	r0, #0
10007782:	d0ee      	beq.n	10007762 <z_time_slice+0x22>
		if (!z_is_thread_prevented_from_running(curr)) {
10007784:	7b63      	ldrb	r3, [r4, #13]
10007786:	06db      	lsls	r3, r3, #27
10007788:	d102      	bne.n	10007790 <z_time_slice+0x50>
			move_thread_to_end_of_prio_q(curr);
1000778a:	4620      	mov	r0, r4
1000778c:	f7ff ff52 	bl	10007634 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
10007790:	4620      	mov	r0, r4
10007792:	e7e4      	b.n	1000775e <z_time_slice+0x1e>
10007794:	080037a0 	.word	0x080037a0
10007798:	080037c0 	.word	0x080037c0
1000779c:	08003807 	.word	0x08003807

100077a0 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
100077a0:	b949      	cbnz	r1, 100077b6 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
100077a2:	f3ef 8005 	mrs	r0, IPSR
100077a6:	b930      	cbnz	r0, 100077b6 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
100077a8:	4b05      	ldr	r3, [pc, #20]	; (100077c0 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
100077aa:	695a      	ldr	r2, [r3, #20]
100077ac:	689b      	ldr	r3, [r3, #8]
100077ae:	429a      	cmp	r2, r3
100077b0:	d001      	beq.n	100077b6 <z_reschedule+0x16>
	ret = arch_swap(key);
100077b2:	f7fb bdaf 	b.w	10003314 <arch_swap>
100077b6:	f381 8811 	msr	BASEPRI, r1
100077ba:	f3bf 8f6f 	isb	sy
}
100077be:	4770      	bx	lr
100077c0:	080037a0 	.word	0x080037a0

100077c4 <z_sched_start>:
{
100077c4:	b510      	push	{r4, lr}
	__asm__ volatile(
100077c6:	f04f 0220 	mov.w	r2, #32
100077ca:	f3ef 8411 	mrs	r4, BASEPRI
100077ce:	f382 8812 	msr	BASEPRI_MAX, r2
100077d2:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
100077d6:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
100077d8:	0751      	lsls	r1, r2, #29
100077da:	d404      	bmi.n	100077e6 <z_sched_start+0x22>
	__asm__ volatile(
100077dc:	f384 8811 	msr	BASEPRI, r4
100077e0:	f3bf 8f6f 	isb	sy
}
100077e4:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
100077e6:	f022 0204 	bic.w	r2, r2, #4
100077ea:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
100077ec:	f7ff ff5c 	bl	100076a8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
100077f0:	4621      	mov	r1, r4
100077f2:	4802      	ldr	r0, [pc, #8]	; (100077fc <z_sched_start+0x38>)
}
100077f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
100077f8:	f7ff bfd2 	b.w	100077a0 <z_reschedule>
100077fc:	08003808 	.word	0x08003808

10007800 <z_impl_k_thread_suspend>:
{
10007800:	b570      	push	{r4, r5, r6, lr}
10007802:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
10007804:	3018      	adds	r0, #24
10007806:	f001 fbb7 	bl	10008f78 <z_abort_timeout>
	__asm__ volatile(
1000780a:	f04f 0320 	mov.w	r3, #32
1000780e:	f3ef 8611 	mrs	r6, BASEPRI
10007812:	f383 8812 	msr	BASEPRI_MAX, r3
10007816:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
1000781a:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
1000781e:	7b63      	ldrb	r3, [r4, #13]
10007820:	2a00      	cmp	r2, #0
10007822:	da05      	bge.n	10007830 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
10007824:	f003 037f 	and.w	r3, r3, #127	; 0x7f
10007828:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
1000782a:	4620      	mov	r0, r4
1000782c:	f001 fb46 	bl	10008ebc <sys_dlist_remove>
		update_cache(thread == _current);
10007830:	4d0b      	ldr	r5, [pc, #44]	; (10007860 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
10007832:	7b63      	ldrb	r3, [r4, #13]
10007834:	68a8      	ldr	r0, [r5, #8]
10007836:	f043 0310 	orr.w	r3, r3, #16
1000783a:	7363      	strb	r3, [r4, #13]
1000783c:	1b03      	subs	r3, r0, r4
1000783e:	4258      	negs	r0, r3
10007840:	4158      	adcs	r0, r3
10007842:	f7ff fed9 	bl	100075f8 <update_cache>
	__asm__ volatile(
10007846:	f386 8811 	msr	BASEPRI, r6
1000784a:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
1000784e:	68ab      	ldr	r3, [r5, #8]
10007850:	42a3      	cmp	r3, r4
10007852:	d103      	bne.n	1000785c <z_impl_k_thread_suspend+0x5c>
}
10007854:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
10007858:	f001 bb84 	b.w	10008f64 <z_reschedule_unlocked>
}
1000785c:	bd70      	pop	{r4, r5, r6, pc}
1000785e:	bf00      	nop
10007860:	080037a0 	.word	0x080037a0

10007864 <k_sched_lock>:
	__asm__ volatile(
10007864:	f04f 0320 	mov.w	r3, #32
10007868:	f3ef 8111 	mrs	r1, BASEPRI
1000786c:	f383 8812 	msr	BASEPRI_MAX, r3
10007870:	f3bf 8f6f 	isb	sy
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
10007874:	4b04      	ldr	r3, [pc, #16]	; (10007888 <k_sched_lock+0x24>)
10007876:	689a      	ldr	r2, [r3, #8]
10007878:	7bd3      	ldrb	r3, [r2, #15]
1000787a:	3b01      	subs	r3, #1
1000787c:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
1000787e:	f381 8811 	msr	BASEPRI, r1
10007882:	f3bf 8f6f 	isb	sy
}
10007886:	4770      	bx	lr
10007888:	080037a0 	.word	0x080037a0

1000788c <k_sched_unlock>:
{
1000788c:	b510      	push	{r4, lr}
	__asm__ volatile(
1000788e:	f04f 0320 	mov.w	r3, #32
10007892:	f3ef 8411 	mrs	r4, BASEPRI
10007896:	f383 8812 	msr	BASEPRI_MAX, r3
1000789a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
1000789e:	4b08      	ldr	r3, [pc, #32]	; (100078c0 <k_sched_unlock+0x34>)
100078a0:	689a      	ldr	r2, [r3, #8]
100078a2:	7bd3      	ldrb	r3, [r2, #15]
100078a4:	3301      	adds	r3, #1
100078a6:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
100078a8:	2000      	movs	r0, #0
100078aa:	f7ff fea5 	bl	100075f8 <update_cache>
	__asm__ volatile(
100078ae:	f384 8811 	msr	BASEPRI, r4
100078b2:	f3bf 8f6f 	isb	sy
}
100078b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
100078ba:	f001 bb53 	b.w	10008f64 <z_reschedule_unlocked>
100078be:	bf00      	nop
100078c0:	080037a0 	.word	0x080037a0

100078c4 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
100078c4:	4b02      	ldr	r3, [pc, #8]	; (100078d0 <z_sched_init+0xc>)
100078c6:	f103 0218 	add.w	r2, r3, #24
	list->tail = (sys_dnode_t *)list;
100078ca:	e9c3 2206 	strd	r2, r2, [r3, #24]
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
100078ce:	4770      	bx	lr
100078d0:	080037a0 	.word	0x080037a0

100078d4 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
100078d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
100078d6:	f04f 0320 	mov.w	r3, #32
100078da:	f3ef 8511 	mrs	r5, BASEPRI
100078de:	f383 8812 	msr	BASEPRI_MAX, r3
100078e2:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
100078e6:	4919      	ldr	r1, [pc, #100]	; (1000794c <z_impl_k_yield+0x78>)
100078e8:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
100078ea:	7b43      	ldrb	r3, [r0, #13]
100078ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
100078f0:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
100078f2:	f001 fae3 	bl	10008ebc <sys_dlist_remove>
	}
	queue_thread(_current);
100078f6:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
100078f8:	7b5a      	ldrb	r2, [r3, #13]
	return list->head == list;
100078fa:	4608      	mov	r0, r1
100078fc:	f062 027f 	orn	r2, r2, #127	; 0x7f
10007900:	735a      	strb	r2, [r3, #13]
10007902:	f850 2f18 	ldr.w	r2, [r0, #24]!
	return (node == list->tail) ? NULL : node->next;
10007906:	69cc      	ldr	r4, [r1, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
10007908:	4282      	cmp	r2, r0
1000790a:	bf08      	it	eq
1000790c:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
1000790e:	b922      	cbnz	r2, 1000791a <z_impl_k_yield+0x46>
	node->prev = tail;
10007910:	e9c3 0400 	strd	r0, r4, [r3]
	tail->next = node;
10007914:	6023      	str	r3, [r4, #0]
	list->tail = node;
10007916:	61cb      	str	r3, [r1, #28]
}
10007918:	e00c      	b.n	10007934 <z_impl_k_yield+0x60>
	int32_t b1 = thread_1->base.prio;
1000791a:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
1000791e:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
10007922:	42be      	cmp	r6, r7
10007924:	d00e      	beq.n	10007944 <z_impl_k_yield+0x70>
		if (z_sched_prio_cmp(thread, t) > 0) {
10007926:	42b7      	cmp	r7, r6
10007928:	dd0c      	ble.n	10007944 <z_impl_k_yield+0x70>
	sys_dnode_t *const prev = successor->prev;
1000792a:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
1000792c:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
10007930:	600b      	str	r3, [r1, #0]
	successor->prev = node;
10007932:	6053      	str	r3, [r2, #4]
	update_cache(1);
10007934:	2001      	movs	r0, #1
10007936:	f7ff fe5f 	bl	100075f8 <update_cache>
1000793a:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
1000793c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
10007940:	f7fb bce8 	b.w	10003314 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
10007944:	42a2      	cmp	r2, r4
10007946:	d0e3      	beq.n	10007910 <z_impl_k_yield+0x3c>
10007948:	6812      	ldr	r2, [r2, #0]
1000794a:	e7e0      	b.n	1000790e <z_impl_k_yield+0x3a>
1000794c:	080037a0 	.word	0x080037a0

10007950 <z_tick_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
10007950:	ea50 0301 	orrs.w	r3, r0, r1
{
10007954:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
10007958:	4605      	mov	r5, r0
1000795a:	460e      	mov	r6, r1
	if (ticks == 0) {
1000795c:	d103      	bne.n	10007966 <z_tick_sleep+0x16>
		(void) arch_syscall_invoke0(K_SYSCALL_K_YIELD);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_yield();
1000795e:	f7ff ffb9 	bl	100078d4 <z_impl_k_yield>
		k_yield();
		return 0;
10007962:	2000      	movs	r0, #0
10007964:	e02c      	b.n	100079c0 <z_tick_sleep+0x70>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
10007966:	1c83      	adds	r3, r0, #2
10007968:	f171 33ff 	sbcs.w	r3, r1, #4294967295
1000796c:	db2a      	blt.n	100079c4 <z_tick_sleep+0x74>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
1000796e:	f001 fb19 	bl	10008fa4 <sys_clock_tick_get_32>
10007972:	182c      	adds	r4, r5, r0
10007974:	f04f 0320 	mov.w	r3, #32
10007978:	f3ef 8811 	mrs	r8, BASEPRI
1000797c:	f383 8812 	msr	BASEPRI_MAX, r3
10007980:	f3bf 8f6f 	isb	sy
	}

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
10007984:	4f11      	ldr	r7, [pc, #68]	; (100079cc <z_tick_sleep+0x7c>)
10007986:	4b12      	ldr	r3, [pc, #72]	; (100079d0 <z_tick_sleep+0x80>)
10007988:	68b8      	ldr	r0, [r7, #8]
1000798a:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
1000798c:	f7ff fec0 	bl	10007710 <unready_thread>
	z_add_thread_timeout(_current, timeout);
10007990:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
10007992:	4910      	ldr	r1, [pc, #64]	; (100079d4 <z_tick_sleep+0x84>)
10007994:	462a      	mov	r2, r5
10007996:	4633      	mov	r3, r6
10007998:	3018      	adds	r0, #24
1000799a:	f000 f8fb 	bl	10007b94 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
1000799e:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
100079a0:	7b53      	ldrb	r3, [r2, #13]
100079a2:	f043 0310 	orr.w	r3, r3, #16
100079a6:	7353      	strb	r3, [r2, #13]
100079a8:	4640      	mov	r0, r8
100079aa:	f7fb fcb3 	bl	10003314 <arch_swap>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
100079ae:	f001 faf9 	bl	10008fa4 <sys_clock_tick_get_32>
100079b2:	1a20      	subs	r0, r4, r0
100079b4:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
100079b8:	2801      	cmp	r0, #1
100079ba:	f173 0300 	sbcs.w	r3, r3, #0
100079be:	dbd0      	blt.n	10007962 <z_tick_sleep+0x12>
		return ticks;
	}
#endif

	return 0;
}
100079c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
100079c4:	f06f 0401 	mvn.w	r4, #1
100079c8:	1a24      	subs	r4, r4, r0
100079ca:	e7d3      	b.n	10007974 <z_tick_sleep+0x24>
100079cc:	080037a0 	.word	0x080037a0
100079d0:	080037c0 	.word	0x080037c0
100079d4:	10008f45 	.word	0x10008f45

100079d8 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
100079d8:	f1b1 3fff 	cmp.w	r1, #4294967295
100079dc:	bf08      	it	eq
100079de:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
100079e2:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
100079e4:	d106      	bne.n	100079f4 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
100079e6:	4b07      	ldr	r3, [pc, #28]	; (10007a04 <z_impl_k_sleep+0x2c>)
100079e8:	6898      	ldr	r0, [r3, #8]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_SUSPEND);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_suspend(thread);
100079ea:	f7ff ff09 	bl	10007800 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
100079ee:	f04f 30ff 	mov.w	r0, #4294967295
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
100079f2:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
100079f4:	f7ff ffac 	bl	10007950 <z_tick_sleep>
			return t / ((uint64_t)from_hz / to_hz);
100079f8:	220a      	movs	r2, #10
100079fa:	2300      	movs	r3, #0
100079fc:	17c1      	asrs	r1, r0, #31
100079fe:	f7fa fccf 	bl	100023a0 <__aeabi_uldivmod>
	return ret;
10007a02:	e7f6      	b.n	100079f2 <z_impl_k_sleep+0x1a>
10007a04:	080037a0 	.word	0x080037a0

10007a08 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
10007a08:	4b01      	ldr	r3, [pc, #4]	; (10007a10 <z_impl_z_current_get+0x8>)
10007a0a:	6898      	ldr	r0, [r3, #8]
10007a0c:	4770      	bx	lr
10007a0e:	bf00      	nop
10007a10:	080037a0 	.word	0x080037a0

10007a14 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
10007a14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
10007a18:	4604      	mov	r4, r0
10007a1a:	f04f 0320 	mov.w	r3, #32
10007a1e:	f3ef 8611 	mrs	r6, BASEPRI
10007a22:	f383 8812 	msr	BASEPRI_MAX, r3
10007a26:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
10007a2a:	7b03      	ldrb	r3, [r0, #12]
10007a2c:	07d9      	lsls	r1, r3, #31
10007a2e:	d50b      	bpl.n	10007a48 <z_thread_abort+0x34>
	__asm__ volatile(
10007a30:	f386 8811 	msr	BASEPRI, r6
10007a34:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
10007a38:	4040      	eors	r0, r0
10007a3a:	f380 8811 	msr	BASEPRI, r0
10007a3e:	f04f 0004 	mov.w	r0, #4
10007a42:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
10007a44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
10007a48:	7b43      	ldrb	r3, [r0, #13]
10007a4a:	071a      	lsls	r2, r3, #28
10007a4c:	d504      	bpl.n	10007a58 <z_thread_abort+0x44>
10007a4e:	f386 8811 	msr	BASEPRI, r6
10007a52:	f3bf 8f6f 	isb	sy
10007a56:	e7f5      	b.n	10007a44 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
10007a58:	f023 0220 	bic.w	r2, r3, #32
10007a5c:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
10007a60:	09d2      	lsrs	r2, r2, #7
10007a62:	d120      	bne.n	10007aa6 <z_thread_abort+0x92>
		thread->base.thread_state &= ~_THREAD_ABORTING;
10007a64:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
10007a66:	68a3      	ldr	r3, [r4, #8]
10007a68:	b113      	cbz	r3, 10007a70 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
10007a6a:	4620      	mov	r0, r4
10007a6c:	f001 fa2e 	bl	10008ecc <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
10007a70:	f104 0018 	add.w	r0, r4, #24
10007a74:	f001 fa80 	bl	10008f78 <z_abort_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
10007a78:	f104 0758 	add.w	r7, r4, #88	; 0x58
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
10007a7c:	f04f 0800 	mov.w	r8, #0
	return list->head == list;
10007a80:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
10007a82:	42bd      	cmp	r5, r7
10007a84:	d000      	beq.n	10007a88 <z_thread_abort+0x74>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
10007a86:	b9b5      	cbnz	r5, 10007ab6 <z_thread_abort+0xa2>
		update_cache(1);
10007a88:	2001      	movs	r0, #1
10007a8a:	f7ff fdb5 	bl	100075f8 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
10007a8e:	4b10      	ldr	r3, [pc, #64]	; (10007ad0 <z_thread_abort+0xbc>)
10007a90:	689b      	ldr	r3, [r3, #8]
10007a92:	42a3      	cmp	r3, r4
10007a94:	d1db      	bne.n	10007a4e <z_thread_abort+0x3a>
10007a96:	f3ef 8305 	mrs	r3, IPSR
10007a9a:	2b00      	cmp	r3, #0
10007a9c:	d1d7      	bne.n	10007a4e <z_thread_abort+0x3a>
10007a9e:	4630      	mov	r0, r6
10007aa0:	f7fb fc38 	bl	10003314 <arch_swap>
	return ret;
10007aa4:	e7d3      	b.n	10007a4e <z_thread_abort+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
10007aa6:	f003 035f 	and.w	r3, r3, #95	; 0x5f
10007aaa:	f043 0308 	orr.w	r3, r3, #8
10007aae:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
10007ab0:	f001 fa04 	bl	10008ebc <sys_dlist_remove>
}
10007ab4:	e7d7      	b.n	10007a66 <z_thread_abort+0x52>
		unpend_thread_no_timeout(thread);
10007ab6:	4628      	mov	r0, r5
10007ab8:	f001 fa08 	bl	10008ecc <unpend_thread_no_timeout>
10007abc:	f105 0018 	add.w	r0, r5, #24
10007ac0:	f001 fa5a 	bl	10008f78 <z_abort_timeout>
10007ac4:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
		ready_thread(thread);
10007ac8:	4628      	mov	r0, r5
10007aca:	f7ff fded 	bl	100076a8 <ready_thread>
10007ace:	e7d7      	b.n	10007a80 <z_thread_abort+0x6c>
10007ad0:	080037a0 	.word	0x080037a0

10007ad4 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
10007ad4:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
10007ad6:	4806      	ldr	r0, [pc, #24]	; (10007af0 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
10007ad8:	4a06      	ldr	r2, [pc, #24]	; (10007af4 <z_data_copy+0x20>)
10007ada:	4907      	ldr	r1, [pc, #28]	; (10007af8 <z_data_copy+0x24>)
10007adc:	1a12      	subs	r2, r2, r0
10007ade:	f001 f9df 	bl	10008ea0 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
10007ae2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
10007ae6:	4a05      	ldr	r2, [pc, #20]	; (10007afc <z_data_copy+0x28>)
10007ae8:	4905      	ldr	r1, [pc, #20]	; (10007b00 <z_data_copy+0x2c>)
10007aea:	4806      	ldr	r0, [pc, #24]	; (10007b04 <z_data_copy+0x30>)
10007aec:	f001 b9d8 	b.w	10008ea0 <z_early_memcpy>
10007af0:	08002800 	.word	0x08002800
10007af4:	08002ed8 	.word	0x08002ed8
10007af8:	1000a9e4 	.word	0x1000a9e4
10007afc:	00000800 	.word	0x00000800
10007b00:	1000a1e4 	.word	0x1000a1e4
10007b04:	08002000 	.word	0x08002000

10007b08 <elapsed>:
	 *
	 * The distinction is implemented by looking at announce_remaining which
	 * will be non-zero while sys_clock_announce() is executing and zero
	 * otherwise.
	 */
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
10007b08:	4b03      	ldr	r3, [pc, #12]	; (10007b18 <elapsed+0x10>)
10007b0a:	681b      	ldr	r3, [r3, #0]
10007b0c:	b90b      	cbnz	r3, 10007b12 <elapsed+0xa>
10007b0e:	f7fc ba41 	b.w	10003f94 <sys_clock_elapsed>
}
10007b12:	2000      	movs	r0, #0
10007b14:	4770      	bx	lr
10007b16:	bf00      	nop
10007b18:	080037cc 	.word	0x080037cc

10007b1c <next_timeout>:

static int32_t next_timeout(void)
{
10007b1c:	b510      	push	{r4, lr}
	return list->head == list;
10007b1e:	4b0e      	ldr	r3, [pc, #56]	; (10007b58 <next_timeout+0x3c>)
10007b20:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
10007b22:	429c      	cmp	r4, r3
10007b24:	d104      	bne.n	10007b30 <next_timeout+0x14>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
10007b26:	f7ff ffef 	bl	10007b08 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
10007b2a:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
10007b2e:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
10007b30:	f7ff ffea 	bl	10007b08 <elapsed>
	if ((to == NULL) ||
10007b34:	2c00      	cmp	r4, #0
10007b36:	d0f8      	beq.n	10007b2a <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
10007b38:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
10007b3c:	1a1b      	subs	r3, r3, r0
10007b3e:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
10007b42:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
10007b46:	f172 0100 	sbcs.w	r1, r2, #0
10007b4a:	daee      	bge.n	10007b2a <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
10007b4c:	2a00      	cmp	r2, #0
10007b4e:	bfac      	ite	ge
10007b50:	4618      	movge	r0, r3
10007b52:	2000      	movlt	r0, #0
	return ret;
10007b54:	e7eb      	b.n	10007b2e <next_timeout+0x12>
10007b56:	bf00      	nop
10007b58:	08002978 	.word	0x08002978

10007b5c <remove_timeout>:
{
10007b5c:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
10007b5e:	b170      	cbz	r0, 10007b7e <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
10007b60:	4b0b      	ldr	r3, [pc, #44]	; (10007b90 <remove_timeout+0x34>)
10007b62:	685b      	ldr	r3, [r3, #4]
10007b64:	4298      	cmp	r0, r3
10007b66:	d00a      	beq.n	10007b7e <remove_timeout+0x22>
10007b68:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
10007b6a:	b143      	cbz	r3, 10007b7e <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
10007b6c:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
10007b70:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
10007b74:	1912      	adds	r2, r2, r4
10007b76:	eb41 0105 	adc.w	r1, r1, r5
10007b7a:	e9c3 2104 	strd	r2, r1, [r3, #16]
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
10007b7e:	e9d0 3200 	ldrd	r3, r2, [r0]

	prev->next = next;
10007b82:	6013      	str	r3, [r2, #0]
	next->prev = prev;
10007b84:	605a      	str	r2, [r3, #4]
	node->next = NULL;
10007b86:	2300      	movs	r3, #0
	node->prev = NULL;
10007b88:	e9c0 3300 	strd	r3, r3, [r0]
}
10007b8c:	bd30      	pop	{r4, r5, pc}
10007b8e:	bf00      	nop
10007b90:	08002978 	.word	0x08002978

10007b94 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
10007b94:	f1b3 3fff 	cmp.w	r3, #4294967295
10007b98:	bf08      	it	eq
10007b9a:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
10007b9e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10007ba0:	4604      	mov	r4, r0
10007ba2:	461d      	mov	r5, r3
10007ba4:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
10007ba6:	d05c      	beq.n	10007c62 <z_add_timeout+0xce>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
10007ba8:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
10007baa:	f04f 0320 	mov.w	r3, #32
10007bae:	f3ef 8711 	mrs	r7, BASEPRI
10007bb2:	f383 8812 	msr	BASEPRI_MAX, r3
10007bb6:	f3bf 8f6f 	isb	sy

	K_SPINLOCK(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
10007bba:	3201      	adds	r2, #1
10007bbc:	f175 33ff 	sbcs.w	r3, r5, #4294967295
10007bc0:	da24      	bge.n	10007c0c <z_add_timeout+0x78>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
10007bc2:	492d      	ldr	r1, [pc, #180]	; (10007c78 <z_add_timeout+0xe4>)
10007bc4:	e9d1 2000 	ldrd	r2, r0, [r1]
10007bc8:	f06f 0301 	mvn.w	r3, #1
10007bcc:	1a9b      	subs	r3, r3, r2
10007bce:	f04f 32ff 	mov.w	r2, #4294967295
10007bd2:	eb62 0000 	sbc.w	r0, r2, r0
10007bd6:	1b9e      	subs	r6, r3, r6
10007bd8:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
10007bdc:	2e01      	cmp	r6, #1
10007bde:	f170 0300 	sbcs.w	r3, r0, #0
10007be2:	da01      	bge.n	10007be8 <z_add_timeout+0x54>
10007be4:	2601      	movs	r6, #1
10007be6:	2000      	movs	r0, #0
10007be8:	e9c4 6004 	strd	r6, r0, [r4, #16]
	return list->head == list;
10007bec:	4e23      	ldr	r6, [pc, #140]	; (10007c7c <z_add_timeout+0xe8>)
10007bee:	f8d6 c000 	ldr.w	ip, [r6]
	return (node == list->tail) ? NULL : node->next;
10007bf2:	6875      	ldr	r5, [r6, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
10007bf4:	45b4      	cmp	ip, r6
10007bf6:	bf08      	it	eq
10007bf8:	f04f 0c00 	moveq.w	ip, #0
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
10007bfc:	f1bc 0f00 	cmp.w	ip, #0
10007c00:	d10d      	bne.n	10007c1e <z_add_timeout+0x8a>
	node->prev = tail;
10007c02:	e9c4 6500 	strd	r6, r5, [r4]
	tail->next = node;
10007c06:	602c      	str	r4, [r5, #0]
	list->tail = node;
10007c08:	6074      	str	r4, [r6, #4]
}
10007c0a:	e01c      	b.n	10007c46 <z_add_timeout+0xb2>
			to->dticks = timeout.ticks + 1 + elapsed();
10007c0c:	f7ff ff7c 	bl	10007b08 <elapsed>
10007c10:	3601      	adds	r6, #1
10007c12:	f145 0500 	adc.w	r5, r5, #0
10007c16:	1836      	adds	r6, r6, r0
10007c18:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
10007c1c:	e7e4      	b.n	10007be8 <z_add_timeout+0x54>
			if (t->dticks > to->dticks) {
10007c1e:	e9dc 2004 	ldrd	r2, r0, [ip, #16]
10007c22:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
10007c26:	4293      	cmp	r3, r2
10007c28:	eb71 0e00 	sbcs.w	lr, r1, r0
10007c2c:	da1a      	bge.n	10007c64 <z_add_timeout+0xd0>
				t->dticks -= to->dticks;
10007c2e:	1ad2      	subs	r2, r2, r3
	sys_dnode_t *const prev = successor->prev;
10007c30:	f8dc 3004 	ldr.w	r3, [ip, #4]
10007c34:	eb60 0001 	sbc.w	r0, r0, r1
10007c38:	e9cc 2004 	strd	r2, r0, [ip, #16]
	node->next = successor;
10007c3c:	e9c4 c300 	strd	ip, r3, [r4]
	prev->next = node;
10007c40:	601c      	str	r4, [r3, #0]
	successor->prev = node;
10007c42:	f8cc 4004 	str.w	r4, [ip, #4]
	return list->head == list;
10007c46:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
10007c48:	42b3      	cmp	r3, r6
10007c4a:	d006      	beq.n	10007c5a <z_add_timeout+0xc6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
10007c4c:	429c      	cmp	r4, r3
10007c4e:	d104      	bne.n	10007c5a <z_add_timeout+0xc6>
			sys_clock_set_timeout(next_timeout(), false);
10007c50:	f7ff ff64 	bl	10007b1c <next_timeout>
10007c54:	2100      	movs	r1, #0
10007c56:	f7fc f923 	bl	10003ea0 <sys_clock_set_timeout>
	__asm__ volatile(
10007c5a:	f387 8811 	msr	BASEPRI, r7
10007c5e:	f3bf 8f6f 	isb	sy
		}
	}
}
10007c62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			to->dticks -= t->dticks;
10007c64:	1a9b      	subs	r3, r3, r2
10007c66:	eb61 0100 	sbc.w	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
10007c6a:	45ac      	cmp	ip, r5
10007c6c:	e9c4 3104 	strd	r3, r1, [r4, #16]
10007c70:	d0c7      	beq.n	10007c02 <z_add_timeout+0x6e>
10007c72:	f8dc c000 	ldr.w	ip, [ip]
10007c76:	e7c1      	b.n	10007bfc <z_add_timeout+0x68>
10007c78:	08003000 	.word	0x08003000
10007c7c:	08002978 	.word	0x08002978

10007c80 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
10007c80:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__asm__ volatile(
10007c84:	f04f 0320 	mov.w	r3, #32
10007c88:	f3ef 8c11 	mrs	ip, BASEPRI
10007c8c:	f383 8812 	msr	BASEPRI_MAX, r3
10007c90:	f3bf 8f6f 	isb	sy
	return list->head == list;
10007c94:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 10007d48 <sys_clock_announce+0xc8>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
10007c98:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 10007d4c <sys_clock_announce+0xcc>
	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
10007c9c:	4f2c      	ldr	r7, [pc, #176]	; (10007d50 <sys_clock_announce+0xd0>)
	announce_remaining = ticks;
10007c9e:	f8c9 0000 	str.w	r0, [r9]
10007ca2:	f8da 0000 	ldr.w	r0, [sl]
		t->dticks = 0;
10007ca6:	2400      	movs	r4, #0
	return sys_dlist_is_empty(list) ? NULL : list->head;
10007ca8:	4550      	cmp	r0, sl
10007caa:	bf08      	it	eq
10007cac:	2000      	moveq	r0, #0
10007cae:	2500      	movs	r5, #0
		curr_tick += dt;
10007cb0:	e9d7 2100 	ldrd	r2, r1, [r7]
	     (t != NULL) && (t->dticks <= announce_remaining);
10007cb4:	f8d9 3000 	ldr.w	r3, [r9]
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
10007cb8:	46e0      	mov	r8, ip
10007cba:	b380      	cbz	r0, 10007d1e <sys_clock_announce+0x9e>
10007cbc:	e9d0 6c04 	ldrd	r6, ip, [r0, #16]
10007cc0:	ea4f 7ee3 	mov.w	lr, r3, asr #31
10007cc4:	42b3      	cmp	r3, r6
10007cc6:	eb7e 0b0c 	sbcs.w	fp, lr, ip
10007cca:	da05      	bge.n	10007cd8 <sys_clock_announce+0x58>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
10007ccc:	1af6      	subs	r6, r6, r3
10007cce:	eb6c 040e 	sbc.w	r4, ip, lr
10007cd2:	e9c0 6404 	strd	r6, r4, [r0, #16]
10007cd6:	e022      	b.n	10007d1e <sys_clock_announce+0x9e>
		curr_tick += dt;
10007cd8:	18b2      	adds	r2, r6, r2
10007cda:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
		t->dticks = 0;
10007cde:	e9c0 4504 	strd	r4, r5, [r0, #16]
		curr_tick += dt;
10007ce2:	e9c7 2100 	strd	r2, r1, [r7]
		remove_timeout(t);
10007ce6:	f7ff ff39 	bl	10007b5c <remove_timeout>
	__asm__ volatile(
10007cea:	f388 8811 	msr	BASEPRI, r8
10007cee:	f3bf 8f6f 	isb	sy
		t->fn(t);
10007cf2:	6883      	ldr	r3, [r0, #8]
10007cf4:	4798      	blx	r3
	__asm__ volatile(
10007cf6:	f04f 0320 	mov.w	r3, #32
10007cfa:	f3ef 8811 	mrs	r8, BASEPRI
10007cfe:	f383 8812 	msr	BASEPRI_MAX, r3
10007d02:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
10007d06:	f8d9 3000 	ldr.w	r3, [r9]
	return list->head == list;
10007d0a:	f8da 0000 	ldr.w	r0, [sl]
10007d0e:	1b9b      	subs	r3, r3, r6
	return sys_dlist_is_empty(list) ? NULL : list->head;
10007d10:	4550      	cmp	r0, sl
	k.key = arch_irq_lock();
10007d12:	46c4      	mov	ip, r8
10007d14:	f8c9 3000 	str.w	r3, [r9]
10007d18:	d1ca      	bne.n	10007cb0 <sys_clock_announce+0x30>
		curr_tick += dt;
10007d1a:	e9d7 2100 	ldrd	r2, r1, [r7]
	}

	curr_tick += announce_remaining;
10007d1e:	189a      	adds	r2, r3, r2
10007d20:	eb41 73e3 	adc.w	r3, r1, r3, asr #31
	announce_remaining = 0;
10007d24:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
10007d26:	e9c7 2300 	strd	r2, r3, [r7]
	announce_remaining = 0;
10007d2a:	f8c9 4000 	str.w	r4, [r9]

	sys_clock_set_timeout(next_timeout(), false);
10007d2e:	f7ff fef5 	bl	10007b1c <next_timeout>
10007d32:	4621      	mov	r1, r4
10007d34:	f7fc f8b4 	bl	10003ea0 <sys_clock_set_timeout>
	__asm__ volatile(
10007d38:	f388 8811 	msr	BASEPRI, r8
10007d3c:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
10007d40:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_time_slice();
10007d44:	f7ff bcfc 	b.w	10007740 <z_time_slice>
10007d48:	08002978 	.word	0x08002978
10007d4c:	080037cc 	.word	0x080037cc
10007d50:	08003000 	.word	0x08003000

10007d54 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
10007d54:	b510      	push	{r4, lr}
	__asm__ volatile(
10007d56:	f04f 0320 	mov.w	r3, #32
10007d5a:	f3ef 8411 	mrs	r4, BASEPRI
10007d5e:	f383 8812 	msr	BASEPRI_MAX, r3
10007d62:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	K_SPINLOCK(&timeout_lock) {
		t = curr_tick + elapsed();
10007d66:	f7ff fecf 	bl	10007b08 <elapsed>
10007d6a:	4a06      	ldr	r2, [pc, #24]	; (10007d84 <sys_clock_tick_get+0x30>)
10007d6c:	4603      	mov	r3, r0
10007d6e:	e9d2 0100 	ldrd	r0, r1, [r2]
10007d72:	1818      	adds	r0, r3, r0
10007d74:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
	__asm__ volatile(
10007d78:	f384 8811 	msr	BASEPRI, r4
10007d7c:	f3bf 8f6f 	isb	sy
	}
	return t;
}
10007d80:	bd10      	pop	{r4, pc}
10007d82:	bf00      	nop
10007d84:	08003000 	.word	0x08003000

10007d88 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
10007d88:	4801      	ldr	r0, [pc, #4]	; (10007d90 <boot_banner+0x8>)
10007d8a:	f000 b81b 	b.w	10007dc4 <printk>
10007d8e:	bf00      	nop
10007d90:	1000a1a0 	.word	0x1000a1a0

10007d94 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
10007d94:	4770      	bx	lr

10007d96 <gpio_pin_configure_dt>:
{
10007d96:	b470      	push	{r4, r5, r6}
10007d98:	4603      	mov	r3, r0
10007d9a:	460c      	mov	r4, r1
				  spec->dt_flags | extra_flags);
10007d9c:	88da      	ldrh	r2, [r3, #6]
	return gpio_pin_configure(spec->port,
10007d9e:	6800      	ldr	r0, [r0, #0]
				  spec->pin,
10007da0:	7919      	ldrb	r1, [r3, #4]
	return gpio_pin_configure(spec->port,
10007da2:	4322      	orrs	r2, r4
	struct gpio_driver_data *data =
10007da4:	6905      	ldr	r5, [r0, #16]
	const struct gpio_driver_api *api =
10007da6:	6886      	ldr	r6, [r0, #8]
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
10007da8:	682b      	ldr	r3, [r5, #0]
		data->invert |= (gpio_port_pins_t)BIT(pin);
10007daa:	2401      	movs	r4, #1
10007dac:	408c      	lsls	r4, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
10007dae:	f012 0f01 	tst.w	r2, #1
		data->invert |= (gpio_port_pins_t)BIT(pin);
10007db2:	bf14      	ite	ne
10007db4:	4323      	orrne	r3, r4
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
10007db6:	43a3      	biceq	r3, r4
10007db8:	602b      	str	r3, [r5, #0]
	return api->pin_configure(port, pin, flags);
10007dba:	6833      	ldr	r3, [r6, #0]
}
10007dbc:	bc70      	pop	{r4, r5, r6}
	return api->pin_configure(port, pin, flags);
10007dbe:	4718      	bx	r3

10007dc0 <arch_printk_char_out>:
}
10007dc0:	2000      	movs	r0, #0
10007dc2:	4770      	bx	lr

10007dc4 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
10007dc4:	b40f      	push	{r0, r1, r2, r3}
10007dc6:	b507      	push	{r0, r1, r2, lr}
10007dc8:	a904      	add	r1, sp, #16
10007dca:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
10007dce:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
10007dd0:	f7fa fe86 	bl	10002ae0 <vprintk>

	va_end(ap);
}
10007dd4:	b003      	add	sp, #12
10007dd6:	f85d eb04 	ldr.w	lr, [sp], #4
10007dda:	b004      	add	sp, #16
10007ddc:	4770      	bx	lr

10007dde <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
10007dde:	4604      	mov	r4, r0
10007de0:	b508      	push	{r3, lr}
10007de2:	4608      	mov	r0, r1
10007de4:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
10007de6:	461a      	mov	r2, r3
10007de8:	47a0      	blx	r4
	return z_impl_z_current_get();
10007dea:	f7ff fe0d 	bl	10007a08 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
10007dee:	f7fb fcc1 	bl	10003774 <z_impl_k_thread_abort>

10007df2 <encode_uint>:
{
10007df2:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
10007df6:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier) != 0;
10007df8:	78d3      	ldrb	r3, [r2, #3]
	switch (specifier) {
10007dfa:	2b6f      	cmp	r3, #111	; 0x6f
{
10007dfc:	4680      	mov	r8, r0
10007dfe:	460f      	mov	r7, r1
10007e00:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
10007e02:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
10007e06:	d029      	beq.n	10007e5c <encode_uint+0x6a>
10007e08:	d824      	bhi.n	10007e54 <encode_uint+0x62>
		return 10;
10007e0a:	2b58      	cmp	r3, #88	; 0x58
10007e0c:	bf0c      	ite	eq
10007e0e:	2610      	moveq	r6, #16
10007e10:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
10007e12:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
10007e16:	4632      	mov	r2, r6
10007e18:	2300      	movs	r3, #0
10007e1a:	4640      	mov	r0, r8
10007e1c:	4639      	mov	r1, r7
10007e1e:	f7fa fabf 	bl	100023a0 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
10007e22:	2a09      	cmp	r2, #9
10007e24:	b2d4      	uxtb	r4, r2
10007e26:	d81e      	bhi.n	10007e66 <encode_uint+0x74>
10007e28:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
10007e2a:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
10007e2c:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
10007e2e:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
10007e32:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
10007e36:	d301      	bcc.n	10007e3c <encode_uint+0x4a>
10007e38:	45d1      	cmp	r9, sl
10007e3a:	d811      	bhi.n	10007e60 <encode_uint+0x6e>
	if (conv->flag_hash) {
10007e3c:	782b      	ldrb	r3, [r5, #0]
10007e3e:	069b      	lsls	r3, r3, #26
10007e40:	d505      	bpl.n	10007e4e <encode_uint+0x5c>
		if (radix == 8) {
10007e42:	2e08      	cmp	r6, #8
10007e44:	d115      	bne.n	10007e72 <encode_uint+0x80>
			conv->altform_0 = true;
10007e46:	78ab      	ldrb	r3, [r5, #2]
10007e48:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
10007e4c:	70ab      	strb	r3, [r5, #2]
}
10007e4e:	4648      	mov	r0, r9
10007e50:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
10007e54:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
10007e58:	2b70      	cmp	r3, #112	; 0x70
10007e5a:	e7d7      	b.n	10007e0c <encode_uint+0x1a>
	switch (specifier) {
10007e5c:	2608      	movs	r6, #8
10007e5e:	e7d8      	b.n	10007e12 <encode_uint+0x20>
		value /= radix;
10007e60:	4680      	mov	r8, r0
10007e62:	460f      	mov	r7, r1
10007e64:	e7d7      	b.n	10007e16 <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
10007e66:	f1bb 0f19 	cmp.w	fp, #25
10007e6a:	bf94      	ite	ls
10007e6c:	3437      	addls	r4, #55	; 0x37
10007e6e:	3457      	addhi	r4, #87	; 0x57
10007e70:	e7db      	b.n	10007e2a <encode_uint+0x38>
		} else if (radix == 16) {
10007e72:	2e10      	cmp	r6, #16
10007e74:	d1eb      	bne.n	10007e4e <encode_uint+0x5c>
			conv->altform_0c = true;
10007e76:	78ab      	ldrb	r3, [r5, #2]
10007e78:	f043 0310 	orr.w	r3, r3, #16
10007e7c:	e7e6      	b.n	10007e4c <encode_uint+0x5a>

10007e7e <outs>:
{
10007e7e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
10007e82:	4607      	mov	r7, r0
10007e84:	4688      	mov	r8, r1
10007e86:	4615      	mov	r5, r2
10007e88:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
10007e8a:	4614      	mov	r4, r2
10007e8c:	42b4      	cmp	r4, r6
10007e8e:	d305      	bcc.n	10007e9c <outs+0x1e>
10007e90:	b10e      	cbz	r6, 10007e96 <outs+0x18>
	return (int)count;
10007e92:	1b60      	subs	r0, r4, r5
10007e94:	e008      	b.n	10007ea8 <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
10007e96:	7823      	ldrb	r3, [r4, #0]
10007e98:	2b00      	cmp	r3, #0
10007e9a:	d0fa      	beq.n	10007e92 <outs+0x14>
		int rc = out((int)*sp++, ctx);
10007e9c:	f814 0b01 	ldrb.w	r0, [r4], #1
10007ea0:	4641      	mov	r1, r8
10007ea2:	47b8      	blx	r7
		if (rc < 0) {
10007ea4:	2800      	cmp	r0, #0
10007ea6:	daf1      	bge.n	10007e8c <outs+0xe>
}
10007ea8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

10007eac <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_TAINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
10007eac:	4770      	bx	lr

10007eae <init_cycfg_platform_wraper>:

	return status;
}

static int init_cycfg_platform_wraper(void)
{
10007eae:	b508      	push	{r3, lr}

	/* Initializes the system */
	SystemInit();
10007eb0:	f7fc f8e0 	bl	10004074 <SystemInit>
	return 0;
}
10007eb4:	2000      	movs	r0, #0
10007eb6:	bd08      	pop	{r3, pc}

10007eb8 <Cy_SysInt_Init>:
{
10007eb8:	b513      	push	{r0, r1, r4, lr}
	CY_ASSERT_L3(CY_SYSINT_IS_PRIORITY_VALID(config->intrPriority));
10007eba:	6843      	ldr	r3, [r0, #4]
10007ebc:	2b07      	cmp	r3, #7
{
10007ebe:	460a      	mov	r2, r1
	CY_ASSERT_L3(CY_SYSINT_IS_PRIORITY_VALID(config->intrPriority));
10007ec0:	d900      	bls.n	10007ec4 <Cy_SysInt_Init+0xc>
10007ec2:	be01      	bkpt	0x0001
		priority = (config->intrPriority > IRQ_PRIO_LOWEST) ?
10007ec4:	6841      	ldr	r1, [r0, #4]
static inline int
irq_connect_dynamic(unsigned int irq, unsigned int priority,
		    void (*routine)(const void *parameter),
		    const void *parameter, uint32_t flags)
{
	return arch_irq_connect_dynamic(irq, priority, routine, parameter,
10007ec6:	2400      	movs	r4, #0
10007ec8:	9400      	str	r4, [sp, #0]
10007eca:	2906      	cmp	r1, #6
10007ecc:	4623      	mov	r3, r4
10007ece:	bf28      	it	cs
10007ed0:	2106      	movcs	r1, #6
10007ed2:	f9b0 0000 	ldrsh.w	r0, [r0]
10007ed6:	f000 f80d 	bl	10007ef4 <arch_irq_connect_dynamic>
}
10007eda:	4620      	mov	r0, r4
10007edc:	b002      	add	sp, #8
10007ede:	bd10      	pop	{r4, pc}

10007ee0 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
10007ee0:	f000 bfc1 	b.w	10008e66 <z_fatal_error>

10007ee4 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
10007ee4:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
10007ee6:	6800      	ldr	r0, [r0, #0]
10007ee8:	f000 bfbd 	b.w	10008e66 <z_fatal_error>

10007eec <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
10007eec:	2100      	movs	r1, #0
10007eee:	2001      	movs	r0, #1
10007ef0:	f7ff bff6 	b.w	10007ee0 <z_arm_fatal_error>

10007ef4 <arch_irq_connect_dynamic>:
#ifdef CONFIG_DYNAMIC_INTERRUPTS
#ifdef CONFIG_GEN_ISR_TABLES
int arch_irq_connect_dynamic(unsigned int irq, unsigned int priority,
			     void (*routine)(const void *parameter),
			     const void *parameter, uint32_t flags)
{
10007ef4:	b538      	push	{r3, r4, r5, lr}
10007ef6:	4604      	mov	r4, r0
10007ef8:	460d      	mov	r5, r1
10007efa:	4611      	mov	r1, r2
	z_isr_install(irq, routine, parameter);
10007efc:	461a      	mov	r2, r3
10007efe:	f7fb f9af 	bl	10003260 <z_isr_install>
	NVIC_SetPriority((IRQn_Type)irq, prio);
10007f02:	b220      	sxth	r0, r4
10007f04:	1c69      	adds	r1, r5, #1
10007f06:	f7fb f9c9 	bl	1000329c <__NVIC_SetPriority>
	z_arm_irq_priority_set(irq, priority, flags);
	return irq;
}
10007f0a:	4620      	mov	r0, r4
10007f0c:	bd38      	pop	{r3, r4, r5, pc}

10007f0e <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
10007f0e:	b508      	push	{r3, lr}
	handler();
10007f10:	f7fb f9d8 	bl	100032c4 <z_SysNmiOnReset>
	z_arm_int_exit();
}
10007f14:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
10007f18:	f7fb baac 	b.w	10003474 <z_arm_exc_exit>

10007f1c <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
10007f1c:	4603      	mov	r3, r0
	size_t n = 0;
10007f1e:	2000      	movs	r0, #0

	while (*s != '\0') {
10007f20:	5c1a      	ldrb	r2, [r3, r0]
10007f22:	b902      	cbnz	r2, 10007f26 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
10007f24:	4770      	bx	lr
		n++;
10007f26:	3001      	adds	r0, #1
10007f28:	e7fa      	b.n	10007f20 <strlen+0x4>

10007f2a <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
10007f2a:	b510      	push	{r4, lr}
10007f2c:	1e43      	subs	r3, r0, #1
10007f2e:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
10007f30:	4291      	cmp	r1, r2
10007f32:	d100      	bne.n	10007f36 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
10007f34:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
10007f36:	f811 4b01 	ldrb.w	r4, [r1], #1
10007f3a:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
10007f3e:	e7f7      	b.n	10007f30 <memcpy+0x6>

10007f40 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
10007f40:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
10007f42:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
10007f44:	4603      	mov	r3, r0
	while (n > 0) {
10007f46:	4293      	cmp	r3, r2
10007f48:	d100      	bne.n	10007f4c <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
10007f4a:	4770      	bx	lr
		*(d_byte++) = c_byte;
10007f4c:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
10007f50:	e7f9      	b.n	10007f46 <memset+0x6>

10007f52 <_stdout_hook_default>:
}
10007f52:	f04f 30ff 	mov.w	r0, #4294967295
10007f56:	4770      	bx	lr

10007f58 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
10007f58:	4603      	mov	r3, r0
	size_t n = 0;
10007f5a:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
10007f5c:	5c1a      	ldrb	r2, [r3, r0]
10007f5e:	b10a      	cbz	r2, 10007f64 <strnlen+0xc>
10007f60:	4288      	cmp	r0, r1
10007f62:	d100      	bne.n	10007f66 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
10007f64:	4770      	bx	lr
		n++;
10007f66:	3001      	adds	r0, #1
10007f68:	e7f8      	b.n	10007f5c <strnlen+0x4>

10007f6a <clock_control_infineon_cat_on_off>:
	ARG_UNUSED(dev);
	ARG_UNUSED(sys);

	/* On/off functionality are not supported */
	return -ENOSYS;
}
10007f6a:	f06f 0057 	mvn.w	r0, #87	; 0x57
10007f6e:	4770      	bx	lr

10007f70 <gpio_cat1_port_get_raw>:
	GPIO_PRT_Type *const base = cfg->regs;
10007f70:	6843      	ldr	r3, [r0, #4]
10007f72:	689b      	ldr	r3, [r3, #8]
	*value = GPIO_PRT_IN(base);
10007f74:	691b      	ldr	r3, [r3, #16]
10007f76:	600b      	str	r3, [r1, #0]
}
10007f78:	2000      	movs	r0, #0
10007f7a:	4770      	bx	lr

10007f7c <gpio_cat1_port_set_masked_raw>:
	GPIO_PRT_Type *const base = cfg->regs;
10007f7c:	6843      	ldr	r3, [r0, #4]
10007f7e:	689b      	ldr	r3, [r3, #8]
	GPIO_PRT_OUT(base) = (GPIO_PRT_OUT(base) & ~mask) | (mask & value);
10007f80:	6818      	ldr	r0, [r3, #0]
10007f82:	4042      	eors	r2, r0
10007f84:	400a      	ands	r2, r1
10007f86:	4042      	eors	r2, r0
10007f88:	601a      	str	r2, [r3, #0]
}
10007f8a:	2000      	movs	r0, #0
10007f8c:	4770      	bx	lr

10007f8e <gpio_cat1_port_set_bits_raw>:
	GPIO_PRT_Type *const base = cfg->regs;
10007f8e:	6843      	ldr	r3, [r0, #4]
10007f90:	689b      	ldr	r3, [r3, #8]
}
10007f92:	2000      	movs	r0, #0
	GPIO_PRT_OUT_SET(base) = mask;
10007f94:	6099      	str	r1, [r3, #8]
}
10007f96:	4770      	bx	lr

10007f98 <gpio_cat1_port_clear_bits_raw>:
	GPIO_PRT_Type *const base = cfg->regs;
10007f98:	6843      	ldr	r3, [r0, #4]
10007f9a:	689b      	ldr	r3, [r3, #8]
}
10007f9c:	2000      	movs	r0, #0
	GPIO_PRT_OUT_CLR(base) = mask;
10007f9e:	6059      	str	r1, [r3, #4]
}
10007fa0:	4770      	bx	lr

10007fa2 <gpio_cat1_port_toggle_bits>:
	GPIO_PRT_Type *const base = cfg->regs;
10007fa2:	6843      	ldr	r3, [r0, #4]
10007fa4:	689b      	ldr	r3, [r3, #8]
}
10007fa6:	2000      	movs	r0, #0
	GPIO_PRT_OUT_INV(base) = mask;
10007fa8:	60d9      	str	r1, [r3, #12]
}
10007faa:	4770      	bx	lr

10007fac <gpio_cat1_get_pending_int>:
	GPIO_PRT_Type *const base = cfg->regs;
10007fac:	6843      	ldr	r3, [r0, #4]
10007fae:	689b      	ldr	r3, [r3, #8]
	return GPIO_PRT_INTR_MASKED(base);
10007fb0:	69d8      	ldr	r0, [r3, #28]
}
10007fb2:	4770      	bx	lr

10007fb4 <gpio_cat1_manage_callback>:

static int gpio_cat1_manage_callback(const struct device *port,
				     struct gpio_callback *callback,
				     bool set)
{
10007fb4:	b510      	push	{r4, lr}
	return gpio_manage_callback(&((struct gpio_cat1_data *const)(port)->data)->callbacks,
10007fb6:	6903      	ldr	r3, [r0, #16]
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
10007fb8:	6898      	ldr	r0, [r3, #8]
	if (!sys_slist_is_empty(callbacks)) {
10007fba:	b1f8      	cbz	r0, 10007ffc <gpio_cat1_manage_callback+0x48>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
10007fbc:	4288      	cmp	r0, r1
10007fbe:	d119      	bne.n	10007ff4 <gpio_cat1_manage_callback+0x40>
Z_GENLIST_REMOVE(slist, snode)
10007fc0:	68dc      	ldr	r4, [r3, #12]
	return node->next;
10007fc2:	6808      	ldr	r0, [r1, #0]
	list->head = node;
10007fc4:	6098      	str	r0, [r3, #8]
Z_GENLIST_REMOVE(slist, snode)
10007fc6:	42a1      	cmp	r1, r4
10007fc8:	d100      	bne.n	10007fcc <gpio_cat1_manage_callback+0x18>
	list->tail = node;
10007fca:	60d8      	str	r0, [r3, #12]
	parent->next = child;
10007fcc:	2000      	movs	r0, #0
10007fce:	6008      	str	r0, [r1, #0]
	if (set) {
10007fd0:	b12a      	cbz	r2, 10007fde <gpio_cat1_manage_callback+0x2a>
	return list->head;
10007fd2:	689a      	ldr	r2, [r3, #8]
	parent->next = child;
10007fd4:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
10007fd6:	68da      	ldr	r2, [r3, #12]
	list->head = node;
10007fd8:	6099      	str	r1, [r3, #8]
Z_GENLIST_PREPEND(slist, snode)
10007fda:	b902      	cbnz	r2, 10007fde <gpio_cat1_manage_callback+0x2a>
	list->tail = node;
10007fdc:	60d9      	str	r1, [r3, #12]
	return 0;
10007fde:	2000      	movs	r0, #0
10007fe0:	e010      	b.n	10008004 <gpio_cat1_manage_callback+0x50>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
10007fe2:	4281      	cmp	r1, r0
10007fe4:	d106      	bne.n	10007ff4 <gpio_cat1_manage_callback+0x40>
	return node->next;
10007fe6:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
10007fe8:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
10007fea:	68d8      	ldr	r0, [r3, #12]
10007fec:	4281      	cmp	r1, r0
10007fee:	d1ed      	bne.n	10007fcc <gpio_cat1_manage_callback+0x18>
	list->tail = node;
10007ff0:	60dc      	str	r4, [r3, #12]
}
10007ff2:	e7eb      	b.n	10007fcc <gpio_cat1_manage_callback+0x18>
	return node->next;
10007ff4:	4604      	mov	r4, r0
10007ff6:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
10007ff8:	2800      	cmp	r0, #0
10007ffa:	d1f2      	bne.n	10007fe2 <gpio_cat1_manage_callback+0x2e>
			if (!set) {
10007ffc:	2a00      	cmp	r2, #0
10007ffe:	d1e8      	bne.n	10007fd2 <gpio_cat1_manage_callback+0x1e>
				return -EINVAL;
10008000:	f06f 0015 	mvn.w	r0, #21
				    callback, set);
}
10008004:	bd10      	pop	{r4, pc}

10008006 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
10008006:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
10008008:	6803      	ldr	r3, [r0, #0]
1000800a:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
1000800c:	7905      	ldrb	r5, [r0, #4]
1000800e:	6804      	ldr	r4, [r0, #0]
10008010:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
10008014:	42a3      	cmp	r3, r4
10008016:	d302      	bcc.n	1000801e <pinctrl_lookup_state+0x18>
		}

		(*state)++;
	}

	return -ENOENT;
10008018:	f06f 0001 	mvn.w	r0, #1
}
1000801c:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
1000801e:	795c      	ldrb	r4, [r3, #5]
10008020:	428c      	cmp	r4, r1
10008022:	d001      	beq.n	10008028 <pinctrl_lookup_state+0x22>
		(*state)++;
10008024:	3308      	adds	r3, #8
10008026:	e7f0      	b.n	1000800a <pinctrl_lookup_state+0x4>
			return 0;
10008028:	2000      	movs	r0, #0
1000802a:	e7f7      	b.n	1000801c <pinctrl_lookup_state+0x16>

1000802c <ifx_cat1_uart_err_check>:
	uint32_t status = Cy_SCB_UART_GetRxFifoStatus(data->obj.base);
1000802c:	6903      	ldr	r3, [r0, #16]
1000802e:	681b      	ldr	r3, [r3, #0]
* See \ref group_scb_common_macros_rx_intr for the set of constants.
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_SCB_GetRxInterruptStatus(CySCB_Type const *base)
{
    return (SCB_INTR_RX(base) & CY_SCB_RX_INTR_MASK);
10008030:	f8d3 3fc0 	ldr.w	r3, [r3, #4032]	; 0xfc0
	if (status & CY_SCB_UART_RX_OVERFLOW) {
10008034:	f3c3 1040 	ubfx	r0, r3, #5, #1
	if (status & CY_SCB_UART_RX_ERR_PARITY) {
10008038:	059a      	lsls	r2, r3, #22
		errors |= UART_ERROR_PARITY;
1000803a:	bf48      	it	mi
1000803c:	f040 0002 	orrmi.w	r0, r0, #2
	if (status & CY_SCB_UART_RX_ERR_FRAME) {
10008040:	05db      	lsls	r3, r3, #23
		errors |= UART_ERROR_FRAMING;
10008042:	bf48      	it	mi
10008044:	f040 0004 	orrmi.w	r0, r0, #4
}
10008048:	4770      	bx	lr

1000804a <ifx_cat1_uart_config_get>:
	struct ifx_cat1_uart_data *const data = dev->data;
1000804a:	6902      	ldr	r2, [r0, #16]
	if (cfg == NULL) {
1000804c:	460b      	mov	r3, r1
1000804e:	b129      	cbz	r1, 1000805c <ifx_cat1_uart_config_get+0x12>
	*cfg = data->cfg;
10008050:	e9d2 012a 	ldrd	r0, r1, [r2, #168]	; 0xa8
10008054:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
10008058:	2000      	movs	r0, #0
1000805a:	4770      	bx	lr
		return -EINVAL;
1000805c:	f06f 0015 	mvn.w	r0, #21
}
10008060:	4770      	bx	lr

10008062 <ifx_cat1_uart_configure>:
{
10008062:	b530      	push	{r4, r5, lr}
10008064:	b087      	sub	sp, #28
	cyhal_uart_cfg_t uart_cfg = {
10008066:	2300      	movs	r3, #0
10008068:	e9cd 3303 	strd	r3, r3, [sp, #12]
1000806c:	9305      	str	r3, [sp, #20]
		.data_bits = _convert_uart_data_bits_z_to_cyhal(cfg->data_bits),
1000806e:	798b      	ldrb	r3, [r1, #6]
	struct ifx_cat1_uart_data *data = dev->data;
10008070:	6905      	ldr	r5, [r0, #16]
	switch (data_bits) {
10008072:	1e5a      	subs	r2, r3, #1
10008074:	2a03      	cmp	r2, #3
10008076:	bf9a      	itte	ls
10008078:	3305      	addls	r3, #5
1000807a:	b2db      	uxtbls	r3, r3
		.data_bits = _convert_uart_data_bits_z_to_cyhal(cfg->data_bits),
1000807c:	2301      	movhi	r3, #1
	cyhal_uart_cfg_t uart_cfg = {
1000807e:	9301      	str	r3, [sp, #4]
	switch (stop_bits) {
10008080:	794b      	ldrb	r3, [r1, #5]
		cyhal_stop_bits = 1u;
10008082:	2b03      	cmp	r3, #3
10008084:	bf0c      	ite	eq
10008086:	2302      	moveq	r3, #2
10008088:	2301      	movne	r3, #1
	cyhal_uart_cfg_t uart_cfg = {
1000808a:	9302      	str	r3, [sp, #8]
		.parity = _convert_uart_parity_z_to_cyhal(cfg->parity)
1000808c:	790b      	ldrb	r3, [r1, #4]
	switch (parity) {
1000808e:	2b01      	cmp	r3, #1
{
10008090:	460c      	mov	r4, r1
	switch (parity) {
10008092:	d019      	beq.n	100080c8 <ifx_cat1_uart_configure+0x66>
10008094:	1e9a      	subs	r2, r3, #2
10008096:	4253      	negs	r3, r2
10008098:	4153      	adcs	r3, r2
	data->cfg = *cfg;
1000809a:	e894 0003 	ldmia.w	r4, {r0, r1}
	cyhal_uart_cfg_t uart_cfg = {
1000809e:	f88d 300c 	strb.w	r3, [sp, #12]
	data->cfg = *cfg;
100080a2:	f105 03a8 	add.w	r3, r5, #168	; 0xa8
100080a6:	e883 0003 	stmia.w	r3, {r0, r1}
	result = cyhal_uart_configure(&data->obj, &uart_cfg);
100080aa:	a901      	add	r1, sp, #4
100080ac:	4628      	mov	r0, r5
100080ae:	f000 fb80 	bl	100087b2 <cyhal_uart_configure>
	if (result == CY_RSLT_SUCCESS) {
100080b2:	4602      	mov	r2, r0
100080b4:	b920      	cbnz	r0, 100080c0 <ifx_cat1_uart_configure+0x5e>
		result = cyhal_uart_set_baud(&data->obj, cfg->baudrate, NULL);
100080b6:	6821      	ldr	r1, [r4, #0]
100080b8:	4628      	mov	r0, r5
100080ba:	f7fd ff1d 	bl	10005ef8 <cyhal_uart_set_baud>
	if ((result == CY_RSLT_SUCCESS) && cfg->flow_ctrl) {
100080be:	b128      	cbz	r0, 100080cc <ifx_cat1_uart_configure+0x6a>
	return (result == CY_RSLT_SUCCESS) ? 0 : -ENOTSUP;
100080c0:	f06f 0085 	mvn.w	r0, #133	; 0x85
};
100080c4:	b007      	add	sp, #28
100080c6:	bd30      	pop	{r4, r5, pc}
	switch (parity) {
100080c8:	2302      	movs	r3, #2
100080ca:	e7e6      	b.n	1000809a <ifx_cat1_uart_configure+0x38>
	if ((result == CY_RSLT_SUCCESS) && cfg->flow_ctrl) {
100080cc:	79e3      	ldrb	r3, [r4, #7]
100080ce:	b90b      	cbnz	r3, 100080d4 <ifx_cat1_uart_configure+0x72>
	return (result == CY_RSLT_SUCCESS) ? 0 : -ENOTSUP;
100080d0:	2000      	movs	r0, #0
100080d2:	e7f7      	b.n	100080c4 <ifx_cat1_uart_configure+0x62>
		result = cyhal_uart_enable_flow_control(&data->obj, true, true);
100080d4:	2201      	movs	r2, #1
100080d6:	4611      	mov	r1, r2
100080d8:	4628      	mov	r0, r5
100080da:	f7fd ffc9 	bl	10006070 <cyhal_uart_enable_flow_control>
	return (result == CY_RSLT_SUCCESS) ? 0 : -ENOTSUP;
100080de:	2800      	cmp	r0, #0
100080e0:	d0f6      	beq.n	100080d0 <ifx_cat1_uart_configure+0x6e>
100080e2:	e7ed      	b.n	100080c0 <ifx_cat1_uart_configure+0x5e>

100080e4 <ifx_cat1_uart_poll_out>:
	(void) cyhal_uart_putc(&data->obj, (uint32_t)c);
100080e4:	6900      	ldr	r0, [r0, #16]
100080e6:	f7fd bfb1 	b.w	1000604c <cyhal_uart_putc>

100080ea <ifx_cat1_uart_poll_in>:
{
100080ea:	b508      	push	{r3, lr}
	rec = cyhal_uart_getc(&data->obj, c, 0u);
100080ec:	2200      	movs	r2, #0
100080ee:	6900      	ldr	r0, [r0, #16]
100080f0:	f7fd ff86 	bl	10006000 <cyhal_uart_getc>
}
100080f4:	3001      	adds	r0, #1
100080f6:	f04f 30ff 	mov.w	r0, #4294967295
100080fa:	bf18      	it	ne
100080fc:	2000      	movne	r0, #0
100080fe:	bd08      	pop	{r3, pc}

10008100 <Cy_SysIpcPipeIsrCm4>:
* This is the interrupt service routine for the system pipe.
*
*******************************************************************************/
void Cy_SysIpcPipeIsrCm4(void)
{
    Cy_IPC_Pipe_ExecuteCallback(CY_IPC_EP_CYPIPE_CM4_ADDR);
10008100:	2001      	movs	r0, #1
10008102:	f7fc bb89 	b.w	10004818 <Cy_IPC_Pipe_ExecuteCallback>

10008106 <Cy_SystemInit>:
}
10008106:	4770      	bx	lr

10008108 <Cy_SCB_GetFifoSize>:
__STATIC_INLINE uint32_t Cy_SCB_GetFifoSize(CySCB_Type const *base)
{
#if(CY_IP_MXSCB_VERSION>=3)
    {return (((uint32_t)(CY_SCB_FIFO_SIZE)) >> _FLD2VAL(SCB_CTRL_MEM_WIDTH, SCB_CTRL(base)));}
#elif(CY_IP_MXSCB_VERSION==1)
    {return (_FLD2BOOL(SCB_CTRL_BYTE_MODE, SCB_CTRL(base)) ? (CY_SCB_FIFO_SIZE) : (CY_SCB_FIFO_SIZE / 2UL));}
10008108:	6803      	ldr	r3, [r0, #0]
1000810a:	f413 6f00 	tst.w	r3, #2048	; 0x800
#endif /* CY_IP_MXSCB_VERSION */
}
1000810e:	bf0c      	ite	eq
10008110:	2040      	moveq	r0, #64	; 0x40
10008112:	2080      	movne	r0, #128	; 0x80
10008114:	4770      	bx	lr

10008116 <Cy_SCB_SetRxFifoLevel>:
{
10008116:	b508      	push	{r3, lr}
10008118:	4602      	mov	r2, r0
    CY_ASSERT_L2(CY_SCB_IS_TRIGGER_LEVEL_VALID(base, level));
1000811a:	f7ff fff5 	bl	10008108 <Cy_SCB_GetFifoSize>
1000811e:	4288      	cmp	r0, r1
10008120:	d800      	bhi.n	10008124 <Cy_SCB_SetRxFifoLevel+0xe>
10008122:	be01      	bkpt	0x0001
    CY_REG32_CLR_SET(SCB_RX_FIFO_CTRL(base), SCB_RX_FIFO_CTRL_TRIGGER_LEVEL, level);
10008124:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
10008128:	b2c9      	uxtb	r1, r1
1000812a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
1000812e:	430b      	orrs	r3, r1
10008130:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
10008134:	bd08      	pop	{r3, pc}

10008136 <SelectRxFifoLevel>:
* \return
* The RX FIFO level.
*
*******************************************************************************/
static uint32_t SelectRxFifoLevel(CySCB_Type const *base)
{
10008136:	b508      	push	{r3, lr}
10008138:	4601      	mov	r1, r0
    uint32_t halfFifoSize = Cy_SCB_GetFifoSize(base) / 2UL;
1000813a:	f7ff ffe5 	bl	10008108 <Cy_SCB_GetFifoSize>
1000813e:	4602      	mov	r2, r0
    return _FLD2VAL(SCB_UART_FLOW_CTRL_TRIGGER_LEVEL, SCB_UART_FLOW_CTRL(base));
10008140:	6d08      	ldr	r0, [r1, #80]	; 0x50
    uint32_t rtsFifoLevel = Cy_SCB_UART_GetRtsFifoLevel(base);

    return ((rtsFifoLevel != 0UL ) ? (rtsFifoLevel) : (halfFifoSize));
10008142:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
    uint32_t halfFifoSize = Cy_SCB_GetFifoSize(base) / 2UL;
10008146:	bf08      	it	eq
10008148:	0850      	lsreq	r0, r2, #1
}
1000814a:	bd08      	pop	{r3, pc}

1000814c <Cy_SCB_UART_Disable>:
    SCB_CTRL(base) &= (uint32_t) ~SCB_CTRL_ENABLED_Msk;
1000814c:	6803      	ldr	r3, [r0, #0]
1000814e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
10008152:	6003      	str	r3, [r0, #0]
    if (NULL != context)
10008154:	b121      	cbz	r1, 10008160 <Cy_SCB_UART_Disable+0x14>
        context->rxStatus  = 0UL;
10008156:	2300      	movs	r3, #0
10008158:	604b      	str	r3, [r1, #4]
        context->txStatus  = 0UL;
1000815a:	600b      	str	r3, [r1, #0]
        context->rxBufIdx  = 0UL;
1000815c:	620b      	str	r3, [r1, #32]
        context->txLeftToTransmit = 0UL;
1000815e:	62cb      	str	r3, [r1, #44]	; 0x2c
}
10008160:	4770      	bx	lr

10008162 <Cy_SCB_UART_GetNumInRingBuffer>:
*
*******************************************************************************/
uint32_t Cy_SCB_UART_GetNumInRingBuffer(CySCB_Type const *base, cy_stc_scb_uart_context_t const *context)
{
    uint32_t size;
    uint32_t locHead = context->rxRingBufHead;
10008162:	6908      	ldr	r0, [r1, #16]

    /* Suppress a compiler warning about unused variables */
    (void) base;

    if (locHead >= context->rxRingBufTail)
10008164:	694b      	ldr	r3, [r1, #20]
10008166:	4283      	cmp	r3, r0
    {
        size = (locHead - context->rxRingBufTail);
    }
    else
    {
        size = (locHead + (context->rxRingBufSize - context->rxRingBufTail));
10008168:	bf88      	it	hi
1000816a:	68ca      	ldrhi	r2, [r1, #12]
        size = (locHead - context->rxRingBufTail);
1000816c:	694b      	ldr	r3, [r1, #20]
        size = (locHead + (context->rxRingBufSize - context->rxRingBufTail));
1000816e:	bf88      	it	hi
10008170:	1880      	addhi	r0, r0, r2
10008172:	1ac0      	subs	r0, r0, r3
    }

    return (size);
}
10008174:	4770      	bx	lr

10008176 <Cy_SCB_UART_GetReceiveStatus>:
uint32_t Cy_SCB_UART_GetReceiveStatus(CySCB_Type const *base, cy_stc_scb_uart_context_t const *context)
{
    /* Suppress a compiler warning about unused variables */
    (void) base;

    return (context->rxStatus);
10008176:	6848      	ldr	r0, [r1, #4]
}
10008178:	4770      	bx	lr

1000817a <Cy_SCB_UART_GetTransmitStatus>:
uint32_t Cy_SCB_UART_GetTransmitStatus(CySCB_Type const *base, cy_stc_scb_uart_context_t const *context)
{
    /* Suppress a compiler warning about unused variables */
    (void) base;

    return (context->txStatus);
1000817a:	6808      	ldr	r0, [r1, #0]
}
1000817c:	4770      	bx	lr

1000817e <Cy_SCB_UART_Interrupt>:
* configuration and data retention. The user must not modify anything
* in this structure.
*
*******************************************************************************/
void Cy_SCB_UART_Interrupt(CySCB_Type *base, cy_stc_scb_uart_context_t *context)
{
1000817e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return (SCB_INTR_CAUSE(base));
10008182:	f8d0 3e00 	ldr.w	r3, [r0, #3584]	; 0xe00
10008186:	460c      	mov	r4, r1
    if (0UL != (CY_SCB_RX_INTR & Cy_SCB_GetInterruptCause(base)))
10008188:	0719      	lsls	r1, r3, #28
{
1000818a:	4605      	mov	r5, r0
    if (0UL != (CY_SCB_RX_INTR & Cy_SCB_GetInterruptCause(base)))
1000818c:	d562      	bpl.n	10008254 <Cy_SCB_UART_Interrupt+0xd6>
    return (SCB_INTR_RX_MASKED(base));
1000818e:	f8d0 3fcc 	ldr.w	r3, [r0, #4044]	; 0xfcc
    {
        /* Get RX error events: a frame error, parity error, and overflow */
        uint32_t locRxErr = (CY_SCB_UART_RECEIVE_ERR & Cy_SCB_GetRxInterruptStatusMasked(base));

        /* Handle the error conditions */
        if (0UL != locRxErr)
10008192:	f413 7348 	ands.w	r3, r3, #800	; 0x320
10008196:	d00a      	beq.n	100081ae <Cy_SCB_UART_Interrupt+0x30>
        {
            context->rxStatus |= locRxErr;
10008198:	6862      	ldr	r2, [r4, #4]
1000819a:	431a      	orrs	r2, r3
1000819c:	6062      	str	r2, [r4, #4]
    SCB_INTR_RX(base) = interruptMask;
1000819e:	f8c0 3fc0 	str.w	r3, [r0, #4032]	; 0xfc0
    (void) SCB_INTR_RX(base);
100081a2:	f8d0 3fc0 	ldr.w	r3, [r0, #4032]	; 0xfc0

            Cy_SCB_ClearRxInterrupt(base, locRxErr);

            if (NULL != context->cbEvents)
100081a6:	6b63      	ldr	r3, [r4, #52]	; 0x34
100081a8:	b10b      	cbz	r3, 100081ae <Cy_SCB_UART_Interrupt+0x30>
            {
                context->cbEvents(CY_SCB_UART_RECEIVE_ERR_EVENT);
100081aa:	2010      	movs	r0, #16
100081ac:	4798      	blx	r3
    return (SCB_INTR_RX_MASKED(base));
100081ae:	f8d5 3fcc 	ldr.w	r3, [r5, #4044]	; 0xfcc
            }
        }

        /* Break the detect */
        if (0UL != (CY_SCB_RX_INTR_UART_BREAK_DETECT & Cy_SCB_GetRxInterruptStatusMasked(base)))
100081b2:	051a      	lsls	r2, r3, #20
100081b4:	d509      	bpl.n	100081ca <Cy_SCB_UART_Interrupt+0x4c>
        {
            context->rxStatus |= CY_SCB_UART_RECEIVE_BREAK_DETECT;
100081b6:	6863      	ldr	r3, [r4, #4]
100081b8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
100081bc:	6063      	str	r3, [r4, #4]
    SCB_INTR_RX(base) = interruptMask;
100081be:	f44f 6300 	mov.w	r3, #2048	; 0x800
100081c2:	f8c5 3fc0 	str.w	r3, [r5, #4032]	; 0xfc0
    (void) SCB_INTR_RX(base);
100081c6:	f8d5 3fc0 	ldr.w	r3, [r5, #4032]	; 0xfc0
    return (SCB_INTR_RX_MASKED(base));
100081ca:	f8d5 3fcc 	ldr.w	r3, [r5, #4044]	; 0xfcc

            Cy_SCB_ClearRxInterrupt(base, CY_SCB_RX_INTR_UART_BREAK_DETECT);
        }

        /* Copy the received data */
        if (0UL != (CY_SCB_RX_INTR_LEVEL & Cy_SCB_GetRxInterruptStatusMasked(base)))
100081ce:	07db      	lsls	r3, r3, #31
100081d0:	d533      	bpl.n	1000823a <Cy_SCB_UART_Interrupt+0xbc>
        {
            if (context->rxBufSize > 0UL)
100081d2:	69e7      	ldr	r7, [r4, #28]
100081d4:	2f00      	cmp	r7, #0
100081d6:	f000 80d6 	beq.w	10008386 <Cy_SCB_UART_Interrupt+0x208>
*
*******************************************************************************/
static void HandleDataReceive(CySCB_Type *base, cy_stc_scb_uart_context_t *context)
{
    uint32_t numCopied;
    uint32_t irqRxLevel = SelectRxFifoLevel(base);
100081da:	4628      	mov	r0, r5
100081dc:	f7ff ffab 	bl	10008136 <SelectRxFifoLevel>

    /* Get data from RX FIFO */
    numCopied = Cy_SCB_UART_GetArray(base, context->rxBuf, context->rxBufSize);
100081e0:	69a1      	ldr	r1, [r4, #24]
    uint32_t irqRxLevel = SelectRxFifoLevel(base);
100081e2:	4606      	mov	r6, r0
    CY_ASSERT_L1(CY_SCB_IS_BUFFER_VALID(buffer, size));
100081e4:	b901      	cbnz	r1, 100081e8 <Cy_SCB_UART_Interrupt+0x6a>
100081e6:	be01      	bkpt	0x0001
    return Cy_SCB_ReadArray(base, buffer, size);
100081e8:	463a      	mov	r2, r7
100081ea:	4628      	mov	r0, r5
100081ec:	f000 f924 	bl	10008438 <Cy_SCB_ReadArray>

    /* Move the buffer */
    context->rxBufIdx  += numCopied;
100081f0:	6a23      	ldr	r3, [r4, #32]
    context->rxBufSize -= numCopied;
100081f2:	69e1      	ldr	r1, [r4, #28]
    context->rxBufIdx  += numCopied;
100081f4:	4403      	add	r3, r0
    context->rxBufSize -= numCopied;
100081f6:	1a09      	subs	r1, r1, r0
    context->rxBufIdx  += numCopied;
100081f8:	6223      	str	r3, [r4, #32]
    context->rxBufSize -= numCopied;
100081fa:	61e1      	str	r1, [r4, #28]

    if (0UL == context->rxBufSize)
100081fc:	2900      	cmp	r1, #0
100081fe:	f040 80b5 	bne.w	1000836c <Cy_SCB_UART_Interrupt+0x1ee>
    {
        if (NULL != context->rxRingBuf)
10008202:	68a3      	ldr	r3, [r4, #8]
10008204:	b153      	cbz	r3, 1000821c <Cy_SCB_UART_Interrupt+0x9e>
        {
            /* Adjust the level to proceed with the ring buffer */
            Cy_SCB_SetRxFifoLevel(base, (context->rxRingBufSize >= irqRxLevel) ?
10008206:	68e1      	ldr	r1, [r4, #12]
10008208:	428e      	cmp	r6, r1
1000820a:	bf94      	ite	ls
1000820c:	f106 31ff 	addls.w	r1, r6, #4294967295
10008210:	f101 31ff 	addhi.w	r1, r1, #4294967295
10008214:	4628      	mov	r0, r5
10008216:	f7ff ff7e 	bl	10008116 <Cy_SCB_SetRxFifoLevel>
    SCB_INTR_RX_MASK(base) = interruptMask;
1000821a:	2301      	movs	r3, #1
1000821c:	f8c5 3fc8 	str.w	r3, [r5, #4040]	; 0xfc8
        {
            Cy_SCB_SetRxInterruptMask(base, CY_SCB_CLEAR_ALL_INTR_SRC);
        }

        /* Update the status */
        context->rxStatus &= (uint32_t) ~CY_SCB_UART_RECEIVE_ACTIVE;
10008220:	6863      	ldr	r3, [r4, #4]
10008222:	f023 0301 	bic.w	r3, r3, #1
10008226:	6063      	str	r3, [r4, #4]

        /* Notify that receive is done in a callback */
        if (NULL != context->cbEvents)
10008228:	6b63      	ldr	r3, [r4, #52]	; 0x34
1000822a:	b10b      	cbz	r3, 10008230 <Cy_SCB_UART_Interrupt+0xb2>
        {
            context->cbEvents(CY_SCB_UART_RECEIVE_DONE_EVENT);
1000822c:	2004      	movs	r0, #4
1000822e:	4798      	blx	r3
    SCB_INTR_RX(base) = interruptMask;
10008230:	2301      	movs	r3, #1
10008232:	f8c5 3fc0 	str.w	r3, [r5, #4032]	; 0xfc0
    (void) SCB_INTR_RX(base);
10008236:	f8d5 3fc0 	ldr.w	r3, [r5, #4032]	; 0xfc0
    return (SCB_INTR_RX_MASKED(base));
1000823a:	f8d5 3fcc 	ldr.w	r3, [r5, #4044]	; 0xfcc
        if (0UL != (CY_SCB_RX_INTR_NOT_EMPTY & Cy_SCB_GetRxInterruptStatusMasked(base)))
1000823e:	075e      	lsls	r6, r3, #29
10008240:	d508      	bpl.n	10008254 <Cy_SCB_UART_Interrupt+0xd6>
            if (NULL != context->cbEvents)
10008242:	6b63      	ldr	r3, [r4, #52]	; 0x34
10008244:	b10b      	cbz	r3, 1000824a <Cy_SCB_UART_Interrupt+0xcc>
                context->cbEvents(CY_SCB_UART_RECEIVE_NOT_EMTPY);
10008246:	2040      	movs	r0, #64	; 0x40
10008248:	4798      	blx	r3
    SCB_INTR_RX(base) = interruptMask;
1000824a:	2304      	movs	r3, #4
1000824c:	f8c5 3fc0 	str.w	r3, [r5, #4032]	; 0xfc0
    (void) SCB_INTR_RX(base);
10008250:	f8d5 3fc0 	ldr.w	r3, [r5, #4032]	; 0xfc0
    return (SCB_INTR_CAUSE(base));
10008254:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
    if (0UL != (CY_SCB_TX_INTR & Cy_SCB_GetInterruptCause(base)))
10008258:	0758      	lsls	r0, r3, #29
1000825a:	f140 8085 	bpl.w	10008368 <Cy_SCB_UART_Interrupt+0x1ea>
    return (SCB_INTR_TX_MASKED(base));
1000825e:	f8d5 3f8c 	ldr.w	r3, [r5, #3980]	; 0xf8c
        if (0UL != locTxErr)
10008262:	f413 63a0 	ands.w	r3, r3, #1280	; 0x500
10008266:	d00a      	beq.n	1000827e <Cy_SCB_UART_Interrupt+0x100>
            context->txStatus |= locTxErr;
10008268:	6822      	ldr	r2, [r4, #0]
1000826a:	431a      	orrs	r2, r3
1000826c:	6022      	str	r2, [r4, #0]
    SCB_INTR_TX(base) = interruptMask;
1000826e:	f8c5 3f80 	str.w	r3, [r5, #3968]	; 0xf80
    (void) SCB_INTR_TX(base);
10008272:	f8d5 3f80 	ldr.w	r3, [r5, #3968]	; 0xf80
            if (NULL != context->cbEvents)
10008276:	6b63      	ldr	r3, [r4, #52]	; 0x34
10008278:	b10b      	cbz	r3, 1000827e <Cy_SCB_UART_Interrupt+0x100>
                context->cbEvents(CY_SCB_UART_TRANSMIT_ERR_EVENT);
1000827a:	2020      	movs	r0, #32
1000827c:	4798      	blx	r3
    return (SCB_INTR_TX_MASKED(base));
1000827e:	f8d5 3f8c 	ldr.w	r3, [r5, #3980]	; 0xf8c
        if (0UL != (CY_SCB_TX_INTR_LEVEL & Cy_SCB_GetTxInterruptStatusMasked(base)))
10008282:	07d9      	lsls	r1, r3, #31
10008284:	d553      	bpl.n	1000832e <Cy_SCB_UART_Interrupt+0x1b0>
*
*******************************************************************************/
static void HandleDataTransmit(CySCB_Type *base, cy_stc_scb_uart_context_t *context)
{
    uint32_t numToCopy;
    uint32_t fifoSize = Cy_SCB_GetFifoSize(base);
10008286:	4628      	mov	r0, r5
10008288:	f7ff ff3e 	bl	10008108 <Cy_SCB_GetFifoSize>
    bool     byteMode = Cy_SCB_IsTxDataWidthByte(base);

    if (context->txBufSize > 1UL)
1000828c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
* If true, the TX data width is a byte (8 bits). Otherwise, false.
*
*******************************************************************************/
__STATIC_INLINE bool Cy_SCB_IsTxDataWidthByte(CySCB_Type const *base)
{
    return (_FLD2VAL(SCB_TX_CTRL_DATA_WIDTH, SCB_TX_CTRL(base)) < CY_SCB_BYTE_WIDTH);
1000828e:	f8d5 7200 	ldr.w	r7, [r5, #512]	; 0x200
10008292:	2a01      	cmp	r2, #1
    uint32_t fifoSize = Cy_SCB_GetFifoSize(base);
10008294:	4680      	mov	r8, r0
10008296:	f007 0708 	and.w	r7, r7, #8
    if (context->txBufSize > 1UL)
1000829a:	d90f      	bls.n	100082bc <Cy_SCB_UART_Interrupt+0x13e>
    {
        uint8_t *buf = (uint8_t *) context->txBuf;
1000829c:	6a66      	ldr	r6, [r4, #36]	; 0x24

        /* Get the number of items left for transmission */
        context->txLeftToTransmit = context->txBufSize;
1000829e:	62e2      	str	r2, [r4, #44]	; 0x2c

        /* Put data into TX FIFO */
        numToCopy = Cy_SCB_UART_PutArray(base, context->txBuf, (context->txBufSize - 1UL));
100082a0:	3a01      	subs	r2, #1
* The number of data elements placed in the TX FIFO.
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_SCB_UART_PutArray(CySCB_Type *base, void *buffer, uint32_t size)
{
    CY_ASSERT_L1(CY_SCB_IS_BUFFER_VALID(buffer, size));
100082a2:	b906      	cbnz	r6, 100082a6 <Cy_SCB_UART_Interrupt+0x128>
100082a4:	be01      	bkpt	0x0001

    return Cy_SCB_WriteArray(base, buffer, size);
100082a6:	4631      	mov	r1, r6
100082a8:	4628      	mov	r0, r5
100082aa:	f000 f8fa 	bl	100084a2 <Cy_SCB_WriteArray>

        /* Move the buffer */
        context->txBufSize -= numToCopy;
100082ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
100082b0:	1a1b      	subs	r3, r3, r0
100082b2:	62a3      	str	r3, [r4, #40]	; 0x28

        buf = &buf[(byteMode) ? (numToCopy) : (2UL * numToCopy)];
100082b4:	b107      	cbz	r7, 100082b8 <Cy_SCB_UART_Interrupt+0x13a>
100082b6:	0040      	lsls	r0, r0, #1
100082b8:	4406      	add	r6, r0
        context->txBuf = (void *) buf;
100082ba:	6266      	str	r6, [r4, #36]	; 0x24
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
100082bc:	f8d5 3208 	ldr.w	r3, [r5, #520]	; 0x208
100082c0:	f3c3 0308 	ubfx	r3, r3, #0, #9
    }

    /* Put the last data item into TX FIFO */
    if ((fifoSize != Cy_SCB_GetNumInTxFifo(base)) && (1UL == context->txBufSize))
100082c4:	4598      	cmp	r8, r3
100082c6:	d02d      	beq.n	10008324 <Cy_SCB_UART_Interrupt+0x1a6>
100082c8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
100082ca:	2b01      	cmp	r3, #1
100082cc:	d12a      	bne.n	10008324 <Cy_SCB_UART_Interrupt+0x1a6>
    {
        uint32_t txData;
        uint32_t intrStatus;

        context->txBufSize = 0UL;
100082ce:	2300      	movs	r3, #0
100082d0:	62a3      	str	r3, [r4, #40]	; 0x28

        /* Get the last item from the buffer */
        txData = (uint32_t) ((byteMode) ? ((uint8_t *)  context->txBuf)[0UL] :
100082d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
100082d4:	2f00      	cmp	r7, #0
100082d6:	f040 8096 	bne.w	10008406 <Cy_SCB_UART_Interrupt+0x288>
100082da:	781e      	ldrb	r6, [r3, #0]
                                          ((uint16_t *) context->txBuf)[0UL]);

        /* Put the last data element and make sure that "TX done" will happen for it */
        intrStatus = Cy_SysLib_EnterCriticalSection();
100082dc:	f7fa f809 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>
    SCB_INTR_TX(base) = interruptMask;
100082e0:	f44f 7300 	mov.w	r3, #512	; 0x200
    SCB_TX_FIFO_WR(base) = data;
100082e4:	f8c5 6240 	str.w	r6, [r5, #576]	; 0x240
    SCB_INTR_TX(base) = interruptMask;
100082e8:	f8c5 3f80 	str.w	r3, [r5, #3968]	; 0xf80
    (void) SCB_INTR_TX(base);
100082ec:	f8d5 3f80 	ldr.w	r3, [r5, #3968]	; 0xf80

        Cy_SCB_WriteTxFifo(base, txData);
        Cy_SCB_ClearTxInterrupt(base, CY_SCB_TX_INTR_UART_DONE);

        Cy_SysLib_ExitCriticalSection(intrStatus);
100082f0:	f7fa f803 	bl	100022fa <Cy_SysLib_ExitCriticalSection>
    return (SCB_INTR_TX_MASK(base));
100082f4:	f8d5 3f88 	ldr.w	r3, [r5, #3976]	; 0xf88

        /* Disable the level interrupt source and enable "transfer done" */
        Cy_SCB_SetTxInterruptMask(base, (CY_SCB_TX_INTR_UART_DONE |
100082f8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
    CY_ASSERT_L2(CY_SCB_IS_INTR_VALID(interruptMask, CY_SCB_TX_INTR_MASK));
100082fc:	f423 63ee 	bic.w	r3, r3, #1904	; 0x770
10008300:	f022 0201 	bic.w	r2, r2, #1
10008304:	f023 0303 	bic.w	r3, r3, #3
10008308:	f442 7200 	orr.w	r2, r2, #512	; 0x200
1000830c:	b103      	cbz	r3, 10008310 <Cy_SCB_UART_Interrupt+0x192>
1000830e:	be01      	bkpt	0x0001
    SCB_INTR_TX_MASK(base) = interruptMask;
10008310:	f8c5 2f88 	str.w	r2, [r5, #3976]	; 0xf88
                    (Cy_SCB_GetTxInterruptMask(base) & (uint32_t) ~CY_SCB_TX_INTR_LEVEL)));

        /* Data is copied into TX FIFO */
        context->txStatus |= CY_SCB_UART_TRANSMIT_IN_FIFO;
10008314:	6823      	ldr	r3, [r4, #0]
10008316:	f043 0302 	orr.w	r3, r3, #2
1000831a:	6023      	str	r3, [r4, #0]

        if (NULL != context->cbEvents)
1000831c:	6b63      	ldr	r3, [r4, #52]	; 0x34
1000831e:	b10b      	cbz	r3, 10008324 <Cy_SCB_UART_Interrupt+0x1a6>
        {
            context->cbEvents(CY_SCB_UART_TRANSMIT_IN_FIFO_EVENT);
10008320:	2001      	movs	r0, #1
10008322:	4798      	blx	r3
    SCB_INTR_TX(base) = interruptMask;
10008324:	2301      	movs	r3, #1
10008326:	f8c5 3f80 	str.w	r3, [r5, #3968]	; 0xf80
    (void) SCB_INTR_TX(base);
1000832a:	f8d5 3f80 	ldr.w	r3, [r5, #3968]	; 0xf80
    return (SCB_INTR_TX_MASKED(base));
1000832e:	f8d5 3f8c 	ldr.w	r3, [r5, #3980]	; 0xf8c
        if (0UL != (CY_SCB_TX_INTR_UART_DONE & Cy_SCB_GetTxInterruptStatusMasked(base)))
10008332:	059a      	lsls	r2, r3, #22
10008334:	d50b      	bpl.n	1000834e <Cy_SCB_UART_Interrupt+0x1d0>
    SCB_INTR_TX_MASK(base) = interruptMask;
10008336:	2200      	movs	r2, #0
10008338:	f8c5 2f88 	str.w	r2, [r5, #3976]	; 0xf88
            context->txStatus &= (uint32_t) ~CY_SCB_UART_TRANSMIT_ACTIVE;
1000833c:	6823      	ldr	r3, [r4, #0]
1000833e:	f023 0301 	bic.w	r3, r3, #1
10008342:	6023      	str	r3, [r4, #0]
            if (NULL != context->cbEvents)
10008344:	6b63      	ldr	r3, [r4, #52]	; 0x34
            context->txLeftToTransmit = 0UL;
10008346:	62e2      	str	r2, [r4, #44]	; 0x2c
            if (NULL != context->cbEvents)
10008348:	b10b      	cbz	r3, 1000834e <Cy_SCB_UART_Interrupt+0x1d0>
                context->cbEvents(CY_SCB_UART_TRANSMIT_DONE_EVENT);
1000834a:	2002      	movs	r0, #2
1000834c:	4798      	blx	r3
    return (SCB_INTR_TX_MASKED(base));
1000834e:	f8d5 3f8c 	ldr.w	r3, [r5, #3980]	; 0xf8c
        if (0UL != (CY_SCB_UART_TX_EMPTY & Cy_SCB_GetTxInterruptStatusMasked(base)))
10008352:	06db      	lsls	r3, r3, #27
10008354:	d508      	bpl.n	10008368 <Cy_SCB_UART_Interrupt+0x1ea>
            if (NULL != context->cbEvents)
10008356:	6b63      	ldr	r3, [r4, #52]	; 0x34
10008358:	b10b      	cbz	r3, 1000835e <Cy_SCB_UART_Interrupt+0x1e0>
                context->cbEvents(CY_SCB_UART_TRANSMIT_EMTPY);
1000835a:	2080      	movs	r0, #128	; 0x80
1000835c:	4798      	blx	r3
    SCB_INTR_TX(base) = interruptMask;
1000835e:	2310      	movs	r3, #16
10008360:	f8c5 3f80 	str.w	r3, [r5, #3968]	; 0xf80
    (void) SCB_INTR_TX(base);
10008364:	f8d5 3f80 	ldr.w	r3, [r5, #3968]	; 0xf80
}
10008368:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (_FLD2VAL(SCB_RX_CTRL_DATA_WIDTH, SCB_RX_CTRL(base)) < CY_SCB_BYTE_WIDTH);
1000836c:	f8d5 2300 	ldr.w	r2, [r5, #768]	; 0x300
        uint8_t *buf = (uint8_t *) context->rxBuf;
10008370:	69a3      	ldr	r3, [r4, #24]
        buf = &buf[(Cy_SCB_IsRxDataWidthByte(base) ? (numCopied) : (2UL * numCopied))];
10008372:	0717      	lsls	r7, r2, #28
10008374:	bf48      	it	mi
10008376:	0040      	lslmi	r0, r0, #1
10008378:	4403      	add	r3, r0
        if (context->rxBufSize < irqRxLevel)
1000837a:	428e      	cmp	r6, r1
        context->rxBuf = (void *) buf;
1000837c:	61a3      	str	r3, [r4, #24]
        if (context->rxBufSize < irqRxLevel)
1000837e:	f67f af57 	bls.w	10008230 <Cy_SCB_UART_Interrupt+0xb2>
        uint32_t level = (numToCopy > 0UL) ? (numToCopy - 1UL) : 0UL;
10008382:	3901      	subs	r1, #1
10008384:	e02d      	b.n	100083e2 <Cy_SCB_UART_Interrupt+0x264>
                if (NULL != context->rxRingBuf)
10008386:	68a3      	ldr	r3, [r4, #8]
10008388:	2b00      	cmp	r3, #0
1000838a:	f43f af51 	beq.w	10008230 <Cy_SCB_UART_Interrupt+0xb2>
    uint32_t irqRxLevel = SelectRxFifoLevel(base);
1000838e:	4628      	mov	r0, r5
10008390:	f7ff fed1 	bl	10008136 <SelectRxFifoLevel>
    return _FLD2VAL(SCB_RX_FIFO_STATUS_USED, SCB_RX_FIFO_STATUS(base));
10008394:	f8d5 7308 	ldr.w	r7, [r5, #776]	; 0x308
    uint32_t locHead = context->rxRingBufHead;
10008398:	6926      	ldr	r6, [r4, #16]
    uint32_t irqRxLevel = SelectRxFifoLevel(base);
1000839a:	4680      	mov	r8, r0
1000839c:	f3c7 0708 	ubfx	r7, r7, #0, #9
        if (locHead == context->rxRingBufSize)
100083a0:	68e3      	ldr	r3, [r4, #12]
    while (numToCopy > 0UL)
100083a2:	b197      	cbz	r7, 100083ca <Cy_SCB_UART_Interrupt+0x24c>
        ++locHead;
100083a4:	3601      	adds	r6, #1
            locHead = 0UL;
100083a6:	429e      	cmp	r6, r3
100083a8:	bf08      	it	eq
100083aa:	2600      	moveq	r6, #0
        if (locHead == context->rxRingBufTail)
100083ac:	6963      	ldr	r3, [r4, #20]
100083ae:	42b3      	cmp	r3, r6
100083b0:	d11d      	bne.n	100083ee <Cy_SCB_UART_Interrupt+0x270>
            if (NULL != context->cbEvents)
100083b2:	6b63      	ldr	r3, [r4, #52]	; 0x34
100083b4:	b10b      	cbz	r3, 100083ba <Cy_SCB_UART_Interrupt+0x23c>
                context->cbEvents(CY_SCB_UART_RB_FULL_EVENT);
100083b6:	2008      	movs	r0, #8
100083b8:	4798      	blx	r3
            if (locHead == context->rxRingBufTail)
100083ba:	6963      	ldr	r3, [r4, #20]
100083bc:	429e      	cmp	r6, r3
100083be:	d116      	bne.n	100083ee <Cy_SCB_UART_Interrupt+0x270>
    SCB_INTR_RX_MASK(base) = interruptMask;
100083c0:	2300      	movs	r3, #0
100083c2:	f8c5 3fc8 	str.w	r3, [r5, #4040]	; 0xfc8
                locHead = (locHead > 0UL) ? (locHead - 1UL) : (context->rxRingBufSize - 1UL);
100083c6:	b186      	cbz	r6, 100083ea <Cy_SCB_UART_Interrupt+0x26c>
100083c8:	3e01      	subs	r6, #1
    context->rxRingBufHead = locHead;
100083ca:	6126      	str	r6, [r4, #16]
    numToCopy = context->rxRingBufSize - Cy_SCB_UART_GetNumInRingBuffer(base, context);
100083cc:	4621      	mov	r1, r4
100083ce:	4628      	mov	r0, r5
100083d0:	68e6      	ldr	r6, [r4, #12]
100083d2:	f7ff fec6 	bl	10008162 <Cy_SCB_UART_GetNumInRingBuffer>
100083d6:	1a31      	subs	r1, r6, r0
    if (numToCopy < irqRxLevel)
100083d8:	4588      	cmp	r8, r1
100083da:	f67f af29 	bls.w	10008230 <Cy_SCB_UART_Interrupt+0xb2>
        uint32_t level = (numToCopy > 0UL) ? (numToCopy - 1UL) : 0UL;
100083de:	2900      	cmp	r1, #0
100083e0:	d1cf      	bne.n	10008382 <Cy_SCB_UART_Interrupt+0x204>
        Cy_SCB_SetRxFifoLevel(base, level);
100083e2:	4628      	mov	r0, r5
100083e4:	f7ff fe97 	bl	10008116 <Cy_SCB_SetRxFifoLevel>
100083e8:	e722      	b.n	10008230 <Cy_SCB_UART_Interrupt+0xb2>
                locHead = (locHead > 0UL) ? (locHead - 1UL) : (context->rxRingBufSize - 1UL);
100083ea:	68e6      	ldr	r6, [r4, #12]
100083ec:	e7ec      	b.n	100083c8 <Cy_SCB_UART_Interrupt+0x24a>
    return (SCB_RX_FIFO_RD(base));
100083ee:	f8d5 2340 	ldr.w	r2, [r5, #832]	; 0x340
    return (_FLD2VAL(SCB_RX_CTRL_DATA_WIDTH, SCB_RX_CTRL(base)) < CY_SCB_BYTE_WIDTH);
100083f2:	f8d5 1300 	ldr.w	r1, [r5, #768]	; 0x300
            ((uint8_t *) context->rxRingBuf)[locHead] = (uint8_t) rxData;
100083f6:	68a3      	ldr	r3, [r4, #8]
        if (Cy_SCB_IsRxDataWidthByte(base))
100083f8:	0709      	lsls	r1, r1, #28
            ((uint8_t *) context->rxRingBuf)[locHead] = (uint8_t) rxData;
100083fa:	bf54      	ite	pl
100083fc:	559a      	strbpl	r2, [r3, r6]
            ((uint16_t *) context->rxRingBuf)[locHead] = (uint16_t) rxData;
100083fe:	f823 2016 	strhmi.w	r2, [r3, r6, lsl #1]
        --numToCopy;
10008402:	3f01      	subs	r7, #1
10008404:	e7cc      	b.n	100083a0 <Cy_SCB_UART_Interrupt+0x222>
        txData = (uint32_t) ((byteMode) ? ((uint8_t *)  context->txBuf)[0UL] :
10008406:	881e      	ldrh	r6, [r3, #0]
10008408:	e768      	b.n	100082dc <Cy_SCB_UART_Interrupt+0x15e>

1000840a <Cy_SCB_ReadArrayNoCheck>:
1000840a:	f8d0 3300 	ldr.w	r3, [r0, #768]	; 0x300
*******************************************************************************/
void Cy_SCB_ReadArrayNoCheck(CySCB_Type const *base, void *buffer, uint32_t size)
{
    uint32_t idx;
#if(CY_IP_MXSCB_VERSION==1)
    if (Cy_SCB_IsRxDataWidthByte(base))
1000840e:	071b      	lsls	r3, r3, #28
10008410:	d504      	bpl.n	1000841c <Cy_SCB_ReadArrayNoCheck+0x12>
10008412:	eb01 0242 	add.w	r2, r1, r2, lsl #1
    else
    {
        uint16_t *buf = (uint16_t *) buffer;

        /* Get data available in RX FIFO */
        for (idx = 0UL; idx < size; ++idx)
10008416:	4291      	cmp	r1, r2
10008418:	d109      	bne.n	1000842e <Cy_SCB_ReadArrayNoCheck+0x24>
        {
            buf[idx] = (uint32_t) Cy_SCB_ReadRxFifo(base);
        }
    }
#endif /* CY_IP_MXSCB_VERSION */
}
1000841a:	4770      	bx	lr
1000841c:	440a      	add	r2, r1
        for (idx = 0UL; idx < size; ++idx)
1000841e:	4291      	cmp	r1, r2
10008420:	d100      	bne.n	10008424 <Cy_SCB_ReadArrayNoCheck+0x1a>
10008422:	4770      	bx	lr
    return (SCB_RX_FIFO_RD(base));
10008424:	f8d0 3340 	ldr.w	r3, [r0, #832]	; 0x340
            buf[idx] = (uint8_t) Cy_SCB_ReadRxFifo(base);
10008428:	f801 3b01 	strb.w	r3, [r1], #1
        for (idx = 0UL; idx < size; ++idx)
1000842c:	e7f7      	b.n	1000841e <Cy_SCB_ReadArrayNoCheck+0x14>
1000842e:	f8d0 3340 	ldr.w	r3, [r0, #832]	; 0x340
            buf[idx] = (uint16_t) Cy_SCB_ReadRxFifo(base);
10008432:	f821 3b02 	strh.w	r3, [r1], #2
        for (idx = 0UL; idx < size; ++idx)
10008436:	e7ee      	b.n	10008416 <Cy_SCB_ReadArrayNoCheck+0xc>

10008438 <Cy_SCB_ReadArray>:
* \return
* The number of data elements read from the receive FIFO.
*
*******************************************************************************/
uint32_t Cy_SCB_ReadArray(CySCB_Type const *base, void *buffer, uint32_t size)
{
10008438:	b510      	push	{r4, lr}
    return _FLD2VAL(SCB_RX_FIFO_STATUS_USED, SCB_RX_FIFO_STATUS(base));
1000843a:	f8d0 4308 	ldr.w	r4, [r0, #776]	; 0x308
1000843e:	f3c4 0408 	ubfx	r4, r4, #0, #9
10008442:	4294      	cmp	r4, r2
10008444:	bf28      	it	cs
10008446:	4614      	movcs	r4, r2
    {
        numToCopy = size;
    }

    /* Get data available in RX FIFO */
    Cy_SCB_ReadArrayNoCheck(base, buffer, numToCopy);
10008448:	4622      	mov	r2, r4
1000844a:	f7ff ffde 	bl	1000840a <Cy_SCB_ReadArrayNoCheck>

    return (numToCopy);
}
1000844e:	4620      	mov	r0, r4
10008450:	bd10      	pop	{r4, pc}

10008452 <Cy_SCB_Write>:
    {return (_FLD2BOOL(SCB_CTRL_BYTE_MODE, SCB_CTRL(base)) ? (CY_SCB_FIFO_SIZE) : (CY_SCB_FIFO_SIZE / 2UL));}
10008452:	6803      	ldr	r3, [r0, #0]
10008454:	f413 6f00 	tst.w	r3, #2048	; 0x800
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
10008458:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    {return (_FLD2BOOL(SCB_CTRL_BYTE_MODE, SCB_CTRL(base)) ? (CY_SCB_FIFO_SIZE) : (CY_SCB_FIFO_SIZE / 2UL));}
1000845c:	bf0c      	ite	eq
1000845e:	2240      	moveq	r2, #64	; 0x40
10008460:	2280      	movne	r2, #128	; 0x80
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
10008462:	f3c3 0308 	ubfx	r3, r3, #0, #9
*******************************************************************************/
uint32_t Cy_SCB_Write(CySCB_Type *base, uint32_t data)
{
    uint32_t numCopied = 0UL;

    if (Cy_SCB_GetFifoSize(base) != Cy_SCB_GetNumInTxFifo(base))
10008466:	4293      	cmp	r3, r2
    SCB_TX_FIFO_WR(base) = data;
10008468:	bf1a      	itte	ne
1000846a:	f8c0 1240 	strne.w	r1, [r0, #576]	; 0x240
    {
        Cy_SCB_WriteTxFifo(base, data);

        numCopied = 1UL;
1000846e:	2001      	movne	r0, #1
    uint32_t numCopied = 0UL;
10008470:	2000      	moveq	r0, #0
    }

    return (numCopied);
}
10008472:	4770      	bx	lr

10008474 <Cy_SCB_WriteArrayNoCheck>:
    return (_FLD2VAL(SCB_TX_CTRL_DATA_WIDTH, SCB_TX_CTRL(base)) < CY_SCB_BYTE_WIDTH);
10008474:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
*******************************************************************************/
void Cy_SCB_WriteArrayNoCheck(CySCB_Type *base, void *buffer, uint32_t size)
{
    uint32_t idx;
#if(CY_IP_MXSCB_VERSION==1)
    if (Cy_SCB_IsTxDataWidthByte(base))
10008478:	071b      	lsls	r3, r3, #28
1000847a:	d504      	bpl.n	10008486 <Cy_SCB_WriteArrayNoCheck+0x12>
1000847c:	eb01 0242 	add.w	r2, r1, r2, lsl #1
    else
    {
        uint16_t *buf = (uint16_t *) buffer;

        /* Put data into TX FIFO */
        for (idx = 0UL; idx < size; ++idx)
10008480:	4291      	cmp	r1, r2
10008482:	d109      	bne.n	10008498 <Cy_SCB_WriteArrayNoCheck+0x24>
        {
            Cy_SCB_WriteTxFifo(base, (uint32_t) buf[idx]);
        }
    }
#endif /* CY_IP_MXSCB_VERSION */
}
10008484:	4770      	bx	lr
10008486:	440a      	add	r2, r1
        for (idx = 0UL; idx < size; ++idx)
10008488:	4291      	cmp	r1, r2
1000848a:	d100      	bne.n	1000848e <Cy_SCB_WriteArrayNoCheck+0x1a>
1000848c:	4770      	bx	lr
            Cy_SCB_WriteTxFifo(base, (uint32_t) buf[idx]);
1000848e:	f811 3b01 	ldrb.w	r3, [r1], #1
    SCB_TX_FIFO_WR(base) = data;
10008492:	f8c0 3240 	str.w	r3, [r0, #576]	; 0x240
        for (idx = 0UL; idx < size; ++idx)
10008496:	e7f7      	b.n	10008488 <Cy_SCB_WriteArrayNoCheck+0x14>
            Cy_SCB_WriteTxFifo(base, (uint32_t) buf[idx]);
10008498:	f831 3b02 	ldrh.w	r3, [r1], #2
1000849c:	f8c0 3240 	str.w	r3, [r0, #576]	; 0x240
        for (idx = 0UL; idx < size; ++idx)
100084a0:	e7ee      	b.n	10008480 <Cy_SCB_WriteArrayNoCheck+0xc>

100084a2 <Cy_SCB_WriteArray>:
* \return
* The number of data elements placed in the transmit FIFO.
*
*******************************************************************************/
uint32_t Cy_SCB_WriteArray(CySCB_Type *base, void *buffer, uint32_t size)
{
100084a2:	b510      	push	{r4, lr}
    {return (_FLD2BOOL(SCB_CTRL_BYTE_MODE, SCB_CTRL(base)) ? (CY_SCB_FIFO_SIZE) : (CY_SCB_FIFO_SIZE / 2UL));}
100084a4:	6804      	ldr	r4, [r0, #0]
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
100084a6:	f8d0 3208 	ldr.w	r3, [r0, #520]	; 0x208
    {return (_FLD2BOOL(SCB_CTRL_BYTE_MODE, SCB_CTRL(base)) ? (CY_SCB_FIFO_SIZE) : (CY_SCB_FIFO_SIZE / 2UL));}
100084aa:	f414 6f00 	tst.w	r4, #2048	; 0x800
100084ae:	bf0c      	ite	eq
100084b0:	2440      	moveq	r4, #64	; 0x40
100084b2:	2480      	movne	r4, #128	; 0x80
    return _FLD2VAL(SCB_TX_FIFO_STATUS_USED, SCB_TX_FIFO_STATUS(base));
100084b4:	f3c3 0308 	ubfx	r3, r3, #0, #9
    /* Get free entries in TX FIFO */
    uint32_t numToCopy = Cy_SCB_GetFifoSize(base) - Cy_SCB_GetNumInTxFifo(base);
100084b8:	1ae4      	subs	r4, r4, r3
100084ba:	4294      	cmp	r4, r2
100084bc:	bf28      	it	cs
100084be:	4614      	movcs	r4, r2
    if (numToCopy > size)
    {
        numToCopy = size;
    }

    Cy_SCB_WriteArrayNoCheck(base, buffer, numToCopy);
100084c0:	4622      	mov	r2, r4
100084c2:	f7ff ffd7 	bl	10008474 <Cy_SCB_WriteArrayNoCheck>

    return (numToCopy);
}
100084c6:	4620      	mov	r0, r4
100084c8:	bd10      	pop	{r4, pc}

100084ca <Cy_GPIO_Read>:
    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
100084ca:	2908      	cmp	r1, #8
100084cc:	d900      	bls.n	100084d0 <Cy_GPIO_Read+0x6>
100084ce:	be01      	bkpt	0x0001
    tempReg = GPIO_PRT_IN(base);
100084d0:	6900      	ldr	r0, [r0, #16]
    return (tempReg >> (pinNum)) & CY_GPIO_IN_MASK;
100084d2:	40c8      	lsrs	r0, r1
}
100084d4:	f000 0001 	and.w	r0, r0, #1
100084d8:	4770      	bx	lr

100084da <Cy_GPIO_Write>:
    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
100084da:	2907      	cmp	r1, #7
100084dc:	d900      	bls.n	100084e0 <Cy_GPIO_Write+0x6>
100084de:	be01      	bkpt	0x0001
    outMask = CY_GPIO_OUT_MASK << pinNum;
100084e0:	2301      	movs	r3, #1
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
100084e2:	429a      	cmp	r2, r3
    outMask = CY_GPIO_OUT_MASK << pinNum;
100084e4:	fa03 f101 	lsl.w	r1, r3, r1
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
100084e8:	d902      	bls.n	100084f0 <Cy_GPIO_Write+0x16>
100084ea:	be01      	bkpt	0x0001
        GPIO_PRT_OUT_SET(base) = outMask;
100084ec:	6081      	str	r1, [r0, #8]
}
100084ee:	4770      	bx	lr
    if(0UL == value)
100084f0:	2a00      	cmp	r2, #0
100084f2:	d1fb      	bne.n	100084ec <Cy_GPIO_Write+0x12>
        GPIO_PRT_OUT_CLR(base) = outMask;
100084f4:	6041      	str	r1, [r0, #4]
100084f6:	4770      	bx	lr

100084f8 <Cy_GPIO_Set>:
    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
100084f8:	2907      	cmp	r1, #7
100084fa:	d900      	bls.n	100084fe <Cy_GPIO_Set+0x6>
100084fc:	be01      	bkpt	0x0001
    outMask = CY_GPIO_OUT_MASK << pinNum;
100084fe:	2301      	movs	r3, #1
10008500:	408b      	lsls	r3, r1
    GPIO_PRT_OUT_SET(base) = outMask;
10008502:	6083      	str	r3, [r0, #8]
}
10008504:	4770      	bx	lr

10008506 <Cy_GPIO_ClearInterrupt>:
    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10008506:	2908      	cmp	r1, #8
10008508:	d900      	bls.n	1000850c <Cy_GPIO_ClearInterrupt+0x6>
1000850a:	be01      	bkpt	0x0001
    (void)GPIO_PRT_INTR(base);
1000850c:	6943      	ldr	r3, [r0, #20]
    prtIntr = CY_GPIO_INTR_STATUS_MASK << pinNum;
1000850e:	2301      	movs	r3, #1
10008510:	408b      	lsls	r3, r1
    GPIO_PRT_INTR(base) = prtIntr;
10008512:	6143      	str	r3, [r0, #20]
    (void)GPIO_PRT_INTR(base);
10008514:	6943      	ldr	r3, [r0, #20]
}
10008516:	4770      	bx	lr

10008518 <Cy_GPIO_SetInterruptMask>:
    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10008518:	2908      	cmp	r1, #8
{
1000851a:	b510      	push	{r4, lr}
    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
1000851c:	d900      	bls.n	10008520 <Cy_GPIO_SetInterruptMask+0x8>
1000851e:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
10008520:	2a01      	cmp	r2, #1
10008522:	d900      	bls.n	10008526 <Cy_GPIO_SetInterruptMask+0xe>
10008524:	be01      	bkpt	0x0001
    tempReg= GPIO_PRT_INTR_MASK(base) & ~(CY_GPIO_INTR_EN_MASK << pinNum);
10008526:	6983      	ldr	r3, [r0, #24]
10008528:	2401      	movs	r4, #1
1000852a:	408c      	lsls	r4, r1
    intrMask = tempReg | ((value & CY_GPIO_INTR_EN_MASK) << pinNum);
1000852c:	f002 0201 	and.w	r2, r2, #1
    tempReg= GPIO_PRT_INTR_MASK(base) & ~(CY_GPIO_INTR_EN_MASK << pinNum);
10008530:	ea23 0304 	bic.w	r3, r3, r4
    intrMask = tempReg | ((value & CY_GPIO_INTR_EN_MASK) << pinNum);
10008534:	fa02 f101 	lsl.w	r1, r2, r1
10008538:	430b      	orrs	r3, r1
    GPIO_PRT_INTR_MASK(base) = intrMask;
1000853a:	6183      	str	r3, [r0, #24]
}
1000853c:	bd10      	pop	{r4, pc}

1000853e <Cy_GPIO_GetInterruptStatusMasked>:
    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
1000853e:	2908      	cmp	r1, #8
10008540:	d900      	bls.n	10008544 <Cy_GPIO_GetInterruptStatusMasked+0x6>
10008542:	be01      	bkpt	0x0001
    tempReg = GPIO_PRT_INTR_MASKED(base);
10008544:	69c0      	ldr	r0, [r0, #28]
    return (tempReg >> pinNum) & CY_GPIO_INTR_MASKED_MASK;
10008546:	40c8      	lsrs	r0, r1
}
10008548:	f000 0001 	and.w	r0, r0, #1
1000854c:	4770      	bx	lr

1000854e <Cy_SysClk_ClkPumpGetFrequency>:
{
1000854e:	b508      	push	{r3, lr}
    return (Cy_SysClk_ClkPumpIsEnabled() ?
10008550:	f7fc fc14 	bl	10004d7c <Cy_SysClk_ClkPumpIsEnabled>
             (1UL << (uint32_t)Cy_SysClk_ClkPumpGetDivider())) : 0UL);
10008554:	b140      	cbz	r0, 10008568 <Cy_SysClk_ClkPumpGetFrequency+0x1a>
            (Cy_SysClk_ClkPathGetFrequency((uint32_t)Cy_SysClk_ClkPumpGetSource()) /
10008556:	f7fc fbe5 	bl	10004d24 <Cy_SysClk_ClkPumpGetSource>
1000855a:	f7fd f9d1 	bl	10005900 <Cy_SysClk_ClkPathGetFrequency>
1000855e:	4602      	mov	r2, r0
             (1UL << (uint32_t)Cy_SysClk_ClkPumpGetDivider())) : 0UL);
10008560:	f7fc fbfa 	bl	10004d58 <Cy_SysClk_ClkPumpGetDivider>
10008564:	fa22 f000 	lsr.w	r0, r2, r0
}
10008568:	bd08      	pop	{r3, pc}

1000856a <Cy_SysClk_ClkHfGetFrequency>:
{
1000856a:	b510      	push	{r4, lr}
1000856c:	4602      	mov	r2, r0
    uint32_t pDiv = 1UL << (uint32_t)Cy_SysClk_ClkHfGetDivider(clkHf); /* root prescaler (1/2/4/8) */
1000856e:	f7fc fd49 	bl	10005004 <Cy_SysClk_ClkHfGetDivider>
10008572:	4604      	mov	r4, r0
    uint32_t path = (uint32_t) Cy_SysClk_ClkHfGetSource(clkHf); /* path input for root 0 (clkHf[0]) */
10008574:	4610      	mov	r0, r2
10008576:	f7fc fd15 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
    uint32_t freq = Cy_SysClk_ClkPathGetFrequency(path);
1000857a:	f7fd f9c1 	bl	10005900 <Cy_SysClk_ClkPathGetFrequency>
    uint32_t pDiv = 1UL << (uint32_t)Cy_SysClk_ClkHfGetDivider(clkHf); /* root prescaler (1/2/4/8) */
1000857e:	2301      	movs	r3, #1
10008580:	40a3      	lsls	r3, r4
    return (CY_SYSLIB_DIV_ROUND(freq, pDiv));
10008582:	eb00 0053 	add.w	r0, r0, r3, lsr #1
}
10008586:	40e0      	lsrs	r0, r4
10008588:	bd10      	pop	{r4, pc}

1000858a <Cy_SysClk_ClkPeriGetFrequency>:
{
1000858a:	b508      	push	{r3, lr}
    uint32_t locFreq = Cy_SysClk_ClkHfGetFrequency(0UL); /* Get root frequency */
1000858c:	2000      	movs	r0, #0
1000858e:	f7ff ffec 	bl	1000856a <Cy_SysClk_ClkHfGetFrequency>
10008592:	4601      	mov	r1, r0
    uint32_t locDiv = 1UL + (uint32_t)Cy_SysClk_ClkPeriGetDivider(); /* peri prescaler (1-256) */
10008594:	f7fc fc80 	bl	10004e98 <Cy_SysClk_ClkPeriGetDivider>
10008598:	3001      	adds	r0, #1
    return (CY_SYSLIB_DIV_ROUND(locFreq, locDiv));
1000859a:	eb01 0150 	add.w	r1, r1, r0, lsr #1
}
1000859e:	fbb1 f0f0 	udiv	r0, r1, r0
100085a2:	bd08      	pop	{r3, pc}

100085a4 <Cy_SysClk_ClkSlowGetFrequency>:
{
100085a4:	b508      	push	{r3, lr}
    uint32_t locFreq = Cy_SysClk_ClkPeriGetFrequency(); /* Get Peri frequency */
100085a6:	f7ff fff0 	bl	1000858a <Cy_SysClk_ClkPeriGetFrequency>
100085aa:	4601      	mov	r1, r0
    uint32_t locDiv = 1UL + (uint32_t)Cy_SysClk_ClkSlowGetDivider(); /* peri prescaler (1-256) */
100085ac:	f7fc fb9c 	bl	10004ce8 <Cy_SysClk_ClkSlowGetDivider>
100085b0:	3001      	adds	r0, #1
    return (CY_SYSLIB_DIV_ROUND(locFreq, locDiv));
100085b2:	eb01 0150 	add.w	r1, r1, r0, lsr #1
}
100085b6:	fbb1 f0f0 	udiv	r0, r1, r0
100085ba:	bd08      	pop	{r3, pc}

100085bc <Cy_SysClk_PeriphGetFrequency>:
{
100085bc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint32_t integer = 0UL;        /* Integer part of peripheral divider */
100085be:	2300      	movs	r3, #0
{
100085c0:	4605      	mov	r5, r0
100085c2:	460e      	mov	r6, r1
    uint32_t integer = 0UL;        /* Integer part of peripheral divider */
100085c4:	9300      	str	r3, [sp, #0]
    uint32_t freq = Cy_SysClk_ClkPeriGetFrequency(); /* Get Peri frequency */
100085c6:	f7ff ffe0 	bl	1000858a <Cy_SysClk_ClkPeriGetFrequency>
100085ca:	4604      	mov	r4, r0
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
100085cc:	b95d      	cbnz	r5, 100085e6 <Cy_SysClk_PeriphGetFrequency+0x2a>
100085ce:	2e07      	cmp	r6, #7
100085d0:	d830      	bhi.n	10008634 <Cy_SysClk_PeriphGetFrequency+0x78>
            integer = 1UL + Cy_SysClk_PeriphGetDivider(dividerType, dividerNum);
100085d2:	4631      	mov	r1, r6
100085d4:	4628      	mov	r0, r5
100085d6:	f7fc fa19 	bl	10004a0c <Cy_SysClk_PeriphGetDivider>
100085da:	3001      	adds	r0, #1
            freq = CY_SYSLIB_DIV_ROUND(freq, integer);
100085dc:	eb04 0450 	add.w	r4, r4, r0, lsr #1
100085e0:	fbb4 f4f0 	udiv	r4, r4, r0
            break;
100085e4:	e006      	b.n	100085f4 <Cy_SysClk_PeriphGetFrequency+0x38>
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
100085e6:	2d01      	cmp	r5, #1
100085e8:	d007      	beq.n	100085fa <Cy_SysClk_PeriphGetFrequency+0x3e>
100085ea:	2d02      	cmp	r5, #2
100085ec:	d007      	beq.n	100085fe <Cy_SysClk_PeriphGetFrequency+0x42>
100085ee:	2d03      	cmp	r5, #3
100085f0:	d009      	beq.n	10008606 <Cy_SysClk_PeriphGetFrequency+0x4a>
100085f2:	be01      	bkpt	0x0001
}
100085f4:	4620      	mov	r0, r4
100085f6:	b002      	add	sp, #8
100085f8:	bd70      	pop	{r4, r5, r6, pc}
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
100085fa:	2e0f      	cmp	r6, #15
100085fc:	e7e8      	b.n	100085d0 <Cy_SysClk_PeriphGetFrequency+0x14>
100085fe:	2e03      	cmp	r6, #3
10008600:	d903      	bls.n	1000860a <Cy_SysClk_PeriphGetFrequency+0x4e>
10008602:	be01      	bkpt	0x0001
    switch(dividerType)
10008604:	e001      	b.n	1000860a <Cy_SysClk_PeriphGetFrequency+0x4e>
    CY_ASSERT_L1(((dividerType == CY_SYSCLK_DIV_8_BIT)    && (dividerNum < PERI_DIV_8_NR))    || \
10008606:	2e00      	cmp	r6, #0
10008608:	d1fb      	bne.n	10008602 <Cy_SysClk_PeriphGetFrequency+0x46>
                Cy_SysClk_PeriphGetFracDivider(dividerType, dividerNum, &integer, &locFrac);
1000860a:	4628      	mov	r0, r5
1000860c:	ab01      	add	r3, sp, #4
1000860e:	466a      	mov	r2, sp
10008610:	4631      	mov	r1, r6
10008612:	f7fc fa69 	bl	10004ae8 <Cy_SysClk_PeriphGetFracDivider>
                locDiv = ((1UL + integer) * 32UL) + locFrac;
10008616:	9b00      	ldr	r3, [sp, #0]
10008618:	9a01      	ldr	r2, [sp, #4]
1000861a:	3301      	adds	r3, #1
1000861c:	eb02 1243 	add.w	r2, r2, r3, lsl #5
                freq = (uint32_t) CY_SYSLIB_DIV_ROUND(locFreq, (uint64_t)locDiv);
10008620:	2300      	movs	r3, #0
10008622:	0850      	lsrs	r0, r2, #1
10008624:	4619      	mov	r1, r3
10008626:	2520      	movs	r5, #32
10008628:	fbe4 0105 	umlal	r0, r1, r4, r5
1000862c:	f7f9 feb8 	bl	100023a0 <__aeabi_uldivmod>
10008630:	4604      	mov	r4, r0
    return (freq);
10008632:	e7df      	b.n	100085f4 <Cy_SysClk_PeriphGetFrequency+0x38>
10008634:	be01      	bkpt	0x0001
    switch(dividerType)
10008636:	e7cc      	b.n	100085d2 <Cy_SysClk_PeriphGetFrequency+0x16>

10008638 <Cy_SysClk_ClkFastGetFrequency>:
{
10008638:	b508      	push	{r3, lr}
    uint32_t locFreq = Cy_SysClk_ClkHfGetFrequency(0UL); /* Get root frequency */
1000863a:	2000      	movs	r0, #0
1000863c:	f7ff ff95 	bl	1000856a <Cy_SysClk_ClkHfGetFrequency>
10008640:	4601      	mov	r1, r0
    uint32_t locDiv = 1UL + (uint32_t)Cy_SysClk_ClkFastGetDivider(); /* fast prescaler (1-256) */
10008642:	f7fc fc41 	bl	10004ec8 <Cy_SysClk_ClkFastGetDivider>
10008646:	3001      	adds	r0, #1
    return (CY_SYSLIB_DIV_ROUND(locFreq, locDiv));
10008648:	eb01 0150 	add.w	r1, r1, r0, lsr #1
}
1000864c:	fbb1 f0f0 	udiv	r0, r1, r0
10008650:	bd08      	pop	{r3, pc}

10008652 <Cy_SysPm_IsSystemUlp>:
{
10008652:	b508      	push	{r3, lr}
    return((Cy_SysPm_ReadStatus() & CY_SYSPM_STATUS_SYSTEM_ULP) != 0U);
10008654:	f7fd fa48 	bl	10005ae8 <Cy_SysPm_ReadStatus>
}
10008658:	f3c0 20c0 	ubfx	r0, r0, #11, #1
1000865c:	bd08      	pop	{r3, pc}

1000865e <Cy_SCB_SetTxInterruptMask>:
    CY_ASSERT_L2(CY_SCB_IS_INTR_VALID(interruptMask, CY_SCB_TX_INTR_MASK));
1000865e:	f421 63ee 	bic.w	r3, r1, #1904	; 0x770
10008662:	f023 0303 	bic.w	r3, r3, #3
10008666:	b103      	cbz	r3, 1000866a <Cy_SCB_SetTxInterruptMask+0xc>
10008668:	be01      	bkpt	0x0001
    SCB_INTR_TX_MASK(base) = interruptMask;
1000866a:	f8c0 1f88 	str.w	r1, [r0, #3976]	; 0xf88
}
1000866e:	4770      	bx	lr

10008670 <_cyhal_uart_convert_stopbits>:
    switch (stopbits)
10008670:	3801      	subs	r0, #1
10008672:	2803      	cmp	r0, #3
10008674:	d807      	bhi.n	10008686 <_cyhal_uart_convert_stopbits+0x16>
10008676:	e8df f000 	tbb	[pc, r0]
1000867a:	0907      	.short	0x0907
1000867c:	0402      	.short	0x0402
            return CY_SCB_UART_STOP_BITS_3;
1000867e:	2006      	movs	r0, #6
10008680:	4770      	bx	lr
            return CY_SCB_UART_STOP_BITS_4;
10008682:	2008      	movs	r0, #8
10008684:	4770      	bx	lr
10008686:	be01      	bkpt	0x0001
            return CY_SCB_UART_STOP_BITS_1;
10008688:	2002      	movs	r0, #2
1000868a:	4770      	bx	lr
            return CY_SCB_UART_STOP_BITS_2;
1000868c:	2004      	movs	r0, #4
}
1000868e:	4770      	bx	lr

10008690 <_cyhal_uart_irq_handler>:
{
10008690:	b570      	push	{r4, r5, r6, lr}
    cyhal_uart_t *obj = (cyhal_uart_t*) _cyhal_scb_get_irq_obj();
10008692:	f7fd fd93 	bl	100061bc <_cyhal_scb_get_irq_obj>
    uint32_t txMasked = Cy_SCB_GetTxInterruptStatusMasked(obj->base);
10008696:	4601      	mov	r1, r0
    cyhal_uart_t *obj = (cyhal_uart_t*) _cyhal_scb_get_irq_obj();
10008698:	4604      	mov	r4, r0
    uint32_t txMasked = Cy_SCB_GetTxInterruptStatusMasked(obj->base);
1000869a:	f851 0b18 	ldr.w	r0, [r1], #24
    return (SCB_INTR_TX_MASKED(base));
1000869e:	f8d0 5f8c 	ldr.w	r5, [r0, #3980]	; 0xf8c
    return (SCB_INTR_RX_MASKED(base));
100086a2:	f8d0 6fcc 	ldr.w	r6, [r0, #4044]	; 0xfcc
    Cy_SCB_UART_Interrupt(obj->base, &(obj->context));
100086a6:	f7ff fd6a 	bl	1000817e <Cy_SCB_UART_Interrupt>
    if (0UL != (CY_SCB_UART_TX_OVERFLOW & txMasked))
100086aa:	06aa      	lsls	r2, r5, #26
100086ac:	d508      	bpl.n	100086c0 <_cyhal_uart_irq_handler+0x30>
        Cy_SCB_ClearTxInterrupt(obj->base, CY_SCB_UART_TX_OVERFLOW);
100086ae:	6823      	ldr	r3, [r4, #0]
    SCB_INTR_TX(base) = interruptMask;
100086b0:	2020      	movs	r0, #32
100086b2:	f8c3 0f80 	str.w	r0, [r3, #3968]	; 0xf80
    (void) SCB_INTR_TX(base);
100086b6:	f8d3 3f80 	ldr.w	r3, [r3, #3968]	; 0xf80
        if (NULL != obj->context.cbEvents)
100086ba:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
100086bc:	b103      	cbz	r3, 100086c0 <_cyhal_uart_irq_handler+0x30>
            obj->context.cbEvents(CY_SCB_UART_TRANSMIT_ERR_EVENT);
100086be:	4798      	blx	r3
    if (0UL != (CY_SCB_UART_TX_UNDERFLOW & txMasked))
100086c0:	066b      	lsls	r3, r5, #25
100086c2:	d509      	bpl.n	100086d8 <_cyhal_uart_irq_handler+0x48>
        Cy_SCB_ClearTxInterrupt(obj->base, CY_SCB_UART_TX_UNDERFLOW);
100086c4:	6823      	ldr	r3, [r4, #0]
    SCB_INTR_TX(base) = interruptMask;
100086c6:	2240      	movs	r2, #64	; 0x40
100086c8:	f8c3 2f80 	str.w	r2, [r3, #3968]	; 0xf80
    (void) SCB_INTR_TX(base);
100086cc:	f8d3 3f80 	ldr.w	r3, [r3, #3968]	; 0xf80
        if (NULL != obj->context.cbEvents)
100086d0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
100086d2:	b10b      	cbz	r3, 100086d8 <_cyhal_uart_irq_handler+0x48>
            obj->context.cbEvents(CY_SCB_UART_TRANSMIT_ERR_EVENT);
100086d4:	2020      	movs	r0, #32
100086d6:	4798      	blx	r3
    if (0UL != (CY_SCB_UART_TX_TRIGGER & txMasked))
100086d8:	07e8      	lsls	r0, r5, #31
100086da:	d504      	bpl.n	100086e6 <_cyhal_uart_irq_handler+0x56>
        if (NULL != obj->context.cbEvents)
100086dc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
100086de:	b113      	cbz	r3, 100086e6 <_cyhal_uart_irq_handler+0x56>
            obj->context.cbEvents(CYHAL_UART_IRQ_TX_FIFO >> 1u);
100086e0:	f44f 7080 	mov.w	r0, #256	; 0x100
100086e4:	4798      	blx	r3
    if (0UL != (CY_SCB_UART_TX_DONE & txMasked))
100086e6:	05a9      	lsls	r1, r5, #22
100086e8:	d50c      	bpl.n	10008704 <_cyhal_uart_irq_handler+0x74>
        Cy_SCB_ClearTxInterrupt(obj->base, CY_SCB_UART_TX_DONE);
100086ea:	6823      	ldr	r3, [r4, #0]
    SCB_INTR_TX(base) = interruptMask;
100086ec:	f44f 7200 	mov.w	r2, #512	; 0x200
100086f0:	f8c3 2f80 	str.w	r2, [r3, #3968]	; 0xf80
        Cy_SCB_SetTxInterruptMask(obj->base, Cy_SCB_GetTxInterruptMask(obj->base) | CY_SCB_UART_TX_DONE);
100086f4:	6820      	ldr	r0, [r4, #0]
    (void) SCB_INTR_TX(base);
100086f6:	f8d3 3f80 	ldr.w	r3, [r3, #3968]	; 0xf80
    return (SCB_INTR_TX_MASK(base));
100086fa:	f8d0 1f88 	ldr.w	r1, [r0, #3976]	; 0xf88
100086fe:	4311      	orrs	r1, r2
10008700:	f7ff ffad 	bl	1000865e <Cy_SCB_SetTxInterruptMask>
    if (0UL != (CY_SCB_RX_INTR_UNDERFLOW & rxMasked))
10008704:	0672      	lsls	r2, r6, #25
10008706:	d509      	bpl.n	1000871c <_cyhal_uart_irq_handler+0x8c>
        Cy_SCB_ClearRxInterrupt(obj->base, CY_SCB_RX_INTR_UNDERFLOW);
10008708:	6823      	ldr	r3, [r4, #0]
    SCB_INTR_RX(base) = interruptMask;
1000870a:	2240      	movs	r2, #64	; 0x40
1000870c:	f8c3 2fc0 	str.w	r2, [r3, #4032]	; 0xfc0
    (void) SCB_INTR_RX(base);
10008710:	f8d3 3fc0 	ldr.w	r3, [r3, #4032]	; 0xfc0
        if (NULL != obj->context.cbEvents)
10008714:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
10008716:	b10b      	cbz	r3, 1000871c <_cyhal_uart_irq_handler+0x8c>
            obj->context.cbEvents(CY_SCB_UART_RECEIVE_ERR_EVENT);
10008718:	2010      	movs	r0, #16
1000871a:	4798      	blx	r3
    if (0UL != (CY_SCB_UART_RX_TRIGGER & rxMasked))
1000871c:	07f3      	lsls	r3, r6, #31
1000871e:	d506      	bpl.n	1000872e <_cyhal_uart_irq_handler+0x9e>
        if (NULL != obj->context.cbEvents)
10008720:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
10008722:	b123      	cbz	r3, 1000872e <_cyhal_uart_irq_handler+0x9e>
}
10008724:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            obj->context.cbEvents(CYHAL_UART_IRQ_RX_FIFO >> 1u);
10008728:	f44f 7000 	mov.w	r0, #512	; 0x200
1000872c:	4718      	bx	r3
}
1000872e:	bd70      	pop	{r4, r5, r6, pc}

10008730 <cyhal_uart_init_cfg>:
{
10008730:	b570      	push	{r4, r5, r6, lr}
10008732:	460d      	mov	r5, r1
    CY_ASSERT(NULL != obj);
10008734:	4606      	mov	r6, r0
10008736:	b900      	cbnz	r0, 1000873a <cyhal_uart_init_cfg+0xa>
10008738:	be01      	bkpt	0x0001
    CY_ASSERT(NULL != cfg);
1000873a:	b905      	cbnz	r5, 1000873e <cyhal_uart_init_cfg+0xe>
1000873c:	be01      	bkpt	0x0001
    CY_ASSERT(NULL != cfg->config);
1000873e:	686b      	ldr	r3, [r5, #4]
10008740:	b903      	cbnz	r3, 10008744 <cyhal_uart_init_cfg+0x14>
10008742:	be01      	bkpt	0x0001
    memset(obj, 0, sizeof(cyhal_uart_t));
10008744:	22a8      	movs	r2, #168	; 0xa8
10008746:	2100      	movs	r1, #0
10008748:	4630      	mov	r0, r6
1000874a:	f7ff fbf9 	bl	10007f40 <memset>
    obj->resource = *cfg->resource;
1000874e:	682b      	ldr	r3, [r5, #0]
10008750:	881a      	ldrh	r2, [r3, #0]
10008752:	789b      	ldrb	r3, [r3, #2]
10008754:	71b3      	strb	r3, [r6, #6]
10008756:	80b2      	strh	r2, [r6, #4]
    obj->clock = *cfg->clock;
10008758:	68aa      	ldr	r2, [r5, #8]
1000875a:	e892 0003 	ldmia.w	r2, {r0, r1}
1000875e:	f106 0310 	add.w	r3, r6, #16
10008762:	e883 0003 	stmia.w	r3, {r0, r1}
    obj->is_clock_owned = false;
10008766:	2300      	movs	r3, #0
10008768:	7373      	strb	r3, [r6, #13]
    obj->pin_tx = cfg->gpios.pin_tx;
1000876a:	7b2b      	ldrb	r3, [r5, #12]
1000876c:	7233      	strb	r3, [r6, #8]
    obj->pin_rts = cfg->gpios.pin_rts;
1000876e:	7b6b      	ldrb	r3, [r5, #13]
10008770:	72b3      	strb	r3, [r6, #10]
    obj->pin_cts = cfg->gpios.pin_cts;
10008772:	7bab      	ldrb	r3, [r5, #14]
10008774:	7273      	strb	r3, [r6, #9]
    obj->dc_configured = true;
10008776:	2301      	movs	r3, #1
10008778:	f886 30a4 	strb.w	r3, [r6, #164]	; 0xa4
    obj->cts_enabled = cfg->config->enableCts;
1000877c:	686b      	ldr	r3, [r5, #4]
1000877e:	f893 3020 	ldrb.w	r3, [r3, #32]
10008782:	72f3      	strb	r3, [r6, #11]
    obj->rts_enabled = (NC != cfg->gpios.pin_rts);
10008784:	7b6b      	ldrb	r3, [r5, #13]
10008786:	3bff      	subs	r3, #255	; 0xff
10008788:	bf18      	it	ne
1000878a:	2301      	movne	r3, #1
1000878c:	7333      	strb	r3, [r6, #12]
    obj->config = *cfg->config;
1000878e:	686d      	ldr	r5, [r5, #4]
10008790:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
10008792:	f106 0454 	add.w	r4, r6, #84	; 0x54
10008796:	c40f      	stmia	r4!, {r0, r1, r2, r3}
10008798:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1000879a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
1000879c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
1000879e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
100087a0:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
100087a4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return _cyhal_uart_init_hw(obj);
100087a8:	4630      	mov	r0, r6
}
100087aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return _cyhal_uart_init_hw(obj);
100087ae:	f7fd bacd 	b.w	10005d4c <_cyhal_uart_init_hw>

100087b2 <cyhal_uart_configure>:
{
100087b2:	b538      	push	{r3, r4, r5, lr}
100087b4:	460d      	mov	r5, r1
    CY_ASSERT(NULL != obj);
100087b6:	4604      	mov	r4, r0
100087b8:	b900      	cbnz	r0, 100087bc <cyhal_uart_configure+0xa>
100087ba:	be01      	bkpt	0x0001
    CY_ASSERT(NULL != cfg);
100087bc:	b905      	cbnz	r5, 100087c0 <cyhal_uart_configure+0xe>
100087be:	be01      	bkpt	0x0001
    Cy_SCB_UART_Disable(obj->base, NULL);
100087c0:	6820      	ldr	r0, [r4, #0]
100087c2:	2100      	movs	r1, #0
100087c4:	f7ff fcc2 	bl	1000814c <Cy_SCB_UART_Disable>
    obj->config.dataWidth = cfg->data_bits;
100087c8:	682b      	ldr	r3, [r5, #0]
100087ca:	65e3      	str	r3, [r4, #92]	; 0x5c
    obj->config.stopBits = _cyhal_uart_convert_stopbits((uint8_t)cfg->stop_bits);
100087cc:	7928      	ldrb	r0, [r5, #4]
100087ce:	f7ff ff4f 	bl	10008670 <_cyhal_uart_convert_stopbits>
100087d2:	f884 0061 	strb.w	r0, [r4, #97]	; 0x61
    obj->config.parity = _cyhal_uart_convert_parity(cfg->parity);
100087d6:	7a2b      	ldrb	r3, [r5, #8]
    switch (parity)
100087d8:	2b01      	cmp	r3, #1
100087da:	d015      	beq.n	10008808 <cyhal_uart_configure+0x56>
            return CY_SCB_UART_PARITY_NONE;
100087dc:	2b02      	cmp	r3, #2
100087de:	bf0c      	ite	eq
100087e0:	2303      	moveq	r3, #3
100087e2:	2300      	movne	r3, #0
    obj->config.parity = _cyhal_uart_convert_parity(cfg->parity);
100087e4:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
    obj->config.enableCts = obj->cts_enabled;
100087e8:	7ae3      	ldrb	r3, [r4, #11]
100087ea:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
    Cy_SCB_UART_Init(obj->base, &(obj->config), NULL);
100087ee:	6820      	ldr	r0, [r4, #0]
100087f0:	2200      	movs	r2, #0
100087f2:	f104 0154 	add.w	r1, r4, #84	; 0x54
100087f6:	f7fb fc59 	bl	100040ac <Cy_SCB_UART_Init>
    Cy_SCB_UART_Enable(obj->base);
100087fa:	6822      	ldr	r2, [r4, #0]
    SCB_CTRL(base) |= SCB_CTRL_ENABLED_Msk;
100087fc:	6813      	ldr	r3, [r2, #0]
100087fe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
10008802:	6013      	str	r3, [r2, #0]
}
10008804:	2000      	movs	r0, #0
10008806:	bd38      	pop	{r3, r4, r5, pc}
    switch (parity)
10008808:	2302      	movs	r3, #2
1000880a:	e7eb      	b.n	100087e4 <cyhal_uart_configure+0x32>

1000880c <_cyhal_scb_find_map>:
{
1000880c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
10008810:	4680      	mov	r8, r0
10008812:	4616      	mov	r6, r2
10008814:	461d      	mov	r5, r3
10008816:	460c      	mov	r4, r1
    for (size_t i = 0; i < count; i++)
10008818:	2700      	movs	r7, #0
                cyhal_resource_inst_t rsc = { CYHAL_RSC_SCB, pin_map[i].block_num, pin_map[i].channel_num };
1000881a:	f04f 0a17 	mov.w	sl, #23
    for (size_t i = 0; i < count; i++)
1000881e:	42b7      	cmp	r7, r6
10008820:	d102      	bne.n	10008828 <_cyhal_scb_find_map+0x1c>
    return NULL;
10008822:	f04f 0900 	mov.w	r9, #0
10008826:	e00f      	b.n	10008848 <_cyhal_scb_find_map+0x3c>
        if (pin == pin_map[i].pin)
10008828:	78a3      	ldrb	r3, [r4, #2]
1000882a:	4543      	cmp	r3, r8
1000882c:	46a1      	mov	r9, r4
1000882e:	d11e      	bne.n	1000886e <_cyhal_scb_find_map+0x62>
            if ((NULL != block_res) && (CYHAL_RSC_SCB == block_res->type))
10008830:	7823      	ldrb	r3, [r4, #0]
10008832:	b16d      	cbz	r5, 10008850 <_cyhal_scb_find_map+0x44>
10008834:	782a      	ldrb	r2, [r5, #0]
10008836:	2a17      	cmp	r2, #23
10008838:	d10a      	bne.n	10008850 <_cyhal_scb_find_map+0x44>
 * @param[in] map The pin map instance to compare
 * @return Boolean indicating whether two resources are the same
 */
static inline bool _cyhal_utils_map_resource_equal(const cyhal_resource_inst_t *resource, const cyhal_resource_pin_mapping_t *map)
{
    return (resource->block_num == map->block_num) && (resource->channel_num == map->channel_num);
1000883a:	786a      	ldrb	r2, [r5, #1]
1000883c:	429a      	cmp	r2, r3
1000883e:	d116      	bne.n	1000886e <_cyhal_scb_find_map+0x62>
10008840:	78aa      	ldrb	r2, [r5, #2]
10008842:	7863      	ldrb	r3, [r4, #1]
10008844:	429a      	cmp	r2, r3
10008846:	d112      	bne.n	1000886e <_cyhal_scb_find_map+0x62>
}
10008848:	4648      	mov	r0, r9
1000884a:	b002      	add	sp, #8
1000884c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                cyhal_resource_inst_t rsc = { CYHAL_RSC_SCB, pin_map[i].block_num, pin_map[i].channel_num };
10008850:	f88d 3005 	strb.w	r3, [sp, #5]
                if (CY_RSLT_SUCCESS == cyhal_hwmgr_reserve(&rsc))
10008854:	a801      	add	r0, sp, #4
                cyhal_resource_inst_t rsc = { CYHAL_RSC_SCB, pin_map[i].block_num, pin_map[i].channel_num };
10008856:	7863      	ldrb	r3, [r4, #1]
10008858:	f88d a004 	strb.w	sl, [sp, #4]
1000885c:	f88d 3006 	strb.w	r3, [sp, #6]
                if (CY_RSLT_SUCCESS == cyhal_hwmgr_reserve(&rsc))
10008860:	f7fe faee 	bl	10006e40 <cyhal_hwmgr_reserve>
10008864:	b918      	cbnz	r0, 1000886e <_cyhal_scb_find_map+0x62>
                    cyhal_hwmgr_free(&rsc);
10008866:	a801      	add	r0, sp, #4
10008868:	f7fe fb2a 	bl	10006ec0 <cyhal_hwmgr_free>
                    return &pin_map[i];
1000886c:	e7ec      	b.n	10008848 <_cyhal_scb_find_map+0x3c>
    for (size_t i = 0; i < count; i++)
1000886e:	3701      	adds	r7, #1
10008870:	3404      	adds	r4, #4
10008872:	e7d4      	b.n	1000881e <_cyhal_scb_find_map+0x12>

10008874 <_cyhal_clock_is_enabled_true>:
}
10008874:	2001      	movs	r0, #1
10008876:	4770      	bx	lr

10008878 <_cyhal_clock_get_sources_none>:
    *count = 0;
10008878:	2000      	movs	r0, #0
1000887a:	6010      	str	r0, [r2, #0]
}
1000887c:	4770      	bx	lr

1000887e <_cyhal_clock_get_frequency_ilo>:
}
1000887e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
10008882:	4770      	bx	lr

10008884 <_cyhal_clock_get_frequency_alt_sys_tick>:
10008884:	be01      	bkpt	0x0001
}
10008886:	2000      	movs	r0, #0
10008888:	4770      	bx	lr

1000888a <_cyhal_clock_get_frequency_ext>:
    return Cy_SysClk_ExtClkGetFrequency();
1000888a:	f7fc bc27 	b.w	100050dc <Cy_SysClk_ExtClkGetFrequency>

1000888e <_cyhal_clock_is_enabled_ext>:
{
1000888e:	b508      	push	{r3, lr}
    return (Cy_SysClk_ExtClkGetFrequency() > 0);
10008890:	f7fc fc24 	bl	100050dc <Cy_SysClk_ExtClkGetFrequency>
}
10008894:	3800      	subs	r0, #0
10008896:	bf18      	it	ne
10008898:	2001      	movne	r0, #1
1000889a:	bd08      	pop	{r3, pc}

1000889c <_cyhal_clock_get_frequency_eco>:
    return Cy_SysClk_EcoGetFrequency();
1000889c:	f7fc bc6e 	b.w	1000517c <Cy_SysClk_EcoGetFrequency>

100088a0 <_cyhal_clock_get_frequency_hf>:
    return Cy_SysClk_ClkHfGetFrequency(clock->channel);
100088a0:	7840      	ldrb	r0, [r0, #1]
100088a2:	f7ff be62 	b.w	1000856a <Cy_SysClk_ClkHfGetFrequency>

100088a6 <_cyhal_clock_get_frequency_pathmux>:
    return Cy_SysClk_ClkPathMuxGetFrequency(clock->channel);
100088a6:	7840      	ldrb	r0, [r0, #1]
100088a8:	f7fc bcb8 	b.w	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>

100088ac <_cyhal_clock_is_enabled_pll>:
    return Cy_SysClk_PllIsEnabled(clock->channel + 1);
100088ac:	7840      	ldrb	r0, [r0, #1]
100088ae:	3001      	adds	r0, #1
100088b0:	f7fc bdfe 	b.w	100054b0 <Cy_SysClk_PllIsEnabled>

100088b4 <_cyhal_clock_set_frequency_pll>:
{
100088b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint8_t pll_idx = clock->channel + 1;
100088b8:	7845      	ldrb	r5, [r0, #1]
100088ba:	3501      	adds	r5, #1
{
100088bc:	b086      	sub	sp, #24
    uint8_t pll_idx = clock->channel + 1;
100088be:	b2ed      	uxtb	r5, r5
{
100088c0:	4689      	mov	r9, r1
    cy_rslt_t rslt = Cy_SysClk_PllGetConfiguration(pll_idx, &cfg);
100088c2:	4628      	mov	r0, r5
100088c4:	a901      	add	r1, sp, #4
100088c6:	f7fc fe79 	bl	100055bc <Cy_SysClk_PllGetConfiguration>
    if (CY_RSLT_SUCCESS == rslt)
100088ca:	4604      	mov	r4, r0
100088cc:	2800      	cmp	r0, #0
100088ce:	d151      	bne.n	10008974 <_cyhal_clock_set_frequency_pll+0xc0>
        bool enabled = Cy_SysClk_PllIsEnabled(pll_idx);
100088d0:	4628      	mov	r0, r5
100088d2:	f7fc fded 	bl	100054b0 <Cy_SysClk_PllIsEnabled>
        if (enabled)
100088d6:	4680      	mov	r8, r0
100088d8:	2800      	cmp	r0, #0
100088da:	d145      	bne.n	10008968 <_cyhal_clock_set_frequency_pll+0xb4>
            uint32_t src_freq = Cy_SysClk_ClkPathMuxGetFrequency(pll_idx);
100088dc:	4628      	mov	r0, r5
100088de:	f7fc fc9d 	bl	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>
            uint32_t old_freq = CY_SYSLIB_DIV_ROUND((uint64_t)src_freq * (uint64_t)cfg.feedbackDiv, (uint32_t)cfg.referenceDiv * (uint32_t)cfg.outputDiv);
100088e2:	f89d 3006 	ldrb.w	r3, [sp, #6]
100088e6:	f89d 2005 	ldrb.w	r2, [sp, #5]
100088ea:	f89d 7004 	ldrb.w	r7, [sp, #4]
100088ee:	fb12 f203 	smulbb	r2, r2, r3
100088f2:	2400      	movs	r4, #0
            uint32_t src_freq = Cy_SysClk_ClkPathMuxGetFrequency(pll_idx);
100088f4:	4606      	mov	r6, r0
            uint32_t old_freq = CY_SYSLIB_DIV_ROUND((uint64_t)src_freq * (uint64_t)cfg.feedbackDiv, (uint32_t)cfg.referenceDiv * (uint32_t)cfg.outputDiv);
100088f6:	4621      	mov	r1, r4
100088f8:	0850      	lsrs	r0, r2, #1
100088fa:	4623      	mov	r3, r4
100088fc:	fbe6 0107 	umlal	r0, r1, r6, r7
10008900:	f7f9 fd4e 	bl	100023a0 <__aeabi_uldivmod>
10008904:	4607      	mov	r7, r0
            uint32_t div = (uint32_t)Cy_SysClk_ClkHfGetDivider(0);
10008906:	4620      	mov	r0, r4
10008908:	f7fc fb7c 	bl	10005004 <Cy_SysClk_ClkHfGetDivider>
            uint32_t old_hf_freq = old_freq >> div;
1000890c:	40c7      	lsrs	r7, r0
            uint32_t new_hf_freq = hz/*new_freq*/ >> div;
1000890e:	fa29 f600 	lsr.w	r6, r9, r0
            bool pll_sources_hf0 = (pll_idx == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
10008912:	4620      	mov	r0, r4
10008914:	f7fc fb46 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
            if (pll_sources_hf0)
10008918:	42a8      	cmp	r0, r5
            bool pll_sources_hf0 = (pll_idx == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
1000891a:	4682      	mov	sl, r0
            if (pll_sources_hf0)
1000891c:	d104      	bne.n	10008928 <_cyhal_clock_set_frequency_pll+0x74>
                _cyhal_clock_update_system_state(true, old_hf_freq, new_hf_freq);
1000891e:	4632      	mov	r2, r6
10008920:	4639      	mov	r1, r7
10008922:	2001      	movs	r0, #1
10008924:	f7fd fd3a 	bl	1000639c <_cyhal_clock_update_system_state>
            uint32_t input_hz = Cy_SysClk_ClkPathMuxGetFrequency(pll_idx);
10008928:	4628      	mov	r0, r5
1000892a:	f7fc fc77 	bl	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>
            cy_stc_pll_config_t cfg2 =
1000892e:	2300      	movs	r3, #0
10008930:	e9cd 0903 	strd	r0, r9, [sp, #12]
            rslt = Cy_SysClk_PllConfigure(pll_idx, &cfg2);
10008934:	a903      	add	r1, sp, #12
10008936:	4628      	mov	r0, r5
            cy_stc_pll_config_t cfg2 =
10008938:	f8ad 3014 	strh.w	r3, [sp, #20]
            rslt = Cy_SysClk_PllConfigure(pll_idx, &cfg2);
1000893c:	f7fc fe64 	bl	10005608 <Cy_SysClk_PllConfigure>
10008940:	4604      	mov	r4, r0
            if (enabled)
10008942:	f1b8 0f00 	cmp.w	r8, #0
10008946:	d006      	beq.n	10008956 <_cyhal_clock_set_frequency_pll+0xa2>
                cy_rslt_t rslt2 = Cy_SysClk_PllEnable(pll_idx, _CYHAL_CLOCK_PLL_LOCK_TIME);
10008948:	f242 7110 	movw	r1, #10000	; 0x2710
1000894c:	4628      	mov	r0, r5
1000894e:	f7fc ff19 	bl	10005784 <Cy_SysClk_PllEnable>
                if (CY_RSLT_SUCCESS == rslt)
10008952:	b99c      	cbnz	r4, 1000897c <_cyhal_clock_set_frequency_pll+0xc8>
                    rslt = rslt2;
10008954:	4604      	mov	r4, r0
            if (pll_sources_hf0)
10008956:	45aa      	cmp	sl, r5
10008958:	d10c      	bne.n	10008974 <_cyhal_clock_set_frequency_pll+0xc0>
                if (CY_RSLT_SUCCESS == rslt)
1000895a:	b98c      	cbnz	r4, 10008980 <_cyhal_clock_set_frequency_pll+0xcc>
                    _cyhal_clock_update_system_state(false, old_hf_freq, new_hf_freq);
1000895c:	4632      	mov	r2, r6
1000895e:	4639      	mov	r1, r7
                    _cyhal_clock_update_system_state(false, new_hf_freq, old_hf_freq);
10008960:	2000      	movs	r0, #0
10008962:	f7fd fd1b 	bl	1000639c <_cyhal_clock_update_system_state>
    return rslt;
10008966:	e005      	b.n	10008974 <_cyhal_clock_set_frequency_pll+0xc0>
            rslt = Cy_SysClk_PllDisable(pll_idx);
10008968:	4628      	mov	r0, r5
1000896a:	f7fc fdb5 	bl	100054d8 <Cy_SysClk_PllDisable>
        if (CY_RSLT_SUCCESS == rslt)
1000896e:	4604      	mov	r4, r0
10008970:	2800      	cmp	r0, #0
10008972:	d0b3      	beq.n	100088dc <_cyhal_clock_set_frequency_pll+0x28>
}
10008974:	4620      	mov	r0, r4
10008976:	b006      	add	sp, #24
10008978:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (pll_sources_hf0)
1000897c:	45aa      	cmp	sl, r5
1000897e:	d1f9      	bne.n	10008974 <_cyhal_clock_set_frequency_pll+0xc0>
                    _cyhal_clock_update_system_state(false, new_hf_freq, old_hf_freq);
10008980:	463a      	mov	r2, r7
10008982:	4631      	mov	r1, r6
10008984:	e7ec      	b.n	10008960 <_cyhal_clock_set_frequency_pll+0xac>

10008986 <_cyhal_clock_set_enabled_pll>:
{
10008986:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t pll_idx = clock->channel + 1;
1000898a:	7845      	ldrb	r5, [r0, #1]
1000898c:	3501      	adds	r5, #1
{
1000898e:	4689      	mov	r9, r1
    cy_rslt_t rslt = Cy_SysClk_PllGetConfiguration(pll_idx, &cfg);
10008990:	4628      	mov	r0, r5
10008992:	4669      	mov	r1, sp
{
10008994:	4690      	mov	r8, r2
    cy_rslt_t rslt = Cy_SysClk_PllGetConfiguration(pll_idx, &cfg);
10008996:	f7fc fe11 	bl	100055bc <Cy_SysClk_PllGetConfiguration>
    if (CY_RSLT_SUCCESS == rslt)
1000899a:	4604      	mov	r4, r0
1000899c:	2800      	cmp	r0, #0
1000899e:	d152      	bne.n	10008a46 <_cyhal_clock_set_enabled_pll+0xc0>
        uint32_t div = (uint32_t)Cy_SysClk_ClkHfGetDivider(0);
100089a0:	f7fc fb30 	bl	10005004 <Cy_SysClk_ClkHfGetDivider>
100089a4:	4607      	mov	r7, r0
        uint32_t src_freq = Cy_SysClk_ClkPathMuxGetFrequency(pll_idx);
100089a6:	4628      	mov	r0, r5
100089a8:	f7fc fc38 	bl	1000521c <Cy_SysClk_ClkPathMuxGetFrequency>
        uint32_t pll_freq = CY_SYSLIB_DIV_ROUND((uint64_t)src_freq * (uint64_t)cfg.feedbackDiv, (uint32_t)cfg.referenceDiv * (uint32_t)cfg.outputDiv);
100089ac:	f89d 3002 	ldrb.w	r3, [sp, #2]
100089b0:	f89d 2001 	ldrb.w	r2, [sp, #1]
100089b4:	f89d 6000 	ldrb.w	r6, [sp]
100089b8:	fb12 f203 	smulbb	r2, r2, r3
        uint32_t src_freq = Cy_SysClk_ClkPathMuxGetFrequency(pll_idx);
100089bc:	4682      	mov	sl, r0
        uint32_t pll_freq = CY_SYSLIB_DIV_ROUND((uint64_t)src_freq * (uint64_t)cfg.feedbackDiv, (uint32_t)cfg.referenceDiv * (uint32_t)cfg.outputDiv);
100089be:	4621      	mov	r1, r4
100089c0:	0850      	lsrs	r0, r2, #1
100089c2:	fbea 0106 	umlal	r0, r1, sl, r6
100089c6:	4623      	mov	r3, r4
100089c8:	f7f9 fcea 	bl	100023a0 <__aeabi_uldivmod>
100089cc:	4606      	mov	r6, r0
        if (enabled)
100089ce:	f1b9 0f00 	cmp.w	r9, #0
100089d2:	d019      	beq.n	10008a08 <_cyhal_clock_set_enabled_pll+0x82>
            new_freq = pll_freq >> div;
100089d4:	fa20 f907 	lsr.w	r9, r0, r7
        bool pll_sources_hf0 = (pll_idx == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
100089d8:	4620      	mov	r0, r4
100089da:	f7fc fae3 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
        if (pll_sources_hf0)
100089de:	4285      	cmp	r5, r0
            old_freq = src_freq >> div;
100089e0:	fa2a f607 	lsr.w	r6, sl, r7
        bool pll_sources_hf0 = (pll_idx == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
100089e4:	4607      	mov	r7, r0
        if (pll_sources_hf0)
100089e6:	d104      	bne.n	100089f2 <_cyhal_clock_set_enabled_pll+0x6c>
            _cyhal_clock_update_system_state(true, old_freq, new_freq);
100089e8:	464a      	mov	r2, r9
100089ea:	4631      	mov	r1, r6
100089ec:	2001      	movs	r0, #1
100089ee:	f7fd fcd5 	bl	1000639c <_cyhal_clock_update_system_state>
            ? Cy_SysClk_PllEnable(pll_idx, wait_for_lock ? _CYHAL_CLOCK_PLL_LOCK_TIME : 0UL)
100089f2:	f242 7110 	movw	r1, #10000	; 0x2710
100089f6:	f1b8 0f00 	cmp.w	r8, #0
100089fa:	bf08      	it	eq
100089fc:	4621      	moveq	r1, r4
100089fe:	4628      	mov	r0, r5
10008a00:	f7fc fec0 	bl	10005784 <Cy_SysClk_PllEnable>
10008a04:	4604      	mov	r4, r0
10008a06:	e011      	b.n	10008a2c <_cyhal_clock_set_enabled_pll+0xa6>
        bool pll_sources_hf0 = (pll_idx == (uint32_t)Cy_SysClk_ClkHfGetSource(0));
10008a08:	4620      	mov	r0, r4
10008a0a:	f7fc facb 	bl	10004fa4 <Cy_SysClk_ClkHfGetSource>
        if (pll_sources_hf0)
10008a0e:	42a8      	cmp	r0, r5
10008a10:	d115      	bne.n	10008a3e <_cyhal_clock_set_enabled_pll+0xb8>
            new_freq = src_freq >> div;
10008a12:	fa2a f907 	lsr.w	r9, sl, r7
            old_freq = pll_freq >> div;
10008a16:	40fe      	lsrs	r6, r7
            _cyhal_clock_update_system_state(true, old_freq, new_freq);
10008a18:	464a      	mov	r2, r9
10008a1a:	4631      	mov	r1, r6
10008a1c:	2001      	movs	r0, #1
10008a1e:	f7fd fcbd 	bl	1000639c <_cyhal_clock_update_system_state>
            : Cy_SysClk_PllDisable(pll_idx);
10008a22:	4628      	mov	r0, r5
10008a24:	f7fc fd58 	bl	100054d8 <Cy_SysClk_PllDisable>
10008a28:	462f      	mov	r7, r5
10008a2a:	4604      	mov	r4, r0
        if (pll_sources_hf0)
10008a2c:	42bd      	cmp	r5, r7
10008a2e:	d10a      	bne.n	10008a46 <_cyhal_clock_set_enabled_pll+0xc0>
            if (CY_RSLT_SUCCESS == rslt)
10008a30:	b96c      	cbnz	r4, 10008a4e <_cyhal_clock_set_enabled_pll+0xc8>
                _cyhal_clock_update_system_state(false, old_freq, new_freq);
10008a32:	464a      	mov	r2, r9
10008a34:	4631      	mov	r1, r6
                _cyhal_clock_update_system_state(false, new_freq, old_freq);
10008a36:	2000      	movs	r0, #0
10008a38:	f7fd fcb0 	bl	1000639c <_cyhal_clock_update_system_state>
    return rslt;
10008a3c:	e003      	b.n	10008a46 <_cyhal_clock_set_enabled_pll+0xc0>
            : Cy_SysClk_PllDisable(pll_idx);
10008a3e:	4628      	mov	r0, r5
10008a40:	f7fc fd4a 	bl	100054d8 <Cy_SysClk_PllDisable>
10008a44:	4604      	mov	r4, r0
}
10008a46:	4620      	mov	r0, r4
10008a48:	b002      	add	sp, #8
10008a4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                _cyhal_clock_update_system_state(false, new_freq, old_freq);
10008a4e:	4632      	mov	r2, r6
10008a50:	4649      	mov	r1, r9
10008a52:	e7f0      	b.n	10008a36 <_cyhal_clock_set_enabled_pll+0xb0>

10008a54 <_cyhal_clock_get_frequency_pll>:
    return Cy_SysClk_ClkPathGetFrequency(clock->channel + 1);
10008a54:	7840      	ldrb	r0, [r0, #1]
10008a56:	3001      	adds	r0, #1
10008a58:	f7fc bf52 	b.w	10005900 <Cy_SysClk_ClkPathGetFrequency>

10008a5c <_cyhal_clock_get_frequency_fll>:
    return Cy_SysClk_ClkPathGetFrequency(0);
10008a5c:	2000      	movs	r0, #0
10008a5e:	f7fc bf4f 	b.w	10005900 <Cy_SysClk_ClkPathGetFrequency>

10008a62 <_cyhal_clock_set_frequency_ext>:
{
10008a62:	b508      	push	{r3, lr}
    Cy_SysClk_ExtClkSetFrequency(hz);
10008a64:	4608      	mov	r0, r1
10008a66:	f7fc fb2f 	bl	100050c8 <Cy_SysClk_ExtClkSetFrequency>
}
10008a6a:	2000      	movs	r0, #0
10008a6c:	bd08      	pop	{r3, pc}

10008a6e <_cyhal_clock_set_enabled_ilo>:
{
10008a6e:	b508      	push	{r3, lr}
    if (enabled)
10008a70:	b119      	cbz	r1, 10008a7a <_cyhal_clock_set_enabled_ilo+0xc>
        Cy_SysClk_IloEnable();
10008a72:	f7fc fb05 	bl	10005080 <Cy_SysClk_IloEnable>
}
10008a76:	2000      	movs	r0, #0
10008a78:	bd08      	pop	{r3, pc}
        Cy_SysClk_IloDisable();
10008a7a:	f7fc fb13 	bl	100050a4 <Cy_SysClk_IloDisable>
10008a7e:	e7fa      	b.n	10008a76 <_cyhal_clock_set_enabled_ilo+0x8>

10008a80 <_cyhal_clock_is_enabled_ilo>:
    return Cy_SysClk_IloIsEnabled();
10008a80:	f7fc bb08 	b.w	10005094 <Cy_SysClk_IloIsEnabled>

10008a84 <_cyhal_clock_get_frequency_pump>:
    return Cy_SysClk_ClkPumpGetFrequency();
10008a84:	f7ff bd63 	b.w	1000854e <Cy_SysClk_ClkPumpGetFrequency>

10008a88 <_cyhal_clock_set_enabled_pump>:
{
10008a88:	b508      	push	{r3, lr}
    if (enabled)
10008a8a:	b119      	cbz	r1, 10008a94 <_cyhal_clock_set_enabled_pump+0xc>
        Cy_SysClk_ClkPumpEnable();
10008a8c:	f7fc f96c 	bl	10004d68 <Cy_SysClk_ClkPumpEnable>
}
10008a90:	2000      	movs	r0, #0
10008a92:	bd08      	pop	{r3, pc}
        Cy_SysClk_ClkPumpDisable();
10008a94:	f7fc f97a 	bl	10004d8c <Cy_SysClk_ClkPumpDisable>
10008a98:	e7fa      	b.n	10008a90 <_cyhal_clock_set_enabled_pump+0x8>

10008a9a <_cyhal_clock_is_enabled_pump>:
    return Cy_SysClk_ClkPumpIsEnabled();
10008a9a:	f7fc b96f 	b.w	10004d7c <Cy_SysClk_ClkPumpIsEnabled>

10008a9e <_cyhal_clock_get_frequency_bak>:
{
10008a9e:	b508      	push	{r3, lr}
    cy_en_clkbak_in_sources_t src = Cy_SysClk_ClkBakGetSource();
10008aa0:	f7fc f98e 	bl	10004dc0 <Cy_SysClk_ClkBakGetSource>
    if (src == CY_SYSCLK_BAK_IN_WCO)
10008aa4:	b910      	cbnz	r0, 10008aac <_cyhal_clock_get_frequency_bak+0xe>
        return CY_SYSCLK_WCO_FREQ;
10008aa6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
10008aaa:	bd08      	pop	{r3, pc}
    cy_en_clklf_in_sources_t source = Cy_SysClk_ClkLfGetSource();
10008aac:	f7fc f9de 	bl	10004e6c <Cy_SysClk_ClkLfGetSource>
    switch (source)
10008ab0:	2801      	cmp	r0, #1
10008ab2:	d9f8      	bls.n	10008aa6 <_cyhal_clock_get_frequency_bak+0x8>
10008ab4:	be01      	bkpt	0x0001
            return 0;
10008ab6:	2000      	movs	r0, #0
10008ab8:	e7f7      	b.n	10008aaa <_cyhal_clock_get_frequency_bak+0xc>

10008aba <_cyhal_clock_is_enabled_hf>:
    return Cy_SysClk_ClkHfIsEnabled(clock->channel);
10008aba:	7840      	ldrb	r0, [r0, #1]
10008abc:	f7fc ba2a 	b.w	10004f14 <Cy_SysClk_ClkHfIsEnabled>

10008ac0 <_cyhal_clock_is_enabled_fll>:
    return Cy_SysClk_FllIsEnabled();
10008ac0:	f7fc bbea 	b.w	10005298 <Cy_SysClk_FllIsEnabled>

10008ac4 <_cyhal_clock_set_frequency_fast>:
{
10008ac4:	b530      	push	{r4, r5, lr}
    uint32_t input_hz = Cy_SysClk_ClkHfGetFrequency(0);
10008ac6:	2000      	movs	r0, #0
{
10008ac8:	b085      	sub	sp, #20
10008aca:	460c      	mov	r4, r1
10008acc:	4615      	mov	r5, r2
    uint32_t input_hz = Cy_SysClk_ClkHfGetFrequency(0);
10008ace:	f7ff fd4c 	bl	1000856a <Cy_SysClk_ClkHfGetFrequency>
    cy_rslt_t rslt = _cyhal_clock_compute_div(input_hz, hz, 8, tolerance, &div);
10008ad2:	ab03      	add	r3, sp, #12
10008ad4:	9300      	str	r3, [sp, #0]
10008ad6:	4621      	mov	r1, r4
10008ad8:	462b      	mov	r3, r5
10008ada:	2208      	movs	r2, #8
10008adc:	f7fd fe9a 	bl	10006814 <_cyhal_clock_compute_div>
    if (CY_RSLT_SUCCESS == rslt)
10008ae0:	4604      	mov	r4, r0
10008ae2:	b930      	cbnz	r0, 10008af2 <_cyhal_clock_set_frequency_fast+0x2e>
        Cy_SysClk_ClkFastSetDivider((uint8_t)(div - 1));
10008ae4:	9803      	ldr	r0, [sp, #12]
10008ae6:	3801      	subs	r0, #1
10008ae8:	b2c0      	uxtb	r0, r0
10008aea:	f7fc f9df 	bl	10004eac <Cy_SysClk_ClkFastSetDivider>
        SystemCoreClockUpdate();
10008aee:	f7fb fa8b 	bl	10004008 <SystemCoreClockUpdate>
}
10008af2:	4620      	mov	r0, r4
10008af4:	b005      	add	sp, #20
10008af6:	bd30      	pop	{r4, r5, pc}

10008af8 <_cyhal_clock_get_frequency_fast>:
    return Cy_SysClk_ClkFastGetFrequency();
10008af8:	f7ff bd9e 	b.w	10008638 <Cy_SysClk_ClkFastGetFrequency>

10008afc <_cyhal_clock_set_frequency_peri>:
{
10008afc:	b530      	push	{r4, r5, lr}
    uint32_t input_hz = Cy_SysClk_ClkHfGetFrequency(0);
10008afe:	2000      	movs	r0, #0
{
10008b00:	b085      	sub	sp, #20
10008b02:	460c      	mov	r4, r1
10008b04:	4615      	mov	r5, r2
    uint32_t input_hz = Cy_SysClk_ClkHfGetFrequency(0);
10008b06:	f7ff fd30 	bl	1000856a <Cy_SysClk_ClkHfGetFrequency>
    cy_rslt_t rslt = _cyhal_clock_compute_div(input_hz, hz, 8, tolerance, &div);
10008b0a:	ab03      	add	r3, sp, #12
10008b0c:	9300      	str	r3, [sp, #0]
10008b0e:	4621      	mov	r1, r4
10008b10:	462b      	mov	r3, r5
10008b12:	2208      	movs	r2, #8
10008b14:	f7fd fe7e 	bl	10006814 <_cyhal_clock_compute_div>
    if (CY_RSLT_SUCCESS == rslt)
10008b18:	4604      	mov	r4, r0
10008b1a:	b930      	cbnz	r0, 10008b2a <_cyhal_clock_set_frequency_peri+0x2e>
        Cy_SysClk_ClkPeriSetDivider((uint8_t)(div - 1));
10008b1c:	9803      	ldr	r0, [sp, #12]
10008b1e:	3801      	subs	r0, #1
10008b20:	b2c0      	uxtb	r0, r0
10008b22:	f7fc f9ab 	bl	10004e7c <Cy_SysClk_ClkPeriSetDivider>
        SystemCoreClockUpdate();
10008b26:	f7fb fa6f 	bl	10004008 <SystemCoreClockUpdate>
}
10008b2a:	4620      	mov	r0, r4
10008b2c:	b005      	add	sp, #20
10008b2e:	bd30      	pop	{r4, r5, pc}

10008b30 <_cyhal_clock_get_frequency_peri>:
    return Cy_SysClk_ClkPeriGetFrequency();
10008b30:	f7ff bd2b 	b.w	1000858a <Cy_SysClk_ClkPeriGetFrequency>

10008b34 <_cyhal_clock_get_frequency_timer>:
    return Cy_SysClk_ClkTimerGetFrequency();
10008b34:	f7fc bf02 	b.w	1000593c <Cy_SysClk_ClkTimerGetFrequency>

10008b38 <_cyhal_clock_set_enabled_timer>:
{
10008b38:	b508      	push	{r3, lr}
    if (enabled)
10008b3a:	b119      	cbz	r1, 10008b44 <_cyhal_clock_set_enabled_timer+0xc>
        Cy_SysClk_ClkTimerEnable();
10008b3c:	f7fc f96a 	bl	10004e14 <Cy_SysClk_ClkTimerEnable>
}
10008b40:	2000      	movs	r0, #0
10008b42:	bd08      	pop	{r3, pc}
        Cy_SysClk_ClkTimerDisable();
10008b44:	f7fc f978 	bl	10004e38 <Cy_SysClk_ClkTimerDisable>
10008b48:	e7fa      	b.n	10008b40 <_cyhal_clock_set_enabled_timer+0x8>

10008b4a <_cyhal_clock_is_enabled_timer>:
    return Cy_SysClk_ClkTimerIsEnabled();
10008b4a:	f7fc b96d 	b.w	10004e28 <Cy_SysClk_ClkTimerIsEnabled>

10008b4e <_cyhal_clock_set_frequency_slow>:
{
10008b4e:	b530      	push	{r4, r5, lr}
10008b50:	b085      	sub	sp, #20
10008b52:	460c      	mov	r4, r1
10008b54:	4615      	mov	r5, r2
    uint32_t input_hz = Cy_SysClk_ClkPeriGetFrequency();
10008b56:	f7ff fd18 	bl	1000858a <Cy_SysClk_ClkPeriGetFrequency>
    cy_rslt_t rslt = _cyhal_clock_compute_div(input_hz, hz, 8, tolerance, &div);
10008b5a:	ab03      	add	r3, sp, #12
10008b5c:	9300      	str	r3, [sp, #0]
10008b5e:	4621      	mov	r1, r4
10008b60:	462b      	mov	r3, r5
10008b62:	2208      	movs	r2, #8
10008b64:	f7fd fe56 	bl	10006814 <_cyhal_clock_compute_div>
    if (CY_RSLT_SUCCESS == rslt)
10008b68:	4604      	mov	r4, r0
10008b6a:	b930      	cbnz	r0, 10008b7a <_cyhal_clock_set_frequency_slow+0x2c>
        Cy_SysClk_ClkSlowSetDivider((uint8_t)(div - 1));
10008b6c:	9803      	ldr	r0, [sp, #12]
10008b6e:	3801      	subs	r0, #1
10008b70:	b2c0      	uxtb	r0, r0
10008b72:	f7fc f8ab 	bl	10004ccc <Cy_SysClk_ClkSlowSetDivider>
        SystemCoreClockUpdate();
10008b76:	f7fb fa47 	bl	10004008 <SystemCoreClockUpdate>
}
10008b7a:	4620      	mov	r0, r4
10008b7c:	b005      	add	sp, #20
10008b7e:	bd30      	pop	{r4, r5, pc}

10008b80 <_cyhal_clock_get_frequency_slow>:
    return Cy_SysClk_ClkSlowGetFrequency();
10008b80:	f7ff bd10 	b.w	100085a4 <Cy_SysClk_ClkSlowGetFrequency>

10008b84 <_cyhal_clock_set_frequency_peripheral>:
{
10008b84:	b5f0      	push	{r4, r5, r6, r7, lr}
10008b86:	4604      	mov	r4, r0
10008b88:	b085      	sub	sp, #20
10008b8a:	4616      	mov	r6, r2
10008b8c:	460d      	mov	r5, r1
    uint32_t input_hz = Cy_SysClk_ClkPeriGetFrequency();
10008b8e:	f7ff fcfc 	bl	1000858a <Cy_SysClk_ClkPeriGetFrequency>
    if ((clock->block & 0x02) == 0)
10008b92:	7823      	ldrb	r3, [r4, #0]
10008b94:	f013 0f02 	tst.w	r3, #2
10008b98:	aa03      	add	r2, sp, #12
10008b9a:	d114      	bne.n	10008bc6 <_cyhal_clock_set_frequency_peripheral+0x42>
        uint32_t bits = (clock->block == CYHAL_CLOCK_BLOCK_PERIPHERAL_8BIT) ? 8 : 16;
10008b9c:	2b00      	cmp	r3, #0
        cy_rslt_t rslt = _cyhal_clock_compute_div(input_hz, hz, bits, tolerance, &div);
10008b9e:	9200      	str	r2, [sp, #0]
10008ba0:	4633      	mov	r3, r6
10008ba2:	bf14      	ite	ne
10008ba4:	2210      	movne	r2, #16
10008ba6:	2208      	moveq	r2, #8
10008ba8:	4629      	mov	r1, r5
10008baa:	f7fd fe33 	bl	10006814 <_cyhal_clock_compute_div>
            : rslt;
10008bae:	bb18      	cbnz	r0, 10008bf8 <_cyhal_clock_set_frequency_peripheral+0x74>
    return Cy_SysClk_PeriphSetDivider(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel, div);
10008bb0:	7820      	ldrb	r0, [r4, #0]
10008bb2:	9a03      	ldr	r2, [sp, #12]
10008bb4:	7861      	ldrb	r1, [r4, #1]
10008bb6:	3a01      	subs	r2, #1
10008bb8:	f000 0003 	and.w	r0, r0, #3
}
10008bbc:	b005      	add	sp, #20
10008bbe:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
10008bc2:	f7fb bef5 	b.w	100049b0 <Cy_SysClk_PeriphSetDivider>
        uint32_t bits = (clock->block == CYHAL_CLOCK_BLOCK_PERIPHERAL_16_5BIT) ? 21 : 29; // Integer bits + 5
10008bc6:	2b02      	cmp	r3, #2
        cy_rslt_t rslt = _cyhal_clock_compute_div(input_hz << 5, hz, bits, tolerance, &div);
10008bc8:	9200      	str	r2, [sp, #0]
10008bca:	4633      	mov	r3, r6
10008bcc:	bf14      	ite	ne
10008bce:	221d      	movne	r2, #29
10008bd0:	2215      	moveq	r2, #21
10008bd2:	4629      	mov	r1, r5
10008bd4:	0140      	lsls	r0, r0, #5
10008bd6:	f7fd fe1d 	bl	10006814 <_cyhal_clock_compute_div>
        if (CY_RSLT_SUCCESS == rslt)
10008bda:	b968      	cbnz	r0, 10008bf8 <_cyhal_clock_set_frequency_peripheral+0x74>
            uint32_t div_int = (div >> 5) - 1;
10008bdc:	9b03      	ldr	r3, [sp, #12]
    return Cy_SysClk_PeriphSetFracDivider(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel, div_int, div_frac);
10008bde:	7820      	ldrb	r0, [r4, #0]
10008be0:	7861      	ldrb	r1, [r4, #1]
10008be2:	095a      	lsrs	r2, r3, #5
10008be4:	3a01      	subs	r2, #1
10008be6:	f003 031f 	and.w	r3, r3, #31
10008bea:	f000 0003 	and.w	r0, r0, #3
}
10008bee:	b005      	add	sp, #20
10008bf0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
10008bf4:	f7fb bf2c 	b.w	10004a50 <Cy_SysClk_PeriphSetFracDivider>
10008bf8:	b005      	add	sp, #20
10008bfa:	bdf0      	pop	{r4, r5, r6, r7, pc}

10008bfc <_cyhal_clock_get_frequency_peripheral>:
    return Cy_SysClk_PeriphGetFrequency(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
10008bfc:	7803      	ldrb	r3, [r0, #0]
10008bfe:	7841      	ldrb	r1, [r0, #1]
10008c00:	f003 0003 	and.w	r0, r3, #3
10008c04:	f7ff bcda 	b.w	100085bc <Cy_SysClk_PeriphGetFrequency>

10008c08 <_cyhal_clock_set_enabled_peripheral>:
{
10008c08:	b410      	push	{r4}
10008c0a:	4602      	mov	r2, r0
{
    #if defined(COMPONENT_CAT1B)
    return Cy_SysClk_PeriPclkEnableDivider(clk_dest, _CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
    #else
    CY_UNUSED_PARAMETER(clk_dest);
    return Cy_SysClk_PeriphEnableDivider(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
10008c0c:	7803      	ldrb	r3, [r0, #0]
10008c0e:	460c      	mov	r4, r1
10008c10:	f003 0003 	and.w	r0, r3, #3
10008c14:	7851      	ldrb	r1, [r2, #1]
        : _cyhal_utils_peri_pclk_disable_divider(_CYHAL_CLOCK_GET_PCLK_GR_NUM(clock->block), clock);
10008c16:	b114      	cbz	r4, 10008c1e <_cyhal_clock_set_enabled_peripheral+0x16>
}
10008c18:	bc10      	pop	{r4}
10008c1a:	f7fb bfc5 	b.w	10004ba8 <Cy_SysClk_PeriphEnableDivider>
10008c1e:	bc10      	pop	{r4}
{
    #if defined(COMPONENT_CAT1B)
    return Cy_SysClk_PeriPclkDisableDivider(clk_dest, _CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
    #else
    CY_UNUSED_PARAMETER(clk_dest);
    return Cy_SysClk_PeriphDisableDivider(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
10008c20:	f7fb bffa 	b.w	10004c18 <Cy_SysClk_PeriphDisableDivider>

10008c24 <_cyhal_clock_is_enabled_peripheral>:
    #elif defined(COMPONENT_CAT2)
    CY_UNUSED_PARAMETER(clk_dest);
    return Cy_SysClk_PeriphDividerIsEnabled(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
    #else
    CY_UNUSED_PARAMETER(clk_dest);
    return Cy_SysClk_PeriphGetDividerEnabled(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel);
10008c24:	7803      	ldrb	r3, [r0, #0]
10008c26:	7841      	ldrb	r1, [r0, #1]
10008c28:	f003 0003 	and.w	r0, r3, #3
10008c2c:	f7fc b81c 	b.w	10004c68 <Cy_SysClk_PeriphGetDividerEnabled>

10008c30 <_cyhal_clock_set_enabled_hf>:
        ? Cy_SysClk_ClkHfEnable(clock->channel)
10008c30:	7840      	ldrb	r0, [r0, #1]
        : Cy_SysClk_ClkHfDisable(clock->channel);
10008c32:	b109      	cbz	r1, 10008c38 <_cyhal_clock_set_enabled_hf+0x8>
        ? Cy_SysClk_ClkHfEnable(clock->channel)
10008c34:	f7fc b954 	b.w	10004ee0 <Cy_SysClk_ClkHfEnable>
        : Cy_SysClk_ClkHfDisable(clock->channel);
10008c38:	f7fc b97e 	b.w	10004f38 <Cy_SysClk_ClkHfDisable>

10008c3c <_cyhal_clock_get_frequency_wco>:
static uint32_t _cyhal_clock_get_frequency_wco(const cyhal_clock_t *clock)
10008c3c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
10008c40:	4770      	bx	lr

10008c42 <_cyhal_clock_set_divider_peripheral>:
{
10008c42:	b410      	push	{r4}
10008c44:	4603      	mov	r3, r0
    return ((clock->block & 0x02) == 0)
10008c46:	7804      	ldrb	r4, [r0, #0]
        ? _cyhal_utils_peri_pclk_set_divider(_CYHAL_CLOCK_GET_PCLK_GR_NUM(clock->block), clock, divider - 1)
10008c48:	1e4a      	subs	r2, r1, #1
    return Cy_SysClk_PeriphSetDivider(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel, div);
10008c4a:	7859      	ldrb	r1, [r3, #1]
        : _cyhal_utils_peri_pclk_set_frac_divider(_CYHAL_CLOCK_GET_PCLK_GR_NUM(clock->block), clock, divider - 1, 0);
10008c4c:	07a3      	lsls	r3, r4, #30
10008c4e:	f004 0003 	and.w	r0, r4, #3
10008c52:	d402      	bmi.n	10008c5a <_cyhal_clock_set_divider_peripheral+0x18>
}
10008c54:	bc10      	pop	{r4}
10008c56:	f7fb beab 	b.w	100049b0 <Cy_SysClk_PeriphSetDivider>
10008c5a:	bc10      	pop	{r4}
    return Cy_SysClk_PeriphSetFracDivider(_CYHAL_PERIPHERAL_GROUP_GET_DIVIDER_TYPE(clock->block), clock->channel, div_int, div_frac);
10008c5c:	2300      	movs	r3, #0
10008c5e:	f7fb bef7 	b.w	10004a50 <Cy_SysClk_PeriphSetFracDivider>

10008c62 <_cyhal_clock_get_frequency_lf>:
{
10008c62:	b508      	push	{r3, lr}
    cy_en_clklf_in_sources_t source = Cy_SysClk_ClkLfGetSource();
10008c64:	f7fc f902 	bl	10004e6c <Cy_SysClk_ClkLfGetSource>
    switch (source)
10008c68:	2801      	cmp	r0, #1
10008c6a:	d902      	bls.n	10008c72 <_cyhal_clock_get_frequency_lf+0x10>
10008c6c:	be01      	bkpt	0x0001
            return 0;
10008c6e:	2000      	movs	r0, #0
}
10008c70:	bd08      	pop	{r3, pc}
            return CY_SYSCLK_ILO_FREQ;
10008c72:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    return _cyhal_clock_get_lf_frequency();
10008c76:	e7fb      	b.n	10008c70 <_cyhal_clock_get_frequency_lf+0xe>

10008c78 <cyhal_clock_reserve>:
{
10008c78:	b573      	push	{r0, r1, r4, r5, r6, lr}
10008c7a:	460c      	mov	r4, r1
    CY_ASSERT(NULL != clock);
10008c7c:	4605      	mov	r5, r0
10008c7e:	b900      	cbnz	r0, 10008c82 <cyhal_clock_reserve+0xa>
10008c80:	be01      	bkpt	0x0001
    CY_ASSERT(NULL != clock_);
10008c82:	b904      	cbnz	r4, 10008c86 <cyhal_clock_reserve+0xe>
10008c84:	be01      	bkpt	0x0001
    cyhal_resource_inst_t clock_resource = { CYHAL_RSC_CLOCK, clock_->block, clock_->channel };
10008c86:	2305      	movs	r3, #5
10008c88:	f88d 3004 	strb.w	r3, [sp, #4]
10008c8c:	7823      	ldrb	r3, [r4, #0]
10008c8e:	f88d 3005 	strb.w	r3, [sp, #5]
    cy_rslt_t rslt = cyhal_hwmgr_reserve(&clock_resource);
10008c92:	a801      	add	r0, sp, #4
    cyhal_resource_inst_t clock_resource = { CYHAL_RSC_CLOCK, clock_->block, clock_->channel };
10008c94:	7863      	ldrb	r3, [r4, #1]
10008c96:	f88d 3006 	strb.w	r3, [sp, #6]
    cy_rslt_t rslt = cyhal_hwmgr_reserve(&clock_resource);
10008c9a:	f7fe f8d1 	bl	10006e40 <cyhal_hwmgr_reserve>
    if (CY_RSLT_SUCCESS == rslt)
10008c9e:	4606      	mov	r6, r0
10008ca0:	b930      	cbnz	r0, 10008cb0 <cyhal_clock_reserve+0x38>
        memcpy(clock, clock_, sizeof(cyhal_clock_t));
10008ca2:	2208      	movs	r2, #8
10008ca4:	4621      	mov	r1, r4
10008ca6:	4628      	mov	r0, r5
10008ca8:	f7ff f93f 	bl	10007f2a <memcpy>
        clock->reserved = true;
10008cac:	2301      	movs	r3, #1
10008cae:	70ab      	strb	r3, [r5, #2]
}
10008cb0:	4630      	mov	r0, r6
10008cb2:	b002      	add	sp, #8
10008cb4:	bd70      	pop	{r4, r5, r6, pc}

10008cb6 <cyhal_clock_set_enabled>:
    CY_ASSERT(NULL != clock);
10008cb6:	b900      	cbnz	r0, 10008cba <cyhal_clock_set_enabled+0x4>
10008cb8:	be01      	bkpt	0x0001
    if (clock->block == CYHAL_CLOCK_BLOCK_HF)
10008cba:	7803      	ldrb	r3, [r0, #0]
10008cbc:	2b12      	cmp	r3, #18
10008cbe:	d101      	bne.n	10008cc4 <cyhal_clock_set_enabled+0xe>
        return _cyhal_clock_set_enabled_hf(clock, enabled, wait_for_lock);
10008cc0:	f7ff bfb6 	b.w	10008c30 <_cyhal_clock_set_enabled_hf>
    else if (clock->block < 4 * _CYHAL_CLOCK_PERI_GROUPS)
10008cc4:	2b03      	cmp	r3, #3
10008cc6:	d801      	bhi.n	10008ccc <cyhal_clock_set_enabled+0x16>
        return _cyhal_clock_set_enabled_peripheral(clock, enabled, wait_for_lock);
10008cc8:	f7ff bf9e 	b.w	10008c08 <_cyhal_clock_set_enabled_peripheral>
        return ((cyhal_clock_funcs_t*)clock->funcs)->set_enabled(clock, enabled, wait_for_lock);
10008ccc:	6843      	ldr	r3, [r0, #4]
10008cce:	685b      	ldr	r3, [r3, #4]
10008cd0:	4718      	bx	r3

10008cd2 <cyhal_clock_set_divider>:
    CY_ASSERT(NULL != clock);
10008cd2:	b900      	cbnz	r0, 10008cd6 <cyhal_clock_set_divider+0x4>
10008cd4:	be01      	bkpt	0x0001
    if (clock->block == CYHAL_CLOCK_BLOCK_HF)
10008cd6:	7803      	ldrb	r3, [r0, #0]
10008cd8:	2b12      	cmp	r3, #18
10008cda:	d101      	bne.n	10008ce0 <cyhal_clock_set_divider+0xe>
        return _cyhal_clock_set_divider_hf(clock, divider);
10008cdc:	f7fd bca0 	b.w	10006620 <_cyhal_clock_set_divider_hf>
    else if (clock->block < 4 * _CYHAL_CLOCK_PERI_GROUPS)
10008ce0:	2b03      	cmp	r3, #3
10008ce2:	d801      	bhi.n	10008ce8 <cyhal_clock_set_divider+0x16>
        return _cyhal_clock_set_divider_peripheral(clock, divider);
10008ce4:	f7ff bfad 	b.w	10008c42 <_cyhal_clock_set_divider_peripheral>
        return ((cyhal_clock_funcs_t*)clock->funcs)->set_divider(clock, divider);
10008ce8:	6843      	ldr	r3, [r0, #4]
10008cea:	691b      	ldr	r3, [r3, #16]
10008cec:	4718      	bx	r3

10008cee <_cyhal_gpio_convert_drive_mode>:
    switch (drive_mode)
10008cee:	2808      	cmp	r0, #8
10008cf0:	d817      	bhi.n	10008d22 <_cyhal_gpio_convert_drive_mode+0x34>
10008cf2:	e8df f000 	tbb	[pc, r0]
10008cf6:	1d14      	.short	0x1d14
10008cf8:	0d0b1905 	.word	0x0d0b1905
10008cfc:	0f1b      	.short	0x0f1b
10008cfe:	11          	.byte	0x11
10008cff:	00          	.byte	0x00
            drvMode = CY_GPIO_DM_PULLUP;
10008d00:	200a      	movs	r0, #10
    if (direction == CYHAL_GPIO_DIR_OUTPUT)
10008d02:	2901      	cmp	r1, #1
10008d04:	d115      	bne.n	10008d32 <_cyhal_gpio_convert_drive_mode+0x44>
        drvMode &= _CYHAL_GPIO_DIRECTION_OUTPUT_MASK;
10008d06:	f000 0007 	and.w	r0, r0, #7
10008d0a:	4770      	bx	lr
            drvMode = CY_GPIO_DM_OD_DRIVESLOW;
10008d0c:	200c      	movs	r0, #12
            break;
10008d0e:	e7f8      	b.n	10008d02 <_cyhal_gpio_convert_drive_mode+0x14>
            drvMode = CY_GPIO_DM_OD_DRIVESHIGH;
10008d10:	200d      	movs	r0, #13
            break;
10008d12:	e7f6      	b.n	10008d02 <_cyhal_gpio_convert_drive_mode+0x14>
            drvMode = CY_GPIO_DM_PULLUP_DOWN;
10008d14:	200f      	movs	r0, #15
            break;
10008d16:	e7f4      	b.n	10008d02 <_cyhal_gpio_convert_drive_mode+0x14>
            if ((direction == CYHAL_GPIO_DIR_OUTPUT) || (direction == CYHAL_GPIO_DIR_BIDIRECTIONAL))
10008d18:	1e4b      	subs	r3, r1, #1
10008d1a:	2b01      	cmp	r3, #1
10008d1c:	d906      	bls.n	10008d2c <_cyhal_gpio_convert_drive_mode+0x3e>
            return drvMode;
10008d1e:	2008      	movs	r0, #8
10008d20:	4770      	bx	lr
10008d22:	be01      	bkpt	0x0001
            drvMode = CY_GPIO_DM_HIGHZ;
10008d24:	2008      	movs	r0, #8
10008d26:	e7ec      	b.n	10008d02 <_cyhal_gpio_convert_drive_mode+0x14>
    switch (drive_mode)
10008d28:	200b      	movs	r0, #11
10008d2a:	e7ea      	b.n	10008d02 <_cyhal_gpio_convert_drive_mode+0x14>
            drvMode = CY_GPIO_DM_STRONG;
10008d2c:	200e      	movs	r0, #14
10008d2e:	e7e8      	b.n	10008d02 <_cyhal_gpio_convert_drive_mode+0x14>
            return drvMode;
10008d30:	2000      	movs	r0, #0
}
10008d32:	4770      	bx	lr

10008d34 <cyhal_gpio_init>:
{
10008d34:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
10008d38:	b085      	sub	sp, #20
    cyhal_resource_inst_t rsc = { CYHAL_RSC_GPIO, CYHAL_GET_PORT(pin), CYHAL_GET_PIN(pin) };
10008d3a:	08c7      	lsrs	r7, r0, #3
10008d3c:	f000 0407 	and.w	r4, r0, #7
10008d40:	461e      	mov	r6, r3
    cy_rslt_t status = cyhal_hwmgr_reserve(&pinRsc);
10008d42:	a803      	add	r0, sp, #12
    cyhal_resource_inst_t pinRsc = _cyhal_utils_get_gpio_resource(pin);
10008d44:	230b      	movs	r3, #11
{
10008d46:	4689      	mov	r9, r1
10008d48:	4690      	mov	r8, r2
    cyhal_resource_inst_t pinRsc = _cyhal_utils_get_gpio_resource(pin);
10008d4a:	f88d 300c 	strb.w	r3, [sp, #12]
10008d4e:	f88d 700d 	strb.w	r7, [sp, #13]
10008d52:	f88d 400e 	strb.w	r4, [sp, #14]
    cy_rslt_t status = cyhal_hwmgr_reserve(&pinRsc);
10008d56:	f7fe f873 	bl	10006e40 <cyhal_hwmgr_reserve>
    if (status == CY_RSLT_SUCCESS)
10008d5a:	4605      	mov	r5, r0
10008d5c:	b968      	cbnz	r0, 10008d7a <cyhal_gpio_init+0x46>
        uint32_t pdl_drive_mode = _cyhal_gpio_convert_drive_mode(drive_mode, direction);
10008d5e:	4649      	mov	r1, r9
10008d60:	4640      	mov	r0, r8
10008d62:	f7ff ffc4 	bl	10008cee <_cyhal_gpio_convert_drive_mode>
10008d66:	4601      	mov	r1, r0
        Cy_GPIO_Pin_FastInit(CYHAL_GET_PORTADDR(pin), CYHAL_GET_PIN(pin), pdl_drive_mode, init_val, HSIOM_SEL_GPIO);
10008d68:	4638      	mov	r0, r7
10008d6a:	f7fd fe7b 	bl	10006a64 <Cy_GPIO_PortToAddr>
10008d6e:	460a      	mov	r2, r1
10008d70:	9500      	str	r5, [sp, #0]
10008d72:	4633      	mov	r3, r6
10008d74:	4621      	mov	r1, r4
10008d76:	f7fb fb81 	bl	1000447c <Cy_GPIO_Pin_FastInit>
}
10008d7a:	4628      	mov	r0, r5
10008d7c:	b005      	add	sp, #20
10008d7e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

10008d82 <_cyhal_disconnect_signal>:
    return _cyhal_interconnect_check_connection(source, dest, CYHAL_CONNECT_TYPE_DISCONNECT);
10008d82:	2202      	movs	r2, #2
10008d84:	f7fe b8c0 	b.w	10006f08 <_cyhal_interconnect_check_connection>

10008d88 <_cyhal_syspm_remove_callback_from_list>:
{
10008d88:	b538      	push	{r3, r4, r5, lr}
10008d8a:	4604      	mov	r4, r0
10008d8c:	460d      	mov	r5, r1
    uint32_t intr_status = cyhal_system_critical_section_enter();
10008d8e:	f7f9 fab0 	bl	100022f2 <Cy_SysLib_EnterCriticalSection>
    while(*list != CYHAL_SYSPM_END_OF_LIST)
10008d92:	f240 7289 	movw	r2, #1929	; 0x789
10008d96:	6823      	ldr	r3, [r4, #0]
10008d98:	4293      	cmp	r3, r2
10008d9a:	d005      	beq.n	10008da8 <_cyhal_syspm_remove_callback_from_list+0x20>
        if (*list == remove)
10008d9c:	42ab      	cmp	r3, r5
10008d9e:	d107      	bne.n	10008db0 <_cyhal_syspm_remove_callback_from_list+0x28>
            *list = remove->next;
10008da0:	68eb      	ldr	r3, [r5, #12]
10008da2:	6023      	str	r3, [r4, #0]
            remove->next = NULL;
10008da4:	2300      	movs	r3, #0
10008da6:	60eb      	str	r3, [r5, #12]
}
10008da8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    cyhal_system_critical_section_exit(intr_status);
10008dac:	f7f9 baa5 	b.w	100022fa <Cy_SysLib_ExitCriticalSection>
        list = &((*list)->next);
10008db0:	f103 040c 	add.w	r4, r3, #12
10008db4:	e7ef      	b.n	10008d96 <_cyhal_syspm_remove_callback_from_list+0xe>

10008db6 <_cyhal_utils_reserve_and_connect>:
{
10008db6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    cyhal_resource_inst_t pinRsc = _cyhal_utils_get_gpio_resource(mapping->pin);
10008db8:	7883      	ldrb	r3, [r0, #2]
10008dba:	220b      	movs	r2, #11
10008dbc:	f88d 2004 	strb.w	r2, [sp, #4]
{
10008dc0:	4605      	mov	r5, r0
10008dc2:	08da      	lsrs	r2, r3, #3
    cy_rslt_t status = cyhal_hwmgr_reserve(&pinRsc);
10008dc4:	a801      	add	r0, sp, #4
10008dc6:	f003 0307 	and.w	r3, r3, #7
{
10008dca:	460e      	mov	r6, r1
    cyhal_resource_inst_t pinRsc = _cyhal_utils_get_gpio_resource(mapping->pin);
10008dcc:	f88d 2005 	strb.w	r2, [sp, #5]
10008dd0:	f88d 3006 	strb.w	r3, [sp, #6]
    cy_rslt_t status = cyhal_hwmgr_reserve(&pinRsc);
10008dd4:	f7fe f834 	bl	10006e40 <cyhal_hwmgr_reserve>
    if (CY_RSLT_SUCCESS == status)
10008dd8:	4604      	mov	r4, r0
10008dda:	b940      	cbnz	r0, 10008dee <_cyhal_utils_reserve_and_connect+0x38>
        status = cyhal_connect_pin(mapping, drive_mode);
10008ddc:	4631      	mov	r1, r6
10008dde:	4628      	mov	r0, r5
10008de0:	f7fe f944 	bl	1000706c <cyhal_connect_pin>
        if (CY_RSLT_SUCCESS != status)
10008de4:	4604      	mov	r4, r0
10008de6:	b110      	cbz	r0, 10008dee <_cyhal_utils_reserve_and_connect+0x38>
            cyhal_hwmgr_free(&pinRsc);
10008de8:	a801      	add	r0, sp, #4
10008dea:	f7fe f869 	bl	10006ec0 <cyhal_hwmgr_free>
}
10008dee:	4620      	mov	r0, r4
10008df0:	b002      	add	sp, #8
10008df2:	bd70      	pop	{r4, r5, r6, pc}

10008df4 <_cyhal_utils_disconnect_and_free>:
{
10008df4:	b513      	push	{r0, r1, r4, lr}
10008df6:	4604      	mov	r4, r0
    cy_rslt_t rslt = cyhal_disconnect_pin(pin);
10008df8:	f7fe f960 	bl	100070bc <cyhal_disconnect_pin>
    CY_ASSERT(CY_RSLT_SUCCESS == rslt);
10008dfc:	b100      	cbz	r0, 10008e00 <_cyhal_utils_disconnect_and_free+0xc>
10008dfe:	be01      	bkpt	0x0001
    cyhal_resource_inst_t rsc = _cyhal_utils_get_gpio_resource(pin);
10008e00:	230b      	movs	r3, #11
10008e02:	f88d 3004 	strb.w	r3, [sp, #4]
    cyhal_hwmgr_free(&rsc);
10008e06:	a801      	add	r0, sp, #4
10008e08:	08e3      	lsrs	r3, r4, #3
10008e0a:	f004 0407 	and.w	r4, r4, #7
    cyhal_resource_inst_t rsc = _cyhal_utils_get_gpio_resource(pin);
10008e0e:	f88d 3005 	strb.w	r3, [sp, #5]
10008e12:	f88d 4006 	strb.w	r4, [sp, #6]
    cyhal_hwmgr_free(&rsc);
10008e16:	f7fe f853 	bl	10006ec0 <cyhal_hwmgr_free>
}
10008e1a:	b002      	add	sp, #8
10008e1c:	bd10      	pop	{r4, pc}

10008e1e <_cyhal_utils_convert_haltopdl_pm_mode>:
    switch (mode)
10008e1e:	1e43      	subs	r3, r0, #1
10008e20:	2b07      	cmp	r3, #7
10008e22:	d805      	bhi.n	10008e30 <_cyhal_utils_convert_haltopdl_pm_mode+0x12>
10008e24:	e8df f003 	tbb	[pc, r3]
10008e28:	06040605 	.word	0x06040605
10008e2c:	06040404 	.word	0x06040404
10008e30:	be01      	bkpt	0x0001
            return CY_SYSPM_CHECK_READY;
10008e32:	2001      	movs	r0, #1
}
10008e34:	4770      	bx	lr

10008e36 <z_device_state_init>:
void z_device_state_init(void)
{
	STRUCT_SECTION_FOREACH(device, dev) {
		z_object_init(dev);
	}
}
10008e36:	4770      	bx	lr

10008e38 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
10008e38:	b140      	cbz	r0, 10008e4c <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
10008e3a:	68c3      	ldr	r3, [r0, #12]
10008e3c:	7858      	ldrb	r0, [r3, #1]
10008e3e:	f010 0001 	ands.w	r0, r0, #1
10008e42:	bf1e      	ittt	ne
10008e44:	7818      	ldrbne	r0, [r3, #0]
10008e46:	fab0 f080 	clzne	r0, r0
10008e4a:	0940      	lsrne	r0, r0, #5
}
10008e4c:	4770      	bx	lr

10008e4e <arch_system_halt>:
	__asm__ volatile(
10008e4e:	f04f 0220 	mov.w	r2, #32
10008e52:	f3ef 8311 	mrs	r3, BASEPRI
10008e56:	f382 8812 	msr	BASEPRI_MAX, r2
10008e5a:	f3bf 8f6f 	isb	sy
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
10008e5e:	e7fe      	b.n	10008e5e <arch_system_halt+0x10>

10008e60 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
10008e60:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
10008e62:	f7ff fff4 	bl	10008e4e <arch_system_halt>

10008e66 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
10008e66:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10008e68:	4605      	mov	r5, r0
10008e6a:	460e      	mov	r6, r1
10008e6c:	f04f 0320 	mov.w	r3, #32
10008e70:	f3ef 8711 	mrs	r7, BASEPRI
10008e74:	f383 8812 	msr	BASEPRI_MAX, r3
10008e78:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
10008e7c:	f7fe fdc4 	bl	10007a08 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
10008e80:	4631      	mov	r1, r6
10008e82:	4604      	mov	r4, r0
10008e84:	4628      	mov	r0, r5
10008e86:	f7ff ffeb 	bl	10008e60 <k_sys_fatal_error_handler>
	__asm__ volatile(
10008e8a:	f387 8811 	msr	BASEPRI, r7
10008e8e:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
10008e92:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
10008e94:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
10008e98:	f7fa bc6c 	b.w	10003774 <z_impl_k_thread_abort>

10008e9c <z_early_memset>:
	(void) memset(dst, c, n);
10008e9c:	f7ff b850 	b.w	10007f40 <memset>

10008ea0 <z_early_memcpy>:
	(void) memcpy(dst, src, n);
10008ea0:	f7ff b843 	b.w	10007f2a <memcpy>

10008ea4 <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
10008ea4:	b508      	push	{r3, lr}
	__asm__ volatile(
10008ea6:	f04f 0220 	mov.w	r2, #32
10008eaa:	f3ef 8311 	mrs	r3, BASEPRI
10008eae:	f382 8812 	msr	BASEPRI_MAX, r2
10008eb2:	f3bf 8f6f 	isb	sy
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
10008eb6:	f7fa f9e3 	bl	10003280 <arch_cpu_idle>
10008eba:	e7f4      	b.n	10008ea6 <idle+0x2>

10008ebc <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
10008ebc:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
10008ec0:	6013      	str	r3, [r2, #0]
	next->prev = prev;
10008ec2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
10008ec4:	2300      	movs	r3, #0
	node->prev = NULL;
10008ec6:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
10008eca:	4770      	bx	lr

10008ecc <unpend_thread_no_timeout>:
{
10008ecc:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
10008ece:	f7ff fff5 	bl	10008ebc <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
10008ed2:	7b43      	ldrb	r3, [r0, #13]
10008ed4:	f023 0302 	bic.w	r3, r3, #2
10008ed8:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
10008eda:	2300      	movs	r3, #0
10008edc:	6083      	str	r3, [r0, #8]
}
10008ede:	bd08      	pop	{r3, pc}

10008ee0 <z_ready_thread>:
{
10008ee0:	b510      	push	{r4, lr}
10008ee2:	f04f 0320 	mov.w	r3, #32
10008ee6:	f3ef 8411 	mrs	r4, BASEPRI
10008eea:	f383 8812 	msr	BASEPRI_MAX, r3
10008eee:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
10008ef2:	f7fe fbd9 	bl	100076a8 <ready_thread>
	__asm__ volatile(
10008ef6:	f384 8811 	msr	BASEPRI, r4
10008efa:	f3bf 8f6f 	isb	sy
}
10008efe:	bd10      	pop	{r4, pc}

10008f00 <z_sched_wake_thread>:
{
10008f00:	b538      	push	{r3, r4, r5, lr}
10008f02:	4604      	mov	r4, r0
	__asm__ volatile(
10008f04:	f04f 0320 	mov.w	r3, #32
10008f08:	f3ef 8511 	mrs	r5, BASEPRI
10008f0c:	f383 8812 	msr	BASEPRI_MAX, r3
10008f10:	f3bf 8f6f 	isb	sy
		if (!killed) {
10008f14:	7b43      	ldrb	r3, [r0, #13]
10008f16:	f013 0f28 	tst.w	r3, #40	; 0x28
10008f1a:	d10b      	bne.n	10008f34 <z_sched_wake_thread+0x34>
			if (thread->base.pended_on != NULL) {
10008f1c:	6883      	ldr	r3, [r0, #8]
10008f1e:	b10b      	cbz	r3, 10008f24 <z_sched_wake_thread+0x24>
				unpend_thread_no_timeout(thread);
10008f20:	f7ff ffd4 	bl	10008ecc <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
10008f24:	7b63      	ldrb	r3, [r4, #13]
			if (is_timeout) {
10008f26:	b951      	cbnz	r1, 10008f3e <z_sched_wake_thread+0x3e>
10008f28:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
10008f2c:	7363      	strb	r3, [r4, #13]
			ready_thread(thread);
10008f2e:	4620      	mov	r0, r4
10008f30:	f7fe fbba 	bl	100076a8 <ready_thread>
	__asm__ volatile(
10008f34:	f385 8811 	msr	BASEPRI, r5
10008f38:	f3bf 8f6f 	isb	sy
}
10008f3c:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
10008f3e:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
}
10008f42:	e7f3      	b.n	10008f2c <z_sched_wake_thread+0x2c>

10008f44 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
10008f44:	2101      	movs	r1, #1
10008f46:	3818      	subs	r0, #24
10008f48:	f7ff bfda 	b.w	10008f00 <z_sched_wake_thread>

10008f4c <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
10008f4c:	4603      	mov	r3, r0
10008f4e:	b920      	cbnz	r0, 10008f5a <z_reschedule_irqlock+0xe>
10008f50:	f3ef 8205 	mrs	r2, IPSR
10008f54:	b90a      	cbnz	r2, 10008f5a <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
10008f56:	f7fa b9dd 	b.w	10003314 <arch_swap>
10008f5a:	f383 8811 	msr	BASEPRI, r3
10008f5e:	f3bf 8f6f 	isb	sy
}
10008f62:	4770      	bx	lr

10008f64 <z_reschedule_unlocked>:
	__asm__ volatile(
10008f64:	f04f 0320 	mov.w	r3, #32
10008f68:	f3ef 8011 	mrs	r0, BASEPRI
10008f6c:	f383 8812 	msr	BASEPRI_MAX, r3
10008f70:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
10008f74:	f7ff bfea 	b.w	10008f4c <z_reschedule_irqlock>

10008f78 <z_abort_timeout>:
{
10008f78:	b510      	push	{r4, lr}
10008f7a:	f04f 0220 	mov.w	r2, #32
10008f7e:	f3ef 8411 	mrs	r4, BASEPRI
10008f82:	f382 8812 	msr	BASEPRI_MAX, r2
10008f86:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
10008f8a:	6803      	ldr	r3, [r0, #0]
10008f8c:	b13b      	cbz	r3, 10008f9e <z_abort_timeout+0x26>
			remove_timeout(to);
10008f8e:	f7fe fde5 	bl	10007b5c <remove_timeout>
			ret = 0;
10008f92:	2000      	movs	r0, #0
	__asm__ volatile(
10008f94:	f384 8811 	msr	BASEPRI, r4
10008f98:	f3bf 8f6f 	isb	sy
}
10008f9c:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
10008f9e:	f06f 0015 	mvn.w	r0, #21
10008fa2:	e7f7      	b.n	10008f94 <z_abort_timeout+0x1c>

10008fa4 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
10008fa4:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
10008fa6:	f7fe fed5 	bl	10007d54 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
10008faa:	bd08      	pop	{r3, pc}

Disassembly of section .ramfunc:

08002000 <Cy_Flash_RAMDelay>:
        uint32_t ticks = (microseconds & 0xFFFFUL) * CY_FLASH_TICKS_FOR_1US;
 8002000:	b280      	uxth	r0, r0
    {
 8002002:	b510      	push	{r4, lr}
        if (ticks != CY_FLASH_NO_DELAY)
 8002004:	00c4      	lsls	r4, r0, #3
 8002006:	b330      	cbz	r0, 8002056 <Cy_Flash_RAMDelay+0x56>
            while(0U == _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_ACQUIRE(CY_IPC_STRUCT_PTR(CY_IPC_CHAN_DDFT))))
 8002008:	4a13      	ldr	r2, [pc, #76]	; (8002058 <Cy_Flash_RAMDelay+0x58>)
 800200a:	6811      	ldr	r1, [r2, #0]
 800200c:	f8b1 30ba 	ldrh.w	r3, [r1, #186]	; 0xba
 8002010:	6a09      	ldr	r1, [r1, #32]
 8002012:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8002016:	440b      	add	r3, r1
 8002018:	6819      	ldr	r1, [r3, #0]
 800201a:	2900      	cmp	r1, #0
 800201c:	dafc      	bge.n	8002018 <Cy_Flash_RAMDelay+0x18>
            SRSS_TST_DDFT_FAST_CTL_REG  = SRSS_TST_DDFT_FAST_CTL_MASK;
 800201e:	4b0f      	ldr	r3, [pc, #60]	; (800205c <Cy_Flash_RAMDelay+0x5c>)
 8002020:	213e      	movs	r1, #62	; 0x3e
 8002022:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
            SRSS_TST_DDFT_SLOW_CTL_REG  = SRSS_TST_DDFT_SLOW_CTL_MASK;
 8002026:	f641 711e 	movw	r1, #7966	; 0x1f1e
 800202a:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
            SRSS_CLK_OUTPUT_SLOW = _VAL2FLD(SRSS_CLK_OUTPUT_SLOW_SLOW_SEL0, CY_SYSCLK_MEAS_CLK_IMO) |
 800202e:	2106      	movs	r1, #6
 8002030:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
            SRSS_CLK_CAL_CNT1 = _VAL2FLD(SRSS_CLK_CAL_CNT1_CAL_COUNTER1, ticks);
 8002034:	f8c3 451c 	str.w	r4, [r3, #1308]	; 0x51c
            ticks = _FLD2VAL(SRSS_CLK_CAL_CNT1_CAL_COUNTER_DONE, SRSS_CLK_CAL_CNT1);
 8002038:	f8d3 151c 	ldr.w	r1, [r3, #1308]	; 0x51c
            REG_IPC_STRUCT_RELEASE(CY_IPC_STRUCT_PTR(CY_IPC_CHAN_DDFT)) = 0U;
 800203c:	6811      	ldr	r1, [r2, #0]
 800203e:	f8b1 20ba 	ldrh.w	r2, [r1, #186]	; 0xba
 8002042:	6a09      	ldr	r1, [r1, #32]
 8002044:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 8002048:	440a      	add	r2, r1
 800204a:	2100      	movs	r1, #0
 800204c:	6051      	str	r1, [r2, #4]
            while (0UL == _FLD2VAL(SRSS_CLK_CAL_CNT1_CAL_COUNTER_DONE, SRSS_CLK_CAL_CNT1))
 800204e:	f8d3 251c 	ldr.w	r2, [r3, #1308]	; 0x51c
 8002052:	2a00      	cmp	r2, #0
 8002054:	dafb      	bge.n	800204e <Cy_Flash_RAMDelay+0x4e>
    }
 8002056:	bd10      	pop	{r4, pc}
 8002058:	08003550 	.word	0x08003550
 800205c:	40260000 	.word	0x40260000

08002060 <Cy_Flash_NotifyHandler>:
    {
 8002060:	b508      	push	{r3, lr}
        if (CY_FLASH_ENTER_WAIT_LOOP == ipcMsgPtr->pktType)
 8002062:	7843      	ldrb	r3, [r0, #1]
 8002064:	2bff      	cmp	r3, #255	; 0xff
 8002066:	d113      	bne.n	8002090 <Cy_Flash_NotifyHandler+0x30>
            intr = Cy_SysLib_EnterCriticalSection();
 8002068:	f000 f952 	bl	8002310 <__Cy_SysLib_EnterCriticalSection_veneer>
 800206c:	4601      	mov	r1, r0
            semaStruct = (cy_stc_ipc_sema_t *)Cy_IPC_Drv_ReadDataValue(Cy_IPC_Drv_GetIpcBaseAddress(CY_IPC_CHAN_SEMA));
 800206e:	2003      	movs	r0, #3
 8002070:	f000 f952 	bl	8002318 <__Cy_IPC_Drv_GetIpcBaseAddress_veneer>
 8002074:	68c3      	ldr	r3, [r0, #12]
            semaPtr = &semaStruct->arrayPtr[semaIndex];
 8002076:	685b      	ldr	r3, [r3, #4]
            *semaPtr |= semaMask;
 8002078:	681a      	ldr	r2, [r3, #0]
 800207a:	f042 0201 	orr.w	r2, r2, #1
 800207e:	601a      	str	r2, [r3, #0]
            while (((*semaPtr) & semaMask) != 0UL)
 8002080:	681a      	ldr	r2, [r3, #0]
 8002082:	07d2      	lsls	r2, r2, #31
 8002084:	d4fc      	bmi.n	8002080 <Cy_Flash_NotifyHandler+0x20>
    }
 8002086:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            Cy_SysLib_ExitCriticalSection(intr);
 800208a:	4608      	mov	r0, r1
 800208c:	f000 b948 	b.w	8002320 <__Cy_SysLib_ExitCriticalSection_veneer>
    }
 8002090:	bd08      	pop	{r3, pc}

08002092 <Cy_Flash_ResumeIrqHandler>:
        {
 8002092:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                bookmark = FLASHC_FM_CTL_BOOKMARK & 0xffffUL;
 8002094:	4f1b      	ldr	r7, [pc, #108]	; (8002104 <Cy_Flash_ResumeIrqHandler+0x72>)
            IPC_STRUCT_Type * locIpcBase = Cy_IPC_Drv_GetIpcBaseAddress(CY_IPC_CHAN_CYPIPE_EP0);
 8002096:	2005      	movs	r0, #5
 8002098:	f000 f93e 	bl	8002318 <__Cy_IPC_Drv_GetIpcBaseAddress_veneer>
                bookmark = FLASHC_FM_CTL_BOOKMARK & 0xffffUL;
 800209c:	683b      	ldr	r3, [r7, #0]
 800209e:	685b      	ldr	r3, [r3, #4]
 80020a0:	f503 4370 	add.w	r3, r3, #61440	; 0xf000
            IPC_STRUCT_Type * locIpcBase = Cy_IPC_Drv_GetIpcBaseAddress(CY_IPC_CHAN_CYPIPE_EP0);
 80020a4:	4606      	mov	r6, r0
                bookmark = FLASHC_FM_CTL_BOOKMARK & 0xffffUL;
 80020a6:	6e1c      	ldr	r4, [r3, #96]	; 0x60
            uint32_t intr = Cy_SysLib_EnterCriticalSection();
 80020a8:	f000 f932 	bl	8002310 <__Cy_SysLib_EnterCriticalSection_veneer>
            uint32_t cm0s = CPUSS_CM0_STATUS;
 80020ac:	683b      	ldr	r3, [r7, #0]
 80020ae:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80020b2:	6819      	ldr	r1, [r3, #0]
 80020b4:	5889      	ldr	r1, [r1, r2]
            bool sflashSingleCore = (0U == SFLASH_SINGLE_CORE);
 80020b6:	f04f 52b0 	mov.w	r2, #369098752	; 0x16000000
                bookmark = FLASHC_FM_CTL_BOOKMARK & 0xffffUL;
 80020ba:	b2a4      	uxth	r4, r4
            bool sflashSingleCore = (0U == SFLASH_SINGLE_CORE);
 80020bc:	7ad2      	ldrb	r2, [r2, #11]
                (bookmark == CY_FLASH_WRITE_ROW_ERASE_BOOKMARK) || (bookmark == CY_FLASH_WRITE_ROW_PROGRAM_BOOKMARK))
 80020be:	3c01      	subs	r4, #1
            if ((bookmark == CY_FLASH_PROGRAM_ROW_BOOKMARK) || (bookmark == CY_FLASH_ERASE_ROW_BOOKMARK) ||
 80020c0:	2c03      	cmp	r4, #3
            uint32_t intr = Cy_SysLib_EnterCriticalSection();
 80020c2:	4605      	mov	r5, r0
            bool sflashSingleCore = (0U == SFLASH_SINGLE_CORE);
 80020c4:	b2d2      	uxtb	r2, r2
            if ((bookmark == CY_FLASH_PROGRAM_ROW_BOOKMARK) || (bookmark == CY_FLASH_ERASE_ROW_BOOKMARK) ||
 80020c6:	d817      	bhi.n	80020f8 <Cy_Flash_ResumeIrqHandler+0x66>
                if ((cm0s == (CPUSS_CM0_STATUS_SLEEPING_Msk | CPUSS_CM0_STATUS_SLEEPDEEP_Msk)) && sflashSingleCore)
 80020c8:	2903      	cmp	r1, #3
 80020ca:	d109      	bne.n	80020e0 <Cy_Flash_ResumeIrqHandler+0x4e>
 80020cc:	b942      	cbnz	r2, 80020e0 <Cy_Flash_ResumeIrqHandler+0x4e>
                    REG_IPC_STRUCT_NOTIFY(locIpcBase) = _VAL2FLD(IPC_STRUCT_NOTIFY_INTR_NOTIFY, (1UL << CY_IPC_INTR_CYPIPE_EP0));
 80020ce:	2208      	movs	r2, #8
 80020d0:	60b2      	str	r2, [r6, #8]
                    while (CPUSS_CM0_STATUS == (CPUSS_CM0_STATUS_SLEEPING_Msk | CPUSS_CM0_STATUS_SLEEPDEEP_Msk))
 80020d2:	681a      	ldr	r2, [r3, #0]
 80020d4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80020d8:	4413      	add	r3, r2
 80020da:	681a      	ldr	r2, [r3, #0]
 80020dc:	2a03      	cmp	r2, #3
 80020de:	d0fc      	beq.n	80020da <Cy_Flash_ResumeIrqHandler+0x48>
                Cy_Flash_RAMDelay(CY_FLASH_FINAL_STAGE_DELAY);
 80020e0:	f000 f926 	bl	8002330 <__Cy_SysClk_ClkSlowGetFrequency_veneer>
 80020e4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80020e8:	fbb0 f3f3 	udiv	r3, r0, r3
 80020ec:	4806      	ldr	r0, [pc, #24]	; (8002108 <Cy_Flash_ResumeIrqHandler+0x76>)
 80020ee:	fbb0 f0f3 	udiv	r0, r0, r3
 80020f2:	3082      	adds	r0, #130	; 0x82
 80020f4:	f7ff ff84 	bl	8002000 <Cy_Flash_RAMDelay>
            Cy_SysLib_ExitCriticalSection(intr);
 80020f8:	4628      	mov	r0, r5
        }
 80020fa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            Cy_SysLib_ExitCriticalSection(intr);
 80020fe:	f000 b90f 	b.w	8002320 <__Cy_SysLib_ExitCriticalSection_veneer>
 8002102:	bf00      	nop
 8002104:	08003550 	.word	0x08003550
 8002108:	000f4240 	.word	0x000f4240

0800210c <Cy_Flash_SendCmd>:
{
 800210c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002110:	4689      	mov	r9, r1
    volatile uint32_t *ipcLockStatus = &REG_IPC_STRUCT_LOCK_STATUS(locIpcBase);
 8002112:	4948      	ldr	r1, [pc, #288]	; (8002234 <Cy_Flash_SendCmd+0x128>)
{
 8002114:	4680      	mov	r8, r0
    IPC_STRUCT_Type * locIpcBase = Cy_IPC_Drv_GetIpcBaseAddress(CY_IPC_CHAN_SYSCALL);
 8002116:	2001      	movs	r0, #1
 8002118:	f000 f8fe 	bl	8002318 <__Cy_IPC_Drv_GetIpcBaseAddress_veneer>
    volatile uint32_t *ipcLockStatus = &REG_IPC_STRUCT_LOCK_STATUS(locIpcBase);
 800211c:	680b      	ldr	r3, [r1, #0]
 800211e:	f8d3 70bc 	ldr.w	r7, [r3, #188]	; 0xbc
    if (cy_device->flashRwwRequired != 0U)
 8002122:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
    IPC_STRUCT_Type * locIpcBase = Cy_IPC_Drv_GetIpcBaseAddress(CY_IPC_CHAN_SYSCALL);
 8002126:	4606      	mov	r6, r0
    volatile uint32_t *ipcLockStatus = &REG_IPC_STRUCT_LOCK_STATUS(locIpcBase);
 8002128:	4407      	add	r7, r0
    if (cy_device->flashRwwRequired != 0U)
 800212a:	2b00      	cmp	r3, #0
 800212c:	d06b      	beq.n	8002206 <Cy_Flash_SendCmd+0xfa>
        if (SFLASH_SINGLE_CORE == 0U)
 800212e:	f04f 53b0 	mov.w	r3, #369098752	; 0x16000000
 8002132:	7adb      	ldrb	r3, [r3, #11]
 8002134:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 8002138:	b14b      	cbz	r3, 800214e <Cy_Flash_SendCmd+0x42>
            intr = Cy_SysLib_EnterCriticalSection();
 800213a:	f000 f8e9 	bl	8002310 <__Cy_SysLib_EnterCriticalSection_veneer>
            if (0UL != _FLD2VAL(SRSS_CLK_CAL_CNT1_CAL_COUNTER_DONE, SRSS_CLK_CAL_CNT1))
 800213e:	4b3e      	ldr	r3, [pc, #248]	; (8002238 <Cy_Flash_SendCmd+0x12c>)
 8002140:	f8d3 351c 	ldr.w	r3, [r3, #1308]	; 0x51c
 8002144:	2b00      	cmp	r3, #0
            intr = Cy_SysLib_EnterCriticalSection();
 8002146:	4605      	mov	r5, r0
            if (0UL != _FLD2VAL(SRSS_CLK_CAL_CNT1_CAL_COUNTER_DONE, SRSS_CLK_CAL_CNT1))
 8002148:	db4e      	blt.n	80021e8 <Cy_Flash_SendCmd+0xdc>
            result = CY_FLASH_DRV_IPC_BUSY;
 800214a:	4c3c      	ldr	r4, [pc, #240]	; (800223c <Cy_Flash_SendCmd+0x130>)
 800214c:	e048      	b.n	80021e0 <Cy_Flash_SendCmd+0xd4>
            if (IS_CY_PIPE_FREE())
 800214e:	2005      	movs	r0, #5
 8002150:	f000 f8e2 	bl	8002318 <__Cy_IPC_Drv_GetIpcBaseAddress_veneer>
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
 8002154:	680b      	ldr	r3, [r1, #0]
 8002156:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800215a:	58c3      	ldr	r3, [r0, r3]
 800215c:	2b00      	cmp	r3, #0
 800215e:	da03      	bge.n	8002168 <Cy_Flash_SendCmd+0x5c>
    cy_en_flashdrv_status_t result = CY_FLASH_DRV_IPC_BUSY;
 8002160:	4c36      	ldr	r4, [pc, #216]	; (800223c <Cy_Flash_SendCmd+0x130>)
}
 8002162:	4620      	mov	r0, r4
 8002164:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                if (CY_IPC_SEMA_STATUS_LOCKED != Cy_IPC_Sema_Status(CY_FLASH_WAIT_SEMA))
 8002168:	4620      	mov	r0, r4
 800216a:	f000 f8cd 	bl	8002308 <__Cy_IPC_Sema_Status_veneer>
 800216e:	f8df a0d0 	ldr.w	sl, [pc, #208]	; 8002240 <Cy_Flash_SendCmd+0x134>
 8002172:	4550      	cmp	r0, sl
 8002174:	d0f4      	beq.n	8002160 <Cy_Flash_SendCmd+0x54>
                    if (CY_IPC_PIPE_SUCCESS == NOTIFY_PEER_CORE(ipcWaitMessage))
 8002176:	4a33      	ldr	r2, [pc, #204]	; (8002244 <Cy_Flash_SendCmd+0x138>)
 8002178:	4623      	mov	r3, r4
 800217a:	4620      	mov	r0, r4
 800217c:	6812      	ldr	r2, [r2, #0]
 800217e:	2101      	movs	r1, #1
 8002180:	f000 f8b6 	bl	80022f0 <__Cy_IPC_Pipe_SendMessage_veneer>
 8002184:	4604      	mov	r4, r0
 8002186:	2800      	cmp	r0, #0
 8002188:	d1ea      	bne.n	8002160 <Cy_Flash_SendCmd+0x54>
 800218a:	4d2f      	ldr	r5, [pc, #188]	; (8002248 <Cy_Flash_SendCmd+0x13c>)
                        while ((CY_IPC_SEMA_STATUS_LOCKED != Cy_IPC_Sema_Status(CY_FLASH_WAIT_SEMA)) && ((semaTryCount < CY_FLASH_SEMA_WAIT_MAX_TRIES)))
 800218c:	2000      	movs	r0, #0
 800218e:	f000 f8bb 	bl	8002308 <__Cy_IPC_Sema_Status_veneer>
 8002192:	4550      	cmp	r0, sl
 8002194:	d003      	beq.n	800219e <Cy_Flash_SendCmd+0x92>
 8002196:	42ac      	cmp	r4, r5
 8002198:	d0e2      	beq.n	8002160 <Cy_Flash_SendCmd+0x54>
                            ++semaTryCount;
 800219a:	3401      	adds	r4, #1
 800219c:	e7f6      	b.n	800218c <Cy_Flash_SendCmd+0x80>
                        if (semaTryCount < CY_FLASH_SEMA_WAIT_MAX_TRIES)
 800219e:	42ac      	cmp	r4, r5
 80021a0:	d0de      	beq.n	8002160 <Cy_Flash_SendCmd+0x54>
            intr = Cy_SysLib_EnterCriticalSection();
 80021a2:	f000 f8b5 	bl	8002310 <__Cy_SysLib_EnterCriticalSection_veneer>
            if (0UL != _FLD2VAL(SRSS_CLK_CAL_CNT1_CAL_COUNTER_DONE, SRSS_CLK_CAL_CNT1))
 80021a6:	4b24      	ldr	r3, [pc, #144]	; (8002238 <Cy_Flash_SendCmd+0x12c>)
 80021a8:	f8d3 351c 	ldr.w	r3, [r3, #1308]	; 0x51c
 80021ac:	2b00      	cmp	r3, #0
            intr = Cy_SysLib_EnterCriticalSection();
 80021ae:	4605      	mov	r5, r0
            if (0UL != _FLD2VAL(SRSS_CLK_CAL_CNT1_CAL_COUNTER_DONE, SRSS_CLK_CAL_CNT1))
 80021b0:	da21      	bge.n	80021f6 <Cy_Flash_SendCmd+0xea>
            isPeerCoreEnabled = true;
 80021b2:	f04f 0a01 	mov.w	sl, #1
    return Cy_IPC_Drv_SendMsgWord(base, notifyEventIntr, (uint32_t)msgPtr);
 80021b6:	4a25      	ldr	r2, [pc, #148]	; (800224c <Cy_Flash_SendCmd+0x140>)
 80021b8:	2101      	movs	r1, #1
 80021ba:	4630      	mov	r0, r6
 80021bc:	f000 f89c 	bl	80022f8 <__Cy_IPC_Drv_SendMsgWord_veneer>
                if (Cy_IPC_Drv_SendMsgPtr(locIpcBase, CY_FLASH_IPC_NOTIFY_STRUCT0, (void*)&flashContext) == CY_IPC_DRV_SUCCESS)
 80021c0:	b9a8      	cbnz	r0, 80021ee <Cy_Flash_SendCmd+0xe2>
                    Cy_Flash_RAMDelay(microseconds);
 80021c2:	4648      	mov	r0, r9
 80021c4:	f7ff ff1c 	bl	8002000 <Cy_Flash_RAMDelay>
                    if (mode == CY_FLASH_NON_BLOCKING_MODE)
 80021c8:	f1b8 0f00 	cmp.w	r8, #0
 80021cc:	d011      	beq.n	80021f2 <Cy_Flash_SendCmd+0xe6>
                        while (0U != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, *ipcLockStatus))
 80021ce:	683b      	ldr	r3, [r7, #0]
 80021d0:	2b00      	cmp	r3, #0
 80021d2:	dbfc      	blt.n	80021ce <Cy_Flash_SendCmd+0xc2>
                        result = Cy_Flash_OperationStatus();
 80021d4:	f000 f8a8 	bl	8002328 <__Cy_Flash_OperationStatus_veneer>
 80021d8:	4604      	mov	r4, r0
            if (isPeerCoreEnabled)
 80021da:	f1ba 0f00 	cmp.w	sl, #0
 80021de:	d10b      	bne.n	80021f8 <Cy_Flash_SendCmd+0xec>
        Cy_SysLib_ExitCriticalSection(intr);
 80021e0:	4628      	mov	r0, r5
 80021e2:	f000 f89d 	bl	8002320 <__Cy_SysLib_ExitCriticalSection_veneer>
    return (result);
 80021e6:	e7bc      	b.n	8002162 <Cy_Flash_SendCmd+0x56>
        bool isPeerCoreEnabled = false;
 80021e8:	f04f 0a00 	mov.w	sl, #0
 80021ec:	e7e3      	b.n	80021b6 <Cy_Flash_SendCmd+0xaa>
                    result = CY_FLASH_DRV_IPC_BUSY;
 80021ee:	4c13      	ldr	r4, [pc, #76]	; (800223c <Cy_Flash_SendCmd+0x130>)
 80021f0:	e7f3      	b.n	80021da <Cy_Flash_SendCmd+0xce>
                        result = CY_FLASH_DRV_OPERATION_STARTED;
 80021f2:	4c17      	ldr	r4, [pc, #92]	; (8002250 <Cy_Flash_SendCmd+0x144>)
 80021f4:	e7f1      	b.n	80021da <Cy_Flash_SendCmd+0xce>
                    result = CY_FLASH_DRV_IPC_BUSY;
 80021f6:	4c11      	ldr	r4, [pc, #68]	; (800223c <Cy_Flash_SendCmd+0x130>)
                while (CY_IPC_SEMA_SUCCESS != Cy_IPC_Sema_Clear(CY_FLASH_WAIT_SEMA, true))
 80021f8:	2101      	movs	r1, #1
 80021fa:	2000      	movs	r0, #0
 80021fc:	f000 f880 	bl	8002300 <__Cy_IPC_Sema_Clear_veneer>
 8002200:	2800      	cmp	r0, #0
 8002202:	d1f9      	bne.n	80021f8 <Cy_Flash_SendCmd+0xec>
 8002204:	e7ec      	b.n	80021e0 <Cy_Flash_SendCmd+0xd4>
        intr = Cy_SysLib_EnterCriticalSection();
 8002206:	f000 f883 	bl	8002310 <__Cy_SysLib_EnterCriticalSection_veneer>
 800220a:	4a10      	ldr	r2, [pc, #64]	; (800224c <Cy_Flash_SendCmd+0x140>)
 800220c:	4605      	mov	r5, r0
 800220e:	2101      	movs	r1, #1
 8002210:	4630      	mov	r0, r6
 8002212:	f000 f871 	bl	80022f8 <__Cy_IPC_Drv_SendMsgWord_veneer>
        if (Cy_IPC_Drv_SendMsgPtr(locIpcBase, CY_FLASH_IPC_NOTIFY_STRUCT0, (void*)&flashContext) == CY_IPC_DRV_SUCCESS)
 8002216:	2800      	cmp	r0, #0
 8002218:	d197      	bne.n	800214a <Cy_Flash_SendCmd+0x3e>
            if (mode == CY_FLASH_NON_BLOCKING_MODE)
 800221a:	f1b8 0f00 	cmp.w	r8, #0
 800221e:	d006      	beq.n	800222e <Cy_Flash_SendCmd+0x122>
                while (0U != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, *ipcLockStatus))
 8002220:	683b      	ldr	r3, [r7, #0]
 8002222:	2b00      	cmp	r3, #0
 8002224:	dbfc      	blt.n	8002220 <Cy_Flash_SendCmd+0x114>
                result = Cy_Flash_OperationStatus();
 8002226:	f000 f87f 	bl	8002328 <__Cy_Flash_OperationStatus_veneer>
 800222a:	4604      	mov	r4, r0
 800222c:	e7d8      	b.n	80021e0 <Cy_Flash_SendCmd+0xd4>
                result = CY_FLASH_DRV_OPERATION_STARTED;
 800222e:	4c08      	ldr	r4, [pc, #32]	; (8002250 <Cy_Flash_SendCmd+0x144>)
 8002230:	e7d6      	b.n	80021e0 <Cy_Flash_SendCmd+0xd4>
 8002232:	bf00      	nop
 8002234:	08003550 	.word	0x08003550
 8002238:	40260000 	.word	0x40260000
 800223c:	00520005 	.word	0x00520005
 8002240:	00880101 	.word	0x00880101
 8002244:	080036e4 	.word	0x080036e4
 8002248:	000249f0 	.word	0x000249f0
 800224c:	080036d4 	.word	0x080036d4
 8002250:	00500001 	.word	0x00500001

08002254 <EnterDeepSleepRam>:
{
 8002254:	b570      	push	{r4, r5, r6, lr}
    volatile uint32_t *delayDoneFlag = DELAY_FLAG_REGISTER_ADDR;
 8002256:	4b21      	ldr	r3, [pc, #132]	; (80022dc <EnterDeepSleepRam+0x88>)
        SCB_SCR |= SCB_SCR_SLEEPDEEP_Msk;
 8002258:	4c21      	ldr	r4, [pc, #132]	; (80022e0 <EnterDeepSleepRam+0x8c>)
    volatile uint32_t *delayDoneFlag = DELAY_FLAG_REGISTER_ADDR;
 800225a:	681b      	ldr	r3, [r3, #0]
            if(wasEventSent)
 800225c:	4d21      	ldr	r5, [pc, #132]	; (80022e4 <EnterDeepSleepRam+0x90>)
    volatile uint32_t *cpussCm4PwrCtlAddr = &CPUSS_CM4_PWR_CTL;
 800225e:	e9d3 2100 	ldrd	r2, r1, [r3]
 8002262:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
            wasEventSent = true;
 8002266:	2601      	movs	r6, #1
    volatile uint32_t *cpussCm4PwrCtlAddr = &CPUSS_CM4_PWR_CTL;
 8002268:	441a      	add	r2, r3
        SCB_SCR |= SCB_SCR_SLEEPDEEP_Msk;
 800226a:	6923      	ldr	r3, [r4, #16]
        if(waitFor != CY_SYSPM_WAIT_FOR_EVENT)
 800226c:	2801      	cmp	r0, #1
        SCB_SCR |= SCB_SCR_SLEEPDEEP_Msk;
 800226e:	f043 0304 	orr.w	r3, r3, #4
 8002272:	6123      	str	r3, [r4, #16]
        if(waitFor != CY_SYSPM_WAIT_FOR_EVENT)
 8002274:	d02b      	beq.n	80022ce <EnterDeepSleepRam+0x7a>
            __WFI();
 8002276:	bf30      	wfi
    } while (_FLD2VAL(CPUSS_CM4_PWR_CTL_PWR_MODE, (*cpussCm4PwrCtlAddr)) == CM4_PWR_STS_RETAINED);
 8002278:	6813      	ldr	r3, [r2, #0]
 800227a:	f003 0303 	and.w	r3, r3, #3
 800227e:	2b02      	cmp	r3, #2
 8002280:	d0f3      	beq.n	800226a <EnterDeepSleepRam+0x16>
    if (*delayDoneFlag == NEED_DELAY)
 8002282:	f8d1 310c 	ldr.w	r3, [r1, #268]	; 0x10c
 8002286:	bb0b      	cbnz	r3, 80022cc <EnterDeepSleepRam+0x78>
        ddftSlowCtl   = SRSS_TST_DDFT_SLOW_CTL_REG;
 8002288:	4b17      	ldr	r3, [pc, #92]	; (80022e8 <EnterDeepSleepRam+0x94>)
        SRSS_TST_DDFT_SLOW_CTL_REG = SRSS_TST_DDFT_SLOW_CTL_MASK;
 800228a:	f641 751e 	movw	r5, #7966	; 0x1f1e
        ddftSlowCtl   = SRSS_TST_DDFT_SLOW_CTL_REG;
 800228e:	f8d3 4108 	ldr.w	r4, [r3, #264]	; 0x108
        clkOutputSlow = SRSS_CLK_OUTPUT_SLOW;
 8002292:	f8d3 0518 	ldr.w	r0, [r3, #1304]	; 0x518
        ddftFastCtl   = SRSS_TST_DDFT_FAST_CTL_REG;
 8002296:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        SRSS_TST_DDFT_SLOW_CTL_REG = SRSS_TST_DDFT_SLOW_CTL_MASK;
 800229a:	f8c3 5108 	str.w	r5, [r3, #264]	; 0x108
        SRSS_CLK_OUTPUT_SLOW       = CLK_OUTPUT_SLOW_MASK;
 800229e:	2506      	movs	r5, #6
 80022a0:	f8c3 5518 	str.w	r5, [r3, #1304]	; 0x518
        SRSS_TST_DDFT_FAST_CTL_REG = TST_DDFT_FAST_CTL_MASK;
 80022a4:	253e      	movs	r5, #62	; 0x3e
 80022a6:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
        SRSS_CLK_CAL_CNT1 = IMO_10US_DELAY;
 80022aa:	2544      	movs	r5, #68	; 0x44
 80022ac:	f8c3 551c 	str.w	r5, [r3, #1308]	; 0x51c
        while (0U == (SRSS_CLK_CAL_CNT1 & SRSS_CLK_CAL_CNT1_CAL_COUNTER_DONE_Msk))
 80022b0:	f8d3 551c 	ldr.w	r5, [r3, #1308]	; 0x51c
 80022b4:	2d00      	cmp	r5, #0
 80022b6:	dafb      	bge.n	80022b0 <EnterDeepSleepRam+0x5c>
        *delayDoneFlag = DELAY_DONE;
 80022b8:	f04f 35aa 	mov.w	r5, #2863311530	; 0xaaaaaaaa
 80022bc:	f8c1 510c 	str.w	r5, [r1, #268]	; 0x10c
        SRSS_TST_DDFT_SLOW_CTL_REG = ddftSlowCtl;
 80022c0:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
        SRSS_CLK_OUTPUT_SLOW       = clkOutputSlow;
 80022c4:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518
        SRSS_TST_DDFT_FAST_CTL_REG = ddftFastCtl;
 80022c8:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
 80022cc:	bd70      	pop	{r4, r5, r6, pc}
            __WFE();
 80022ce:	bf20      	wfe
            if(wasEventSent)
 80022d0:	782b      	ldrb	r3, [r5, #0]
 80022d2:	b103      	cbz	r3, 80022d6 <EnterDeepSleepRam+0x82>
                __WFE();
 80022d4:	bf20      	wfe
            wasEventSent = true;
 80022d6:	702e      	strb	r6, [r5, #0]
 80022d8:	e7ce      	b.n	8002278 <EnterDeepSleepRam+0x24>
 80022da:	bf00      	nop
 80022dc:	08003550 	.word	0x08003550
 80022e0:	e000ed00 	.word	0xe000ed00
 80022e4:	080037dd 	.word	0x080037dd
 80022e8:	40260000 	.word	0x40260000
 80022ec:	00000000 	.word	0x00000000

080022f0 <__Cy_IPC_Pipe_SendMessage_veneer>:
 80022f0:	f85f f000 	ldr.w	pc, [pc]	; 80022f4 <__Cy_IPC_Pipe_SendMessage_veneer+0x4>
 80022f4:	10004715 	.word	0x10004715

080022f8 <__Cy_IPC_Drv_SendMsgWord_veneer>:
 80022f8:	f85f f000 	ldr.w	pc, [pc]	; 80022fc <__Cy_IPC_Drv_SendMsgWord_veneer+0x4>
 80022fc:	100045b1 	.word	0x100045b1

08002300 <__Cy_IPC_Sema_Clear_veneer>:
 8002300:	f85f f000 	ldr.w	pc, [pc]	; 8002304 <__Cy_IPC_Sema_Clear_veneer+0x4>
 8002304:	100048ed 	.word	0x100048ed

08002308 <__Cy_IPC_Sema_Status_veneer>:
 8002308:	f85f f000 	ldr.w	pc, [pc]	; 800230c <__Cy_IPC_Sema_Status_veneer+0x4>
 800230c:	10004975 	.word	0x10004975

08002310 <__Cy_SysLib_EnterCriticalSection_veneer>:
 8002310:	f85f f000 	ldr.w	pc, [pc]	; 8002314 <__Cy_SysLib_EnterCriticalSection_veneer+0x4>
 8002314:	100022f3 	.word	0x100022f3

08002318 <__Cy_IPC_Drv_GetIpcBaseAddress_veneer>:
 8002318:	f85f f000 	ldr.w	pc, [pc]	; 800231c <__Cy_IPC_Drv_GetIpcBaseAddress_veneer+0x4>
 800231c:	10004319 	.word	0x10004319

08002320 <__Cy_SysLib_ExitCriticalSection_veneer>:
 8002320:	f85f f000 	ldr.w	pc, [pc]	; 8002324 <__Cy_SysLib_ExitCriticalSection_veneer+0x4>
 8002324:	100022fb 	.word	0x100022fb

08002328 <__Cy_Flash_OperationStatus_veneer>:
 8002328:	f85f f000 	ldr.w	pc, [pc]	; 800232c <__Cy_Flash_OperationStatus_veneer+0x4>
 800232c:	100043e1 	.word	0x100043e1

08002330 <__Cy_SysClk_ClkSlowGetFrequency_veneer>:
 8002330:	f85f f000 	ldr.w	pc, [pc]	; 8002334 <__Cy_SysClk_ClkSlowGetFrequency_veneer+0x4>
 8002334:	100085a5 	.word	0x100085a5
	...
